#!/bin/bash
###############################################################################
#                                                                             #
#              Linux Software Installer and System Configurator               #
#          ---------------------------------------------------------          #
#          For Debian based systems, optimized for Ubuntu & Raspbian          #
#                                                                             #
#                       (C)opyright bei Michael Gasbers                       #
#                      MIGANO Professional Web Solutions                      #
#                                                                             #
#                             All rights reserved.                            #
#                                                                             #
###############################################################################
#                                                                             #
# DIESE SOFTWARE WIRD OHNE MÄNGELGEWÄHR UND OHNE JEGLICHE AUSDRÜCKLICHE ODER  #
# STILLSCHWEIGENDE GARANTIE ZUR VERFÜGUNG GESTELLT, EINSCHLIESSLICH UND OHNE  #
# EINSCHRÄNKUNG JEGLICHER GARANTIE FÜR DIE GEBRAUCHSTAUGLICHKEIT ODER EIGNUNG #
# FÜR EINEN BESTIMMTEN ZWECK. ALLE RISIKEN IN BEZUG AUF ERGEBNISSE UND        #
# LEISTUNG DIESER SOFTWARE WERDEN VOLLSTÄNDIG VOM BENUTZER ÜBERNOMMEN!        #
#  *************************************************************************  #
# THIS SOFTWARE IS PROVIDED "AS IS" WITH NO WARRANTIES WHAT SO EVER, WHETHER  #
# EXPRESSED OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF       #
# USABILITY OR FITNESS FOR A PARTICULAR PURPOSE. ALL RISKS CONCERNING RESULTS #
# AND PERFORMANCE OF THIS SOFTWARE ARE ASSUMED COMPLETELY BY THE USER!        #
#                                                                             #
###############################################################################
#                                                                             #
#  Jegliche Form der Kopie, Veränderung und kommerziellen Verbreitung dieses  #
#  Scripts oder Teilen davon sowie des Quellcodes ist strengstens verboten!   #
#  *************************************************************************  #
#   Any form of copying, modification or commercial distribution of this      #
#   script or any part thereof or it's sourcecode is strictly prohibited!     #
#  *************************************************************************  #
#   Für Anregungen und Fragen nehmen Sie bitte Kontakt mit uns auf über       #
#   https://migano.de oder per E-Mail an >> kontakt@migano.de <<. Danke.      #
#                                                                             #
###############################################################################
VERSION="3.93"
# Letzte Änderung: 02.11.2023
###############################################################################
HEADLINE_TITLE="Linux Software Installer and System Configurator"
###############################################################################
# URL zum Download dieses Scriptes
###############################################################################
THIS_SCRIPT_URL="https://migano.de/download/lissy/lissy"
THIS_SCRIPT_ICO="https://migano.de/download/lissy/lissy.png"
###############################################################################
# Schriftfarben und Textbausteine
# Bei Änderungen der Farbnamen auch die COL_VAR_LIST anpassen!
# ACHTUNG: Die Farben für das Menü werden in dialogrc festgelegt
###############################################################################
# Text normal
black='\033[0;30m'
red='\033[0;31m'
green='\033[0;32m'
yellow='\033[0;33m'
blue='\033[0;34m'
purple='\033[0;35m'
cyan='\033[0;36m'
white='\033[0;97m'
# Text hell
dark_grey='\033[0;90m'
light_red='\033[0;91m'
light_green='\033[0;92m'
light_yellow='\033[0;93m'
light_blue='\033[0;94m'
light_purple='\033[0;95m'
light_cyan='\033[0;96m'
light_grey='\033[0;37m'
# Text fett
bold_black='\033[1;30m'
bold_red='\033[1;31m'
bold_green='\033[1;32m'
bold_yellow='\033[1;33m'
bold_blue='\033[1;34m'
bold_purple='\033[1;35m'
bold_cyan='\033[1;36m'
bold_white='\033[1;37m'
# Text unterstrichen
uline_black='\033[4;30m'
uline_red='\033[4;31m'
uline_green='\033[4;32m'
uline_yellow='\033[4;33m'
uline_blue='\033[4;34m'
uline_purple='\033[4;35m'
uline_cyan='\033[4;36m'
uline_white='\033[4;37m'
# Hintergrund
bg_black='\033[40m'
bg_red='\033[41m'
bg_green='\033[42m'
bg_yellow='\033[43m'
bg_blue='\033[44m'
bg_purple='\033[45m'
bg_cyan='\033[46m'
bg_white='\033[47m'
# Keine Farben
colors_off='\033[0m'
colors_invers='\033[7m'
# Linienfarbe
line_color='\033[0;90m'
if [ -x "/usr/bin/tput" ] && tput setaf 1 &>/dev/null;
then
  # clear_this_line=$(tput el) # Aktuell nicht benötigt
  clear_last_line=$(tput cuu 1 && tput el)
fi
# --------------
# Textbausteine
# --------------
FULL_LINE="${line_color}$(printf '─%.0s' {1..80})${colors_off}"
HALF_LINE="${line_color}$(printf '─%.0s' {1..40})${colors_off}"
HALF_MINUS_LINE="${line_color}$(printf '\x2D%.0s' {1..40})${colors_off}"
PRE_SPACE=$(printf ' %.0s' {1..5})
FULLSPACE=$(printf '\x20%.0s' {1..80})
NA_TXT="nicht verfügbar"
NF_TXT="nicht gefunden"
NM_TXT="nur MATE-Desktop"
NR_TXT="nicht für root"
NU_TXT="nur mit Ubuntu"
NV_TXT="nicht vorhanden"
RASPY_TXT="nur Raspberry Pi"
PIOS_TXT="nur bei Pi OS"
KF_TAG="${bold_green}ok${colors_off} ${dark_grey}(keine fehlenden gefunden)${colors_off}"
NC_TAG="${bold_green}ok${colors_off} ${dark_grey}(keine Änderung)${colors_off}"
ND_TAG="${bold_green}ok${colors_off} ${dark_grey}(keine Dateien gefunden)${colors_off}"
NF_TAG="${bold_green}ok${colors_off} ${dark_grey}(keine gefunden)${colors_off}"
OA_TAG="${bold_green}ok${colors_off} ${dark_grey}(Autostart aktiv)${colors_off}"
OK_TAG="${bold_green}ok${colors_off}"
FERTIG_TAG="${bold_green}fertig${colors_off}"
HINWEIS_TAG="${bold_yellow}Hinweis${colors_off}"
WARN_TAG="${bold_yellow}Warnung${colors_off}"
ACHTUNG_TAG="${bold_red}Achtung${colors_off}"
ERROR_TAG="${bold_red}Fehler${colors_off}"
USER_CHOICE_YES="OK, Du hast es so gewollt ..."
USER_CHOICE_NO="Sicherheit geht vor!"

###############################################################################
# Ausreichende Zugriffsrechte prüfen
###############################################################################
if ! [ $(id -u) -eq 0 ];
then
  echo -e ""
  echo -e " $HEADLINE_TITLE v$VERSION"
  echo -e " Bitte als Superuser aufrufen: sudo ${0}"
  echo -e ""
  exit 1
fi

###############################################################################
# Eigenen Benutzernamen und Benutzer-ID ermitteln
###############################################################################
if [ $SUDO_USER ]; then USER_USERNAME="$SUDO_USER"; else USER_USERNAME=$(whoami); fi
USER_UID=$(id -u $USER_USERNAME)

###############################################################################
# Ordner zur Speicherung von Downloads, Konfigurationen u. Log-Dateien anlegen
# ACHTUNG: Angaben OHNE Slash(/) am Ende!
###############################################################################
# Ordner des Benutzers
SCRIPT_PATH="$(pwd)"
SCRIPT_NAME="${0##*/}"
if [ "$USER_USERNAME" = "root" ];
then
  USER_HOME_DIR="/root"
  DOWNLOAD_DIR="/tmp/$SCRIPT_NAME"
else
  USER_HOME_DIR="/home/$USER_USERNAME"
  DOWNLOAD_DIR="$USER_HOME_DIR/Downloads/$SCRIPT_NAME"
fi
USER_CONFIG_DIR="$USER_HOME_DIR/.config"
# Ordner für Konfigurationsdateien dieses Scripts
if [ ! -d "$USER_CONFIG_DIR" ]; then USER_CONFIG_DIR="$USER_HOME_DIR"; fi
SCRIPT_CONFIG_DIR="$USER_CONFIG_DIR/$SCRIPT_NAME"
if [ ! -d "$SCRIPT_CONFIG_DIR" ];
then
  mkdir -p "$SCRIPT_CONFIG_DIR" &>/dev/null
  if [ $? -eq 0 ];
  then
    chown -R "$USER_USERNAME:$USER_USERNAME" "$SCRIPT_CONFIG_DIR" &>/dev/null
    chmod 0755 "$SCRIPT_CONFIG_DIR" &>/dev/null
  fi
fi
USER_SCRIPT_CONFIG="$SCRIPT_CONFIG_DIR/$SCRIPT_NAME.conf"
USER_PAKET_LIST="$SCRIPT_CONFIG_DIR/$SCRIPT_NAME.list"
# Ordner für Downloads und temporäre Dateien
DOWNLOAD_DIR+="_files"
if [ ! -d "$DOWNLOAD_DIR" ];
then
  mkdir -p "$DOWNLOAD_DIR" &>/dev/null
  if [ $? -eq 0 ];
  then
    chown "$USER_USERNAME:$USER_USERNAME" "$DOWNLOAD_DIR" &>/dev/null
    chmod 0755 "$DOWNLOAD_DIR" &>/dev/null
  else
    echo -e ""
    echo -e " ${bold_white}$HEADLINE_TITLE v$VERSION${colors_off}"
    echo -e " $ERROR_TAG: ${bold_blue}$DOWNLOAD_DIR${colors_off} kann nicht angelegt werden!"
    echo -e ""
    exit 1
  fi
fi
# Log-Dateien
LOG_FILE="$DOWNLOAD_DIR/$(date +%Y-%m-%d-%H%M).log"
LOG_TEMP="$DOWNLOAD_DIR/$(date +%Y-%m-%d-%H%M).tmp"
# Datei zur Zwischenspeicherung des Exit-Codes des letzten Kommandos
LAST_EXIT_CODE="$DOWNLOAD_DIR/laexco"

###############################################################################
# Pfad erweitern zur Sicherstellung, dass alle Systemprogramme gefunden werden
###############################################################################
export PATH="$PATH:/usr/sbin:/usr/bin:/sbin:/bin"

###############################################################################
# Server-Verzeichnis, aus welchem zur Laufzeit dieses Scriptes weitere frei
# zugängliche (per URL direkt erreichbare) Ressourcen heruntergeladen werden.
# Im Gegensatz zu RESSOURCE_DOWNLOADER bleiben beim direkten Download auch die
# Zeitstempel der Original-Dateien erhalten. ACHTUNG: OHNE Slash (/) am Ende!
###############################################################################
RESSOURCE_SERVER_DIR="https://migano.de/download/lissy/res"
# RESSOURCE_SERVER_DIR="http://localhost/entwicklung/migano.de/download/lissy/res"

###############################################################################
# Server-Script zum Download von nicht frei zugänglichen bzw. in individuellen
# Benutzerverzeichnissen liegenden Ressourcen. Zur Authentifizierung müssen
# Benutzername und Passwort angegeben werden. Im Gegensatz zum Download über
# RESSOURCE_SERVER_DIR erhalten die lokal erstellten Dateien dabei das aktuelle
# Datum als Zeitstempel! ACHTUNG: Angaben OHNE Slash (/) am Ende!
###############################################################################
RESSOURCE_DOWNLOADER="https://migano.de/download.php?f=lissy/res"
# RESSOURCE_DOWNLOADER="http://localhost/entwicklung/migano.de/download.php?f=lissy/res"

###############################################################################
# Prüfen, ob nur die Hilfeseite angezeigt werden soll
###############################################################################
SHOW_HELP=0
for arg in $@;
do
  if [ $(echo -n "${arg}" | grep -i -c -E "\-*\-*help") -gt 0 ];
  then
    SHOW_HELP=1
  fi
done

###############################################################################
# Funktion zur Erstellung einer Backup-Datei
# - erstmalig vom Original (.save), wenn es die Backup-Datei noch nicht gibt
# - rollierend als neues Backup (.bak), wenn es die Backup-Datei schon gibt
# ACHTUNG: Leere Dateien werden nicht berücksichtigt und nicht kopiert!
###############################################################################
function create_backup_file () {
  FILE_TO_BACKUP="$1"
  if [ -s "$FILE_TO_BACKUP" ];
  then
    if [ ! -s "$FILE_TO_BACKUP.save" ]
    then
      cp -f "$FILE_TO_BACKUP" "$FILE_TO_BACKUP.save" &>/dev/null
    else
      cp -f "$FILE_TO_BACKUP" "$FILE_TO_BACKUP.bak" &>/dev/null
    fi
  fi
}

###############################################################################
# Funktion zum Download einer Bild-Datei (Pixmap)
###############################################################################
function download_icon_file ()
{
  PKG_PICTURE_NAME="$1.png"
  PKG_PICTURE_DIR="/usr/share/pixmaps"
  PKG_PICTURE_FILE="$PKG_PICTURE_DIR/$PKG_PICTURE_NAME"
  if [ -d "$PKG_PICTURE_DIR" ] &&
     [ ! -s "$PKG_PICTURE_FILE" ];
  then
    PKG_PICTURE_URL="$RESSOURCE_SERVER_DIR/png/$PKG_PICTURE_NAME"
    LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$PKG_PICTURE_NAME"
    wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$PKG_PICTURE_URL" &>/dev/null
    DOWNLOAD_RESULT=$?
    if [ $DOWNLOAD_RESULT -eq 0 ] &&
       [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
       [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
    then
      mv -f "$LOCAL_DOWNLOAD_FILE" "$PKG_PICTURE_FILE" &>/dev/null
      chown "root:root" "$PKG_PICTURE_FILE" &>/dev/null
      chmod 0644 "$PKG_PICTURE_FILE" &>/dev/null
    else
      remove_file "$LOCAL_DOWNLOAD_FILE"
    fi
  fi
}

###############################################################################
# Funktion zum Auslesen eines dconf-Wertes
###############################################################################
function gsettings_get() {
  if gsettings --version &>/dev/null;
  then
    GS_RETURN_VALUE=$(sudo -u ${USER_USERNAME} DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/${USER_UID}/bus" gsettings get ${1} ${2} 2>/dev/null)
    if [ $? -eq 0 ];
    then
      echo "$GS_RETURN_VALUE" | sed s/\'//g | sed s/\"//g
      return 0
    else
      GS_RETURN_VALUE=$(gsettings get ${1} ${2} 2>/dev/null)
      if [ $? -eq 0 ];
      then
        echo "$GS_RETURN_VALUE" | sed s/\'//g | sed s/\"//g
        return 0
      else
        echo ""
        return 1
      fi
    fi
  else
    echo ""
    return 1
  fi
}

###############################################################################
# Funktion zum Setzen eines dconf-Wertes
###############################################################################
function gsettings_set() {
  if gsettings --version &>/dev/null;
  then
    gsettings set ${1} ${2} ${3} &>/dev/null
    GS_RETURN_CODE=$?
    sudo -u ${USER_USERNAME} DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/${USER_UID}/bus" gsettings set ${1} ${2} ${3} &>/dev/null
    if [ $? -eq 0 ] ||
       [ $GS_RETURN_CODE -eq 0 ];
    then
      return 0
    else
      return 1
    fi
  else
    return 1
  fi
}


###############################################################################
# Systemarchitektur ermitteln
###############################################################################
if [ $SHOW_HELP -eq 0 ];
then
  echo -e ""
  echo -e -n " Initialisierung, bitte warten ... "
  SOURCES_LIST_FILE="/etc/apt/sources.list"
  SOURCES_LIST_DIR="/etc/apt/sources.list.d"
  ANZ_SOURCE_ENTRIES=0
  if [ -s "$SOURCES_LIST_FILE" ];
  then
    # =========================================================================
    # Ermittlung der Anzahl von Paket-Quellen in der Datei sources.list
    # =========================================================================
    ANZ_SOURCE_ENTRIES=$(cat "$SOURCES_LIST_FILE" 2>/dev/null | grep -i -E "^\s*deb\s" | grep -i -v "security" | wc -l)
    # =========================================================================
    # Deaktivieren von CD/DVD als Haupt-Paketquelle (alle zu installierenden
    # Pakete werden ausschließlich immer aktuell aus dem Internet geladen!)
    # =========================================================================
    if [ $(cat "$SOURCES_LIST_FILE" 2>/dev/null | grep -i -c -E "^\s*deb\s\s*cdrom") -gt 0 ];
    then
      echo -e ""
      echo -e -n " Deaktiviere CD/DVD als Paketquelle ... "
      create_backup_file "$SOURCES_LIST_FILE"
      sed -i -E "s/^\s*deb\s\s*cdrom/# deb cdrom/g" "$SOURCES_LIST_FILE"
      if [ $? -eq 0 ];
      then
        echo -e "$OK_TAG"
      else
        echo -e "$ERROR_TAG"
      fi
    fi
  fi
  # ===========================================================================
  # Ermittlung der Anzahl von Paket-Quellen in dem Ordner sources.list.d
  # ===========================================================================
  ANZ_SOURCE_FILES=0
  if [ -d "$SOURCES_LIST_DIR" ];
  then
    ANZ_SOURCE_FILES=$(ls -A "$SOURCES_LIST_DIR" 2>/dev/null | grep -i -v "readme" | wc -w)
  fi
  # ===========================================================================
  # Skript beenden, wenn keine sinnvollen Paketquellen gefunden wurden
  # ===========================================================================
  if [ $ANZ_SOURCE_ENTRIES -eq 0 ] &&
     [ $ANZ_SOURCE_FILES -eq 0 ];
  then
    echo -e ""
    echo -e ""
    echo -e " $ERROR_TAG: Es wurden keine aktiven Quellangaben zur Installation"
    echo -e " von Paketen gefunden. Bitte konfiguriere erst die gewünschten"
    echo -e " Quellen und starte $SCRIPT_NAME dann neu."
    exit 1
  fi
  # ---------
  # Hardware
  # ---------
  IFS=':' MACHINE_STRING=($(LANG=en dmesg 2>/dev/null | grep -i -E "machine\s*model"))
  ANZ_ARGS=${#MACHINE_STRING[@]}
  if [ $ANZ_ARGS -gt 0 ];
  then
    MACHINE_MODEL="${MACHINE_STRING[((ANZ_ARGS-=1))]}"
  else
    IFS=':' MACHINE_STRING=($(LANG=en dmesg 2>/dev/null | grep -i -E "DMI:"))
    MACHINE_MODEL="${MACHINE_STRING[1]}"
  fi
  IFS=' '
  MACHINE_MODEL=$(echo -n "${MACHINE_MODEL:0:32}" | xargs)
  # ----------
  # Prozessor
  # ----------
  # Bezeichnung
  CPU_MODEL=$(cat /proc/cpuinfo 2>/dev/null | grep -i -E "^model\s*name*\s*\:")
  if [ "$CPU_MODEL" = "" ];
  then
    CPU_MODEL=$(cat /proc/cpuinfo 2>/dev/null | grep -i -E "^model\s*\:")
  fi
  CPU_MODEL=$(echo -n "${CPU_MODEL##*\:}" | xargs)
  # Anzahl Kerne
  CPU_CORES=$(cat /proc/cpuinfo 2>/dev/null | grep -i -c -E "^processor\s*\:")
  # CPU-Code
  CPU_CODE=$(cat /proc/cpuinfo 2>/dev/null | grep -i -E "^hardware\s*\:")
  CPU_CODE=$(echo -n "${CPU_CODE##*\:}" | xargs)

  # Seriennummer
  CPU_SERIAL=$(cat /proc/cpuinfo 2>/dev/null | grep -i -E "^serial\s*\:")
  CPU_SERIAL=$(echo -n "${CPU_SERIAL##*\:}" | xargs)

  # -------------------------------------------------------------------------
  # GPU-Infos
  # -------------------------------------------------------------------------
  # Alternative A mit lspci - nicht standardisiert
  # LSPCI_INSTALLED=$(LANG=en dpkg-query -W -f='${Status}' "pciutils" 2>/dev/null | grep -i -c -E "ok installed")
  # if [ $LSPCI_INSTALLED -eq 0 ];
  # then
  #   e_and_l " Installiere ${light_yellow}pciutils${colors_off} ... "
  #   apt install "pciutils" -y &>"$LOG_TEMP"
  #   if [ $? -eq 0 ]; then LSPCI_INSTALLED=1; fi
  # fi
  # GPU_MODEL=""
  # if [ $LSPCI_INSTALLED -eq 1 ];
  # then
  #   GPU_MODEL=$(LANG=en lspci -v 2>/dev/null | grep ' VGA ' | cut -d" " -f 1 | xargs -i lspci -v -s {} | grep -E "Subsystem")
  #   # GPU_MODEL=${GPU_MODEL/Subsystem:/}
  #   GPU_MODEL=$(echo -n "${GPU_MODEL/Subsystem:/}" | xargs)
  # fi
  # -------------------------------------------------------------------------
  # Alternative B mit lshw
  if lshw &>/dev/null;
  then
    GPU_MODEL=$(LANG=en lshw -short 2>/dev/null | grep display | head -n 1)
    GPU_MODEL=$(echo -n "${GPU_MODEL##*display}")
    GPU_MODEL=$(echo -n "${GPU_MODEL:0:32}" | xargs)
  fi

  # -----------------------------------------------------------------------------
  # Memory-Angaben und Infos
  # -----------------------------------------------------------------------------
  # Reservierter Platz im Hauptspeicher für Linux selbst und weitere Programme
  # (nur zur Berechnug von verfügbarem Platz für RAM Disk und temporäre Ordner)
  MIN_LINUX_RAM=$((3 * 1024 * 1024 * 1024)) # Vorgabe 3 GB
  # -----------------------------------------------------------------------------
  # Mindestgröße des Speicherplatzes (MB), der rein rechnerisch nach Abzug des
  # zuvor reservierten Platzes für Linux und Programme verbleiben muss, um die
  # Erstellung einer RAM Disk durchführen zu können
  RAMDISK_MIN_SIZE=100 # Vorgabe 100 MB
  # -----------------------------------------------------------------------------
  # Mindestgröße (MB), den die RAM Disk (/media/ramdisk) mindestens haben muss,
  # um die Verlagerung des Browser-Cache auf die RAM Disk durchführen zu können
  # ACHTUNG: Bei Änderung mit Script "browser-cache-to-ram" abgleichen!
  BROWSER_CACHE_MIN_SIZE=400 # Vorgabe 400 MB
  # -----------------------------------------------------------------------------
  if [ -f "/proc/meminfo" ];
  then
    MEMORY_TOTAL=$(cat /proc/meminfo 2>/dev/null | grep -i -E "memtotal")
    MEMORY_TOTAL=${MEMORY_TOTAL##*\:}
    if [ $(echo $MEMORY_TOTAL | grep -i -c -E "G") -gt 0 ];
    then
      MEMORY_TOTAL=$(echo -n "$MEMORY_TOTAL" | sed 's/\s*GB//i' | sed 's/\s*G//i' | xargs)
      MEMORY_TOTAL=$((MEMORY_TOTAL * 1024 * 1024 * 1024))
    else
      if [ $(echo $MEMORY_TOTAL | grep -i -c -E "M") -gt 0 ];
      then
        MEMORY_TOTAL=$(echo -n "$MEMORY_TOTAL" | sed 's/\s*MB//i' | sed 's/\s*M//i' | xargs)
        MEMORY_TOTAL=$((MEMORY_TOTAL * 1024 * 1024))
      else
        if [ $(echo $MEMORY_TOTAL | grep -i -c -E "K") -gt 0 ];
        then
          MEMORY_TOTAL=$(echo -n "$MEMORY_TOTAL" | sed 's/\s*KB//i' | sed 's/\s*K//i' | xargs)
          MEMORY_TOTAL=$((MEMORY_TOTAL * 1024))
        fi
      fi
    fi
    MEMORY_AVAIL=$(cat /proc/meminfo 2>/dev/null | grep -i -E "memavail")
    MEMORY_AVAIL=${MEMORY_AVAIL##*\:}
    if [ $(echo $MEMORY_AVAIL | grep -i -c -E "G") -gt 0 ];
    then
      MEMORY_AVAIL=$(echo -n "$MEMORY_AVAIL" | sed 's/\s*GB//i' | sed 's/\s*G//i' | xargs)
      MEMORY_AVAIL=$((MEMORY_AVAIL * 1024 * 1024 * 1024))
    else
      if [ $(echo $MEMORY_AVAIL | grep -i -c -E "M") -gt 0 ];
      then
        MEMORY_AVAIL=$(echo -n "$MEMORY_AVAIL" | sed 's/\s*MB//i' | sed 's/\s*M//i' | xargs)
        MEMORY_AVAIL=$((MEMORY_AVAIL * 1024 * 1024))
      else
        if [ $(echo $MEMORY_AVAIL | grep -i -c -E "K") -gt 0 ];
        then
          MEMORY_AVAIL=$(echo -n "$MEMORY_AVAIL" | sed 's/\s*KB//i' | sed 's/\s*K//i' | xargs)
          MEMORY_AVAIL=$((MEMORY_AVAIL * 1024))
        fi
      fi
    fi
  else
    MEMORY_TOTAL=0
    MEMORY_AVAIL=0
  fi

  # ---------------
  # Betriebssystem
  # ---------------
  RASPBERRY=$(LANG=en dmesg 2>/dev/null | grep -i -v -E "hostname" | grep -i -c -E "raspberry")
  if [ $RASPBERRY -eq 0 ] &&
     [ -f "/proc/cpuinfo" ];
  then
    RASPBERRY=$(cat "/proc/cpuinfo" | grep -i -c -E "raspberry")
  fi
  RASPBIAN=0
  OS_V_CODENAME=""
  OS_U_CODENAME=""
  if [ -s '/etc/os-release' ];
  then
    OS_NAME=$(cat "/etc/os-release" | grep -i -E "^NAME\s*=")
    # OS_NAME=$(echo -n "${OS_NAME//\(/}")
    # OS_NAME=$(echo -n "${OS_NAME//\)/}")
    OS_NAME=$(echo -n "${OS_NAME##*\=}" | xargs)

    OS_VERSION=$(cat "/etc/os-release" | grep -i -E "^VERSION\s*=")
    # OS_VERSION=$(echo -n "${OS_VERSION//\(/}")
    # OS_VERSION=$(echo -n "${OS_VERSION//\)/}")
    OS_VERSION=$(echo -n "${OS_VERSION##*\=}" | xargs)

    OS_V_CODENAME=$(cat "/etc/os-release" | grep  -i -E "^VERSION_CODENAME\s*=" | cut -d'"' -f 2 | cut -d'"' -f 1)
    # OS_V_CODENAME=$(echo -n "${OS_V_CODENAME//\(/}")
    # OS_V_CODENAME=$(echo -n "${OS_V_CODENAME//\)/}")
    OS_V_CODENAME=$(echo -n "${OS_V_CODENAME##*\=}" | xargs)

    OS_U_CODENAME=$(cat "/etc/os-release" | grep  -i -E "^UBUNTU_CODENAME\s*=" | cut -d'"' -f 2 | cut -d'"' -f 1)
    # OS_U_CODENAME=$(echo -n "${OS_U_CODENAME//\(/}")
    # OS_U_CODENAME=$(echo -n "${OS_U_CODENAME//\)/}")
    OS_U_CODENAME=$(echo -n "${OS_U_CODENAME##*\=}" | xargs)

    OS_PRETTY_NAME=$(cat "/etc/os-release" | grep -i -E "^PRETTY_NAME\s*=")
    # OS_PRETTY_NAME=$(echo -n "${OS_PRETTY_NAME//\(/}")
    # OS_PRETTY_NAME=$(echo -n "${OS_PRETTY_NAME//\)/}")
    OS_PRETTY_NAME=$(echo -n "${OS_PRETTY_NAME##*\=}" | xargs)

    OPERATION_SYSTEM="$OS_NAME $OS_VERSION"

    # Check if Raspbian
    RASPBIAN=$(cat "/etc/os-release" | grep -i -c -E "raspbian")
    if [ $RASPBIAN -eq 0 ];
    then
      RASPBIAN=$(cat "/etc/os-release" | grep -i -c -E "Raspberry Pi OS")
    fi
    if [ $RASPBIAN -eq 0 ];
    then
      RASPBIAN=$(ps -def | grep -i -c -E "lxde-pi")
      if [ $RASPBIAN -eq 1 ]; then RASPBIAN=0; fi
    fi
  fi

  DEBIAN_CODE=""
  if [ -s "/etc/debian_version" ];
  then
    DEBIAN_CODE="$(cat /etc/debian_version)"
    DEBIAN_CODE="${DEBIAN_CODE%%/*}"
    TEST_CODE=$(echo "$DEBIAN_CODE" | sed 's/[^a-z]*//g' | xargs)
    if [ "$TEST_CODE" = "" ];
    then
      DEBIAN_CODE="$OS_V_CODENAME"
    fi
    # Von LMDE eigene Namen anpassen an die zugrunde liegende Debian-Version
    if [ $(echo "$DEBIAN_CODE" | grep -i -c -E "faye") -gt 0 ]; then DEBIAN_CODE="bookworm"; fi
    # ----
  fi

  UBUNTU_VERSION=""
  DEBIAN_VERSION=""
  if [ "$OS_U_CODENAME" != "" ];
  then
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "bionic") -gt 0 ];   then UBUNTU_VERSION="18.04"; DEBIAN_VERSION="10"; fi
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "cosmic") -gt 0 ];   then UBUNTU_VERSION="18.10"; DEBIAN_VERSION="10"; fi
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "disco") -gt 0 ];    then UBUNTU_VERSION="19.04"; DEBIAN_VERSION="10"; fi
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "eoan") -gt 0 ];     then UBUNTU_VERSION="19.10"; DEBIAN_VERSION="10"; fi
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "focal") -gt 0 ];    then UBUNTU_VERSION="20.04"; DEBIAN_VERSION="11"; fi
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "groovy") -gt 0 ];   then UBUNTU_VERSION="20.10"; DEBIAN_VERSION="11"; fi
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "hirsute") -gt 0 ];  then UBUNTU_VERSION="21.04"; DEBIAN_VERSION="11"; fi
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "impish") -gt 0 ];   then UBUNTU_VERSION="21.10"; DEBIAN_VERSION="11"; fi
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "jammy") -gt 0 ];    then UBUNTU_VERSION="22.04"; DEBIAN_VERSION="12"; fi
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "kinetic") -gt 0 ];  then UBUNTU_VERSION="22.10"; DEBIAN_VERSION="12"; fi
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "lunar") -gt 0 ];    then UBUNTU_VERSION="23.04"; fi
    if [ $(echo "$OS_U_CODENAME" | grep -i -c -E "mantic") -gt 0 ];   then UBUNTU_VERSION="23.10"; fi
  fi
  if [ $(uname -a 2>/dev/null | grep -i -c -E "debian") -gt 0 ] &&
     [ "$DEBIAN_VERSION" = "" ];
  then
    # Von LMDE eigene Namen anpassen an die zugrunde liegende Debian-Version
    if [ $(echo "$OS_V_CODENAME" | grep -i -c -E "faye") -gt 0 ]; then OS_V_CODENAME="bookworm"; fi
    # ----
    if [ $(echo "$OS_V_CODENAME" | grep -i -c -E "stretch") -gt 0 ];  then DEBIAN_VERSION="9";  fi
    if [ $(echo "$OS_V_CODENAME" | grep -i -c -E "buster") -gt 0 ];   then DEBIAN_VERSION="10"; fi
    if [ $(echo "$OS_V_CODENAME" | grep -i -c -E "bullseye") -gt 0 ]; then DEBIAN_VERSION="11"; fi
    if [ $(echo "$OS_V_CODENAME" | grep -i -c -E "bookworm") -gt 0 ]; then DEBIAN_VERSION="12"; fi
    if [ $(echo "$OS_V_CODENAME" | grep -i -c -E "trixie") -gt 0 ];   then DEBIAN_VERSION="13"; fi
    if [ $(echo "$OS_V_CODENAME" | grep -i -c -E "forky") -gt 0 ];    then DEBIAN_VERSION="14"; fi
  fi
  OS_BIT_WIDTH=$(getconf LONG_BIT) 2>/dev/null
  if [ $(uname -a 2>/dev/null | grep -i -c -E "debian") -eq 0 ] &&
     [ $(uname -a 2>/dev/null | grep -i -c -E "ubuntu") -eq 0 ] &&
     [ $RASPBIAN -eq 0 ];
  then
    IS_DEBIAN=0
  else
    IS_DEBIAN=1
  fi

  # ------------------------
  # Systemsprache ermitteln
  # ------------------------
  CUR_SYS_LANG=$(echo -n "${LANGUAGE:0:2}" | xargs)
  if [ "$CUR_SYS_LANG" = "" ];
  then
    CUR_SYS_LANG=$(echo -n "${LANG:0:2}" | xargs)
  fi
  CUR_LANG_NAME=$(locale -k LC_IDENTIFICATION 2>/dev/null | grep -i -E "language")
  CUR_LANG_NAME="${CUR_LANG_NAME##*=}"
  CUR_LANG_NAME=$(echo -n "${CUR_LANG_NAME//\"/}" | xargs)

  # ---------------------
  # Software-Architektur
  # ---------------------
  ARCHITECTURE_MAIN=$(dpkg --print-architecture)
  ARCHITECTURE_OTHER=$(dpkg --print-foreign-architectures)
  ARCHITECTURE_ALL="all|""$ARCHITECTURE_MAIN""|""$ARCHITECTURE_OTHER"
  SNAP_INSTALLED=$(LANG=en dpkg-query -W -f='${Status}' "snapd" 2>/dev/null | grep -i -c -E "ok installed")
  SNAPSHOT_SNAPS_LIST="$DOWNLOAD_DIR/snapshot_list.tmp"

  # ----------------
  # Display-Manager
  # ----------------
  DISPLAY_MANAGER="$(cat /etc/X11/default-display-manager 2>/dev/null)"
  DISPLAY_MANAGER="$(echo -n "${DISPLAY_MANAGER##*/}" | tr '[:upper:]' '[:lower:]')"

  # --------------------
  # Desktop-Environment
  # --------------------
  DESKTOP_ENVIRONMENT=""
  MAX_ENTRIES=0
  DESKTOP_NAMES=('Budgie' 'Cinnamon' 'DDE' 'Enlightment' 'Lumina' 'GNOME' 'KDE' 'Kylin' 'LXDE' 'LXQT' 'MATE' 'Pantheon' 'Plasma' 'TDE' 'Unity' 'XFCE')
  for desktop_name in ${DESKTOP_NAMES[@]};
  do
    DESKTOP_ENTRIES=$(ps -def | grep -i -c -E "\s+$desktop_name")
    if [ ${DESKTOP_ENTRIES} -gt ${MAX_ENTRIES} ];
    then
      MAX_ENTRIES=${DESKTOP_ENTRIES}
      DESKTOP_ENVIRONMENT=$desktop_name
    fi
  done
  DESKTOP_ENVIRONMENT="$(echo -n "$DESKTOP_ENVIRONMENT" | xargs)"
  GNOME_VERSION=""
  GNOME_PLATFORM=0
  if [ "$DESKTOP_ENVIRONMENT" = "GNOME" ] &&
    [ -s "/usr/share/gnome/gnome-version.xml" ];
  then
    GNOME_PLATFORM=$(cat /usr/share/gnome/gnome-version.xml | grep -i -E "platform" | cut -d">" -f 2 | cut -d"<" -f 1 )
    GNOME_MINOR=$(cat /usr/share/gnome/gnome-version.xml | grep -i -E "minor" | cut -d">" -f 2 | cut -d"<" -f 1 )
    GNOME_MICRO=$(cat /usr/share/gnome/gnome-version.xml | grep -i -E "micro" | cut -d">" -f 2 | cut -d"<" -f 1 )
    GNOME_VERSION="$GNOME_PLATFORM.$GNOME_MINOR.$GNOME_MICRO"
    GNOME_PLATFORM=printf -v int '%d\n' "$GNOME_PLATFORM" 2>/dev/null
  fi

  # ---------------
  # Window-Manager
  # ---------------
  WINDOW_MANAGER=""
  if xprop -version &>/dev/null;
  then
    X_WINDOW_ID=$(echo -n "$(xprop -root -notype)" | awk '$1=="_NET_SUPPORTING_WM_CHECK:"{print $5}')
    X_WINDOW_ATTRIBS=$(xprop -id "${X_WINDOW_ID}" -notype -f _NET_WM_NAME 8t)
    WINDOW_MANAGER=$(echo -n "${X_WINDOW_ATTRIBS}" | grep "_NET_WM_NAME = ")
    WINDOW_MANAGER="${WINDOW_MANAGER##*=}"
    WINDOW_MANAGER=$(echo -n "${WINDOW_MANAGER//\"/}" | xargs)
  fi

  # -------------
  # Window-Thema
  # -------------
  WINDOW_THEME="$(gsettings_get org.mate.interface gtk-theme)"
  if [ "$WINDOW_THEME" = "" ];
  then
    WINDOW_THEME="$(gsettings_get org.gnome.desktop.interface gtk-theme)"
  fi
  if [ "$WINDOW_THEME" = "" ];
  then
    if [ -s "$USER_HOME_DIR/.gtkrc-2.0" ];
    then
      WINDOW_THEME=$(grep -i -E "gtk-theme-name" "$USER_HOME_DIR/.gtkrc-2.0")
    fi
    if [ "$WINDOW_THEME" = "" ];
    then
      if [ -s "$USER_CONFIG_DIR/gtk-3.0/settings.ini" ];
      then
        WINDOW_THEME=$(grep -i -E "gtk-theme-name" "$USER_CONFIG_DIR/gtk-3.0/settings.ini")
      fi
    fi
  fi
  WINDOW_THEME=${WINDOW_THEME##*=}
  WINDOW_THEME=${WINDOW_THEME//\"/}
  WINDOW_THEME=${WINDOW_THEME//\'/}

  # -------------
  # Symbol-Thema
  # -------------
  SYMBOL_THEME="$(gsettings_get org.mate.interface icon-theme)"
  if [ "$SYMBOL_THEME" = "" ];
  then
    SYMBOL_THEME="$(gsettings_get org.gnome.desktop.interface icon-theme)"
  fi
  if [ -s "$USER_HOME_DIR/.gtkrc-2.0" ];
  then
    SYMBOL_THEME=$(grep -i -E "gtk-icon-theme-name" "$USER_HOME_DIR/.gtkrc-2.0")
  fi
  if [ "$SYMBOL_THEME" = "" ];
  then
    if [ -s "$USER_CONFIG_DIR/gtk-3.0/settings.ini" ];
    then
      SYMBOL_THEME=$(grep -i -E "gtk-icon-theme-name" "$USER_CONFIG_DIR/gtk-3.0/settings.ini")
    fi
  fi
  SYMBOL_THEME=${SYMBOL_THEME##*=}
  SYMBOL_THEME=${SYMBOL_THEME//\"/}
  SYMBOL_THEME=${SYMBOL_THEME//\'/}

  # ------
  # Shell
  # ------
  SHELL_TEXT="$("${SHELL##*/}" --version)"
  SHELL_TEXT=$(echo -n "${SHELL_TEXT%%(*}")
  SHELL_TEXT=$(echo -n "${SHELL_TEXT:0:64}" | xargs)

fi

###############################################################################
# Listen zur Auswahl der Kategorien definieren
# HINWEIS: Bei Änderungen auch alle Verbindungen mit CURRENT_CATEGORY und
#          Prüfungen auf KATEGORIE_FLAG anpassen!
###############################################################################
declare -A KATEGORIE_FLAG # Kategorie ausgewählt (1) oder nicht (0)
declare -A KATEGORIE_TEXT # Angezeigte Bezeichnung der Kategorie
declare -A KATEGORIE_PKGS # Liste mit den in der Kategorie enthaltenen Paketen

# Alphabetische Reihenfolge
KAT_KEY_LIST=(a b c f g i m n p q s t u v w wg x z mt gx lx mx xx)
# Reihenfolge der Verarbeitung
KAT_ORD_LIST=(x v b i n wg c m g t z u p a f q w s mt gx lx mx xx)

# --- CATEGORIES START ---
KATEGORIE_TEXT[a]="Webserver (Apache und PHP)"
KATEGORIE_TEXT[b]="Büro (Office-Anwendungen, E-book- und PDF-Tools)"
KATEGORIE_TEXT[c]="Cloud-Clients (Clients für Online-Datenspeicher)"
KATEGORIE_TEXT[f]="FTP-Server (ProFTPD)"
KATEGORIE_TEXT[g]="Grafik (Bild- und Foto-Bearbeitung)"
KATEGORIE_TEXT[i]="Internet (Browser, Mail, Chat, File-Transfer und Tools)"
KATEGORIE_TEXT[m]="Multimedia (Media-Player, Konverter und Brenn-Software)"
KATEGORIE_TEXT[n]="Private Netzwerkverbindungen (OpenVPN, VPNC)"
KATEGORIE_TEXT[p]="Programmierung (Editoren und Programmier-Werkzeuge)"
KATEGORIE_TEXT[q]="Emulation u. Virtualisierung (Docker, KVM, QEMU und VBox)"
KATEGORIE_TEXT[s]="Spiele (Michael's Auswahl)"
KATEGORIE_TEXT[t]="Tonstudio (Audio-Bearbeitung und Musikproduktion)"
KATEGORIE_TEXT[u]="USB-Firewall (Selektives Zulassen von USB-Geräten)"
KATEGORIE_TEXT[v]="Systemverwaltung (Hilfsprogramme mit Benutzeroberfläche)"
KATEGORIE_TEXT[w]="Windows API (Wine, Winetricks und PlayOnLinux)"
KATEGORIE_TEXT[wg]="WireGuard VPN (Kernel Version)"
KATEGORIE_TEXT[x]="Systemerweiterungen (Treiber und CLI-Hilfsprogramme)"
KATEGORIE_TEXT[z]="Zubehör (Datei-Manager, Packer und diverse Desktop-Tools)"
KATEGORIE_TEXT[mt]="Mint Tools (Erweiterungen für Linux Mint)"
KATEGORIE_TEXT[gx]="GNOME Tools (Erweiterungen für das GNOME-Desktop)"
KATEGORIE_TEXT[lx]="LXDE Tools (Erweiterungen für das LXDE-Desktop)"
KATEGORIE_TEXT[mx]="MATE Tools (Erweiterungen für das MATE-Desktop)"
KATEGORIE_TEXT[xx]="XFCE Tools (Erweiterungen für das XFCE-Desktop)"
# --- CATEGORIES END ---

###############################################################################
# Status des Kernel-Lockings ermitteln
###############################################################################
KERNEL_PACKS=('linux-generic' 'linux-headers-generic' 'linux-image-generic' 'linux-signed-generic' 'linux-signed-image-generic')
KERNEL_IS_LOCKED=0
for kp in ${KERNEL_PACKS[@]};
do
  if [ $(apt-mark showhold 2>/dev/null | grep -c -i -E "$kp") -gt 0 ];
  then
    ((KERNEL_IS_LOCKED+=1))
  fi
done

###############################################################################
# Listen zur Auswahl der Optionen definieren
###############################################################################
declare -A OPTION_FLAG # Option ausgewählt (1) oder nicht (0)
declare -A OPTION_TEXT # Angezeigte Bezeichnung der Option
declare -A OPTION_MENU # Index des Menüpunktes, in dem die Option erscheint

OPTION_LIST=()
OPTION_LIST+=(nosnap norepo foreign force quiet status listonly addicons) # Menu 2
OPTION_LIST+=(extras exupdate udrivers kuplock kunlock optimize notrim cleansys nopkgsrv personal dsave dload) # Menu 4
OPTION_LIST+=(infoonly noinfo log logfull noupdate nocolor saveconf cleantmp) # Menu 5

OPTION_TEXT[addicons]="Desktop-Symbole (Icons) für Paketauswahl erstellen"
OPTION_TEXT[cleansys]="Reparaturen und diverse Bereinigungen durchführen"
OPTION_TEXT[cleantmp]="Alle temporären Dateien bei Programmende löschen"
OPTION_TEXT[dload]="Gespeicherte Desktop-Einstellungen laden (dconf)"
OPTION_TEXT[dsave]="Aktuelle Desktop-Einstellungen speichern (dconf)"
OPTION_TEXT[extras]="Extras (Schriftarten, Mauszeiger etc.) installieren"
OPTION_TEXT[exupdate]="Programmpakete aus externen Quellen aktualisieren"
OPTION_TEXT[force]="Ja/Nein-Abfrage vor jeder Installation überspringen"
OPTION_TEXT[foreign]="Auch Pakete für Fremd-Architekturen installieren"
OPTION_TEXT[infoonly]="Nur Systeminformationen anzeigen (sonst nichts tun)"
OPTION_TEXT[instonly]="Ein einzelnes Programmpaket installieren"
OPTION_TEXT[kuplock]="Aktualisierungen (Updates) des Kernels blockieren"
OPTION_TEXT[kunlock]="Aktualisierungen (Updates) des Kernels freigeben"
OPTION_TEXT[listonly]="Nur Pakete je Kategorie auflisten (sonst nichts tun)"
OPTION_TEXT[log]="Einfache Log-Datei der wichtigsten Aktionen erstellen"
OPTION_TEXT[logfull]="Vollständige Log-Datei aller Aktionen erstellen"
OPTION_TEXT[nocolor]="Ausgabe der Anzeigen und Meldungen ohne Farben"
OPTION_TEXT[noinfo]="Systeminformationen am Anfang nicht anzeigen"
OPTION_TEXT[nopkgsrv]="Bei Reparaturen Prüfung der Paketserver auslassen"
OPTION_TEXT[norepo]="Repository nicht erweitern oder aktualisieren"
OPTION_TEXT[nosnap]="Keine Snap-Pakete auswählen oder installieren"
OPTION_TEXT[notrim]="Bei Optimierungen kein SSD-Trimming durchführen"
OPTION_TEXT[noupdate]="Nicht nach Updates für dieses Skript suchen"
OPTION_TEXT[optimize]="Diverse Optimierungen des Systems durchführen"
OPTION_TEXT[personal]="Persönliche Einstellungen vom Server laden"
OPTION_TEXT[quiet]="DERZEIT NICHT VERWENDET!"
OPTION_TEXT[remove]="Ein Programmpaket und zugehörige Daten löschen"
OPTION_TEXT[saveconf]="Einstellungen für nächsten Aufruf speichern"
OPTION_TEXT[status]="Nur Status der Pakete anzeigen (nicht installieren)"
OPTION_TEXT[udrivers]="Aktualisierte Treiber für Ubuntu suchen"

OPTION_MENU[quiet]=0 # Wird im Menü nicht angezeigt

OPTION_MENU[instonly]=1 # Wird nicht tatsächlich verwendet, Prüfung erfolgt auf INST_ONLY_PKG

if [ "$DESKTOP_ENVIRONMENT" = "GNOME" ];
then
  OPTION_MENU[addicons]=0
else
  OPTION_MENU[addicons]=2
fi
OPTION_MENU[force]=2
OPTION_MENU[foreign]=2
OPTION_MENU[listonly]=2
OPTION_MENU[norepo]=2
OPTION_MENU[nosnap]=2
OPTION_MENU[status]=2

OPTION_MENU[remove]=3 # Wird nicht tatsächlich verwendet, Prüfung erfolgt auf REMOVE_PKG_NAME

OPTION_MENU[cleansys]=4
OPTION_MENU[dload]=4
OPTION_MENU[dsave]=4
OPTION_MENU[extras]=4
OPTION_MENU[exupdate]=4
if [ $KERNEL_IS_LOCKED -eq 0 ];
then
  OPTION_MENU[kuplock]=4
  OPTION_MENU[kunlock]=0
else
  OPTION_MENU[kuplock]=0
  OPTION_MENU[kunlock]=4
fi
OPTION_MENU[nopkgsrv]=4
OPTION_MENU[notrim]=4
OPTION_MENU[optimize]=4
OPTION_MENU[personal]=4
OPTION_MENU[udrivers]=4

OPTION_MENU[infoonly]=5
OPTION_MENU[cleantmp]=5
OPTION_MENU[log]=5
OPTION_MENU[logfull]=5
OPTION_MENU[nocolor]=5
OPTION_MENU[noinfo]=5
OPTION_MENU[noupdate]=5
OPTION_MENU[saveconf]=5

###############################################################################
# Paket-Listen definieren (Kategorisierte Listen von Programmpaketen)
# -----------------------------------------------------------------------------
# HINWEIS: Wenn vor oder nach einem Paket automatisch auch weitere Pakete
# installiert werden sollen, können diese in AUTO_ADD_PKGS angegeben werden!
# -----------------------------------------------------------------------------
# Sollen aus irgendeinem Grund Snap- oder externe Pakete bevorzugt werden, dann
# können diese in FORCE_SNAPPY_LIST und FORCE_EXTERN_LIST eingetragen werden.
# -----------------------------------------------------------------------------
###############################################################################
# Apache und PHP (Webserver)- mit vielen PHP-Modulen in aktueller Version ;)
PHP_VERSION=$(LANG=en apt show "php" 2>/dev/null | grep -i -E "depends\:\s*")
PHP_VERSION=$(echo -n "${PHP_VERSION##* }" | xargs)
KATEGORIE_PKGS[a]="apache2 php libapache2-mod-php"
PHP_MODULES=(bcmath cli curl dev gd imap intl mbstring mysql opcache readline soap sqlite3 xml xmlrpc zip)
if [ "$PHP_VERSION" != "" ];
then
  for php_mod_name in ${PHP_MODULES[@]};
  do
    KATEGORIE_PKGS[a]+=" $PHP_VERSION-$php_mod_name"
  done
fi
# Büro
KATEGORIE_PKGS[b]="calibre evolution libreoffice okular pdfarranger pdfchain qpdfview scribus"
if [ $(echo "$OPERATION_SYSTEM" | grep -i -c -E " mint ") -gt 0 ]; then KATEGORIE_PKGS[b]+=" thingy xreader"; fi
# Cloud-Clients"Online-Datenspeicher"
KATEGORIE_PKGS[c]="owncloud-client nextcloud-desktop"
# Programmierung
KATEGORIE_PKGS[p]="bless closure-compiler codium geany ghex kate kdiff3 kompare meld mu-editor python3 scratch thonny"
# Emulation und Virtualisierung
KATEGORIE_PKGS[q]="docker.io qemu-system-common qemu-system-data qemu-system-x86 qemu-system-arm qemu-system-gui qemu-efi-aarch64 qemu-efi-arm qemu-utils qemu-block-extra libvirt-daemon-system libvirt-clients bridge-utils virt-manager"
if [ $(uname -a 2>/dev/null | grep -i -c -E "debian") -gt 0 ] &&
   [ $(echo "$OS_V_CODENAME" | grep -i -c -E "bookworm") -gt 0 ];
then # Externes Paket => Extension-Pack wird per POST_INST_CONF nachinstalliert
  KATEGORIE_PKGS[q]+=" virtualbox-7.0"
else # Repo => Extensions siehe AUTO_ADD_PKGS
  KATEGORIE_PKGS[q]+=" virtualbox"
fi
# FTP-Server
KATEGORIE_PKGS[f]="proftpd-basic"
# Grafik
KATEGORIE_PKGS[g]="blender darktable digikam drawing eom fraqtive geeqie gimp gpicview gpick gwenview imagemagick inkscape krita mandelbulber2 mtpaint pinta rawtherapee shotwell simple-scan xnview"
if [ $(echo "$OPERATION_SYSTEM" | grep -i -c -E " mint ") -gt 0 ]; then KATEGORIE_PKGS[g]+=" pix xviewer"; fi
# Internet
KATEGORIE_PKGS[i]="anydesk ipscan chromium filezilla firefox opera-stable microsoft-edge-stable nomachine realvnc-vnc-server realvnc-vnc-viewer remmina teamviewer telegram-desktop thunderbird tor-browser transmission-common virt-viewer wireshark"
if [ $(echo "$OPERATION_SYSTEM" | grep -i -c -E " mint ") -gt 0 ]; then KATEGORIE_PKGS[i]+=" hexchat warpinator"; fi
# Multimedia
KATEGORIE_PKGS[m]="asunder celluloid cheese easytag freetuxtv handbrake hypnotix iptvnator k3b kdenlive kid3 kodi lame makemkv-bin mediainfo mixxx mkvtoolnix mpv parole openshot-qt rhythmbox smplayer vlc yt-dlp youtube-dl youtubedl-gui youplay"
# Netzwerkverbindungen
KATEGORIE_PKGS[n]="openvpn network-manager-openvpn network-manager-openvpn-gnome vpnc vpnc-scripts network-manager-vpnc network-manager-vpnc-gnome"
# Spiele
KATEGORIE_PKGS[s]="0ad alien-arena astromenace atomix billard-gl biniax2 blobwars blockout2 briquolo brutalchess caveexpress chromium-bsu code-the-classics criticalmass cuyo dreamchess enigma extremetuxracer foobillardplus freedoom frogatto frozen-bubble fs-uae gbrainy gcompris-qt gemdropx gnome-games gnubg gweled hedgewars jag kapman katomic kdiamond kmahjongg knights kpat kreversi ksudoku lbreakout2 lix marsshooter morris naev neverball neverputt nexuiz numptyphysics oolite open-invaders pinball pingus pokerth pybik rocksndiamonds sauerbraten sdl-ball supertux supertuxkart teeworlds torcs trigger-rally tuxmath ufoai wesnoth widelands zaz"
# Systemerweiterungen
KATEGORIE_PKGS[x]="apt-file apturl arj ccd2iso cifs-utils clonezilla cpu-checker curl dconf-cli diffutils dirmngr dpkg-repack e2fsprogs ethtool exfat-fuse exfatprogs extundelete fail2ban fdisk ffmpegthumbnailer firejail ftp gdisk git gpart gvfs-backends hdparm heif-gdk-pixbuf heif-thumbnailer htop iat img2pdf jfsutils lhasa libaacs0 libbluray2 libbluray-bdj libbluray-bin libdvd-pkg libfuse2 lsof lrzip lshw lzip lzop menu msr-tools mtools nano ncompress neofetch net-tools nmap numlockx openssh-server p7zip-full partclone partimage pciutils pdfcrack pdfresurrect ppa-purge qpdf resolvconf rsync samba sed screen smartmontools smbclient sqlite3 sshguard sysbench sysfsutils sysstat tar tcptrack testdisk traceroute udftools ufw unzip usbutils util-linux wget whois zstd zulumount-cli"
# Systemverwaltung
KATEGORIE_PKGS[v]="backintime-common baobab bleachbit blueman caja copyq czkawka dconf-editor deja-dup filelight font-manager gdebi gnome-disk-utility gnome-software gparted grsync grub-customizer gsmartcontrol gtkhash gufw hardinfo kwalletmanager mozo nemo plasma-discover seahorse synaptic system-config-printer timeshift tilda usbview xfce4-taskmanager zulumount-gui"
if [ $(echo "$OPERATION_SYSTEM" | grep -i -c -E " mint ") -gt 0 ]; then KATEGORIE_PKGS[v]+=" bulky qt5ct webapp-manager"; fi
# Tonstudio
KATEGORIE_PKGS[t]="ardour audacity hydrogen lmms qjackctl qtractor yoshimi"
# USB-Firewall
KATEGORIE_PKGS[u]="usbauth"
# Zubehör
KATEGORIE_PKGS[z]="balena-etcher barrier clamav clamtk doublecmd-common engrampa freefilesync galculator gedit gnome-characters gucharmap keepass2 kfind klavaro ktouch magnus mousepad nmapsi4 onboard pdfmod pluma putty redshift rpi-imager usb-creator-common veracrypt xournal"
if [ $(echo "$OPERATION_SYSTEM" | grep -i -c -E " mint ") -gt 0 ]; then KATEGORIE_PKGS[z]+=" sticky xed"; fi
# Windows-API "Wine"
if [ $(apt list "wine-installer" 2>/dev/null | grep -i -c -E "wine-installer") -gt 0 ];
then
  KATEGORIE_PKGS[w]="wine-installer"
else
  KATEGORIE_PKGS[w]="wine wine64 wine32"
fi
KATEGORIE_PKGS[w]+=" winetricks zenity playonlinux"
# WireGuard
KATEGORIE_PKGS[wg]="wireguard wireguard-tools"
# Mint Tools
KATEGORIE_PKGS[mt]="mintbackup mintdesktop mintdrivers mintinstall mintlocale mintreport mintsources mintstick mintupdate mintwelcome"
# GNOME Tools
KATEGORIE_PKGS[gx]="gnome-control-center gnome-disk-utility gnome-firmware gnome-software gnome-system-tools gnome-terminal gnome-tweaks"
# LXDE Tools
KATEGORIE_PKGS[lx]="lxappearance lxhotkey-gtk lxinput lxrandr lxsession-edit lxtask lxterminal"
# MATE Tools
KATEGORIE_PKGS[mx]="mate-applets mate-control-center mate-indicator-applet mate-media mate-sensors-applet mate-terminal mate-utils"
if [ $(echo "$OPERATION_SYSTEM" | grep -i -c -E " mint ") -gt 0 ];
then
  KATEGORIE_PKGS[mx]+=" mate-calc mate-dock-applet mate-menu mate-tweak mate-user-share"
else
  KATEGORIE_PKGS[mx]+=" mate-desktop-environment-extras"
fi
if [ $(echo "$OPERATION_SYSTEM" | grep -i -c -E "ubuntu") -gt 0 ]; then KATEGORIE_PKGS[mx]+=" software-boutique ubuntu-mate-welcome"; fi
# XFCE Tools
KATEGORIE_PKGS[xx]=""

###############################################################################
# Liste von Paketen, die automatisch zusätzlich zu einem Basispaket installiert
# werden. HINWEIS: Diese Funktionalität ersetzt die vorherige Logik mittels
# DEPENDS_PACK (s.u.), bei welcher alle Pakete durchlaufen werden, aber nur
# die Pakete installiert werden, deren Basispaket bereits installiert ist.
###############################################################################
declare -A AUTO_ADD_PKGS # Liste der zusätzlichen Pakete
declare -A AUTO_ADD_PPOS # Wenn "true" zusätzliche Pakete VOR Basispaket einfügen

AUTO_ADD_PKGS[alien-arena]="alien-arena-data"
AUTO_ADD_PPOS[alien-arena]="true"
AUTO_ADD_PKGS[astromenace]="astromenace-data-src"
AUTO_ADD_PPOS[astromenace]="true"
AUTO_ADD_PKGS[caja]="caja-actions caja-eiciel caja-extensions-common caja-gtkhash caja-image-converter caja-mediainfo caja-open-terminal caja-rename caja-seahorse caja-sendto caja-share caja-wallpaper caja-xattr-tags"
AUTO_ADD_PKGS[doublecmd-common]="doublecmd-gtk"
AUTO_ADD_PKGS[frogatto]="frogatto-data"
AUTO_ADD_PPOS[frogatto]="true"
AUTO_ADD_PKGS[fs-uae]="fs-uae-launcher"
AUTO_ADD_PPOS[fs-uae]=""
AUTO_ADD_PKGS[gcompris-qt]="gcompris-qt-data"
AUTO_ADD_PPOS[gcompris-qt]="true"
AUTO_ADD_PKGS[krita]="krita-l10n"
AUTO_ADD_PKGS[libreoffice]="libreoffice-gnome"
AUTO_ADD_PKGS[libreoffice-common]="libreoffice-gnome"
AUTO_ADD_PKGS[mediainfo]="mediainfo-gui"
AUTO_ADD_PKGS[mkvtoolnix]="mkvtoolnix-gui"
AUTO_ADD_PKGS[redshift]="redshift-gtk"
AUTO_ADD_PKGS[scribus]="scribus-template"
AUTO_ADD_PKGS[usbauth]="usbauth-notifier"
AUTO_ADD_PKGS[usb-creator-common]="usb-creator-gtk"
AUTO_ADD_PKGS[virtualbox]="virtualbox-ext-pack virtualbox-guest-additions-iso"

###############################################################################
# Einige Programme sind nicht in jedem Repository enthalten und können dann
# nicht installiert werden, so dass auch Erweiterungen zu diesen Programmen
# nicht benötigt werden, obwohl diese oft unsinnigerweise installierbar sind.
# Die in der Tabelle DEPENDS_PACK aufgeführten Programme werden daher nur
# dann installiert, wenn auch das zugehörige Basispaket installiert ist.
# HINWEIS: Diese Funktionalität wurde ersetzt durch AUTO_ADD_PKGS (s.o.),
# welche quasi in umgekehrter Logik arbeitet.
###############################################################################
# declare -A DEPENDS_PACK

# DEPENDS_PACK[doublecmd-gtk]="doublecmd-common"
# DEPENDS_PACK[krita-l10n]="krita"
# DEPENDS_PACK[mediainfo-gui]="mediainfo"
# DEPENDS_PACK[mkvtoolnix-gui]="mkvtoolnix"
# DEPENDS_PACK[scribus-template]="scribus"
# DEPENDS_PACK[usbauth-notifier]="usbauth"
# DEPENDS_PACK[usb-creator-gtk]="usb-creator-common"
# DEPENDS_PACK[virtualbox-ext-pack]="virtualbox"
# DEPENDS_PACK[virtualbox-guest-additions-iso]="virtualbox"

###############################################################################
# Alternative ähnliche Programmpakete, welche installiert werden, wenn das
# primäre Paket aus den oben stehenden Paket-Listen nicht verfügbar ist.
# Die alternativen Programmpakete können auch aus externen Quellen sein.
# Sollen mehrere verschiedene Alternativen zu einem Paket geprüft werden,
# diese einfach kaskadierend nach gewünschter Reihenfolge notieren.
###############################################################################
declare -A SIMILAR_PACK

SIMILAR_PACK[blender]="blender-tpaw"
SIMILAR_PACK[brasero]="xfburn"
SIMILAR_PACK[celluloid]="parole"
SIMILAR_PACK[chromium]="chromium-browser"
SIMILAR_PACK[chromium-browser]="chromium-common"
SIMILAR_PACK[czkawka]="fslint"
SIMILAR_PACK[engrampa]="file-roller"
SIMILAR_PACK[exfatprogs]="exfat-utils"
SIMILAR_PACK[file-roller]="xarchiver"
SIMILAR_PACK[firefox]="firefox-esr"
SIMILAR_PACK[gcompris-qt]="gcompris"
SIMILAR_PACK[gnome-tweaks]="gnome-tweak-tool"
SIMILAR_PACK[iptvnator]="hypnotix"
SIMILAR_PACK[hypnotix]="freetuxtv"
SIMILAR_PACK[k3b]="brasero"
SIMILAR_PACK[kid3]="exfalso"
SIMILAR_PACK[libreoffice]="libreoffice-common"
SIMILAR_PACK[magnus]="kmag"
SIMILAR_PACK[microsoft-edge-stable]="microsoft-edge-dev"
SIMILAR_PACK[opera-stable]="opera"
SIMILAR_PACK[p7zip-full]="p7zip"
SIMILAR_PACK[parole]="mpv"
SIMILAR_PACK[pdfchain]="pdfmod"
SIMILAR_PACK[pdfarranger]="pdfmod"
SIMILAR_PACK[pinta]="drawing"
SIMILAR_PACK[transmission-common]="transmission"
SIMILAR_PACK[usb-creator-common]="balena-etcher"
SIMILAR_PACK[virtualbox]="virtualbox-7.0"

###############################################################################
# Liste der Architekturen
###############################################################################
ARCH_NAME_LIST=('amd64' 'i386' 'arm64' 'armhf')

###############################################################################
# Alternative Quellen "ERW": Programmpakete aus den oben stehenden Paketlisten,
# die zwar nicht im Standard-Repository enthalten sind, aber durch Erweiterung
# der Quell-Listen (/etc/apt/sources.list.d) mit apt installiert werden können.
# Diese Pakete erscheinen danach auch mit apt list <PAKETNAME> als installiert.
###############################################################################
declare -A ERW_AUTH_KEY # URLs der Authentifizierungs-Schlüssel
declare -A ERW_REPO_TXT # Repository-Einträge

# HINWEIS: AnyDesk ist aktuell für die arm64-Architektur nicht verfügbar und
# läuft selbst mit viel Aufwand als armhf-Version auf arm64 nur sehr schlecht!
ERW_AUTH_KEY[anydesk]="https://keys.anydesk.com/repos/DEB-GPG-KEY"
ERW_REPO_TXT[anydesk]="deb http://deb.anydesk.com/ all main"

ERW_AUTH_KEY[opera-stable]="https://deb.opera.com/archive.key"
ERW_REPO_TXT[opera-stable]="deb https://deb.opera.com/opera-stable/ stable non-free"

ERW_AUTH_KEY[microsoft-edge-stable]="https://packages.microsoft.com/keys/microsoft.asc"
ERW_REPO_TXT[microsoft-edge-stable]="deb [arch=amd64] https://packages.microsoft.com/repos/edge/ stable main"

ERW_AUTH_KEY[microsoft-edge-dev]="https://packages.microsoft.com/keys/microsoft.asc"
ERW_REPO_TXT[microsoft-edge-dev]="deb [arch=amd64] https://packages.microsoft.com/repos/edge/ stable main"

# In reinen Debian-Systemen ist VirtualBox nicht enthalten,
# aber auf den Original-Seiten von VirtualBox downloadbar.
# ACHTUNG: Der Paketname lautet dann "virtualbox-7.0", nicht nur "virtualbox"
# HINWEIS: Auch als externes Paket verfügbar (s.u. DEB)
if [ $(uname -a 2>/dev/null | grep -i -c -E "debian") -gt 0 ] &&
   [ $(echo "$OS_V_CODENAME" | grep -i -c -E "bookworm") -gt 0 ];
then
  ERW_AUTH_KEY[virtualbox-7.0]="https://www.virtualbox.org/download/oracle_vbox_2016.asc"
  ERW_REPO_TXT[virtualbox-7.0]="deb [arch=amd64] http://download.virtualbox.org/virtualbox/debian bookworm contrib"
fi

# TeamViewer besser mit direkten Download (s.u. DEB) installieren, weil
# TeamViewer bei der Installation seine eigenen Repo-Erweiterungen anlegt
# und dadurch Redundanzen mit unserer Erweiterung enstehen würden.
# ERW_AUTH_KEY[teamviewer]="https://download.teamviewer.com/download/linux/signature/TeamViewer2017.asc"
# ERW_REPO_TXT[teamviewer]="deb https://linux.teamviewer.com/deb stable main"

###############################################################################
# Alternative Quellen "PPA": Programmpakete aus den oben stehenden Paketlisten,
# die zwar nicht im Standard-Repository enthalten sind, aber durch Erweiterung
# des Repository durch ein privates Repo mit apt installiert werden können.
# Diese Pakete erscheinen danach auch mit apt list <PAKETNAME> als installiert.
# HINWEIS: PPA_REPO_SRC beinhaltet soweit bekannt von Paketen selbst angelegte
# Quelldateien und dient nur zum Löschen dieser Dateien im Falle einer nicht
# erfolgreichen Installation, damit diese nicht den Update-Vorgang stören.
###############################################################################
declare -A PPA_REPO_TXT # Repository-Einträge
declare -A PPA_REPO_SRC # Datei mit Quellangaben (siehe auch Hinweis oben!)

PPA_REPO_TXT[makemkv-bin]="ppa:heyarje/makemkv-beta"
PPA_REPO_SRC[makemkv-bin]="heyarje-ubuntu-makemkv-beta*"

###############################################################################
# Alternative Quellen "DEB": Programmpakete aus den oben stehenden Paketlisten,
# welche von Dritt-Anbietern im Format .deb zum Download zur Verfügung gestellt
# werden und mit apt installiert werden können.
# Diese Pakete erscheinen danach auch mit apt list <PAKETNAME> als installiert.
# Bei der Notation des Index kann (muss) zudem auch eine Differenzierung nach
# verschiedenen OS-Architekturen erfolgen: [<PAKETNAME>_<SYSTEMARCHITEKTUR>]
# Falls die heruntergeladenen Dateien verifiziert werden sollen, können in dem
# Feld DEB_PKG_CSUM die Prüfsummen dazu direkt (SHA256 oder SHA512), oder eine
# URL zum Download einer entsprechenden Datei mit Prüfsummen angegeben werden.
# Da die meisten Hersteller für die Programme keinen dauerhaft verlässlichen
# Download-Link zur Verfügung stellen, werden diese Programme in der möglichst
# aktuellen und in jedem Fall geprüften Version von migano.de heruntergeladen.
###############################################################################
declare -A DEB_PKG_NAME # Angezeigter Name des Programms
declare -A DEB_PKG_VERS # Auf migano.de zum Download bereitgestellte Version
declare -A DEB_PKG_MESG # Hinweis zur Installation der neuen Version
declare -A DEB_PKG_EVAL # Kommando zum Testen der Voraussetzungen
declare -A DEB_PKG_FILE # Download-URL
declare -A DEB_PKG_CSUM # Prüfsumme ODER URL zu Prüfsummen-Datei
declare -A DEB_PKG_OLDV # Nummer der Vorgänger-Version (nur amd64)
declare -A DEB_PKG_OLDF # Download-URL der Vorgänger-Version (nur amd64)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# ACHTUNG: ÄNDERUNGEN AUCH IN DEN POST-SCRIPTEN UND "EXUPDATE_PKG_LIST" ABGLEICHEN !
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# Download von https://github.com/balena-io/etcher/releases/latest (https://www.balena.io/etcher/)
# ACHTUNG: Auch als WEB-Version eingetragen (s.u.)!
DEB_PKG_NAME[balena-etcher]="balenaEtcher"
DEB_PKG_OLDV[balena-etcher]="1.18.4"
DEB_PKG_OLDF[balena-etcher]="$RESSOURCE_SERVER_DIR/deb/balena-etcher_1.18.4_amd64.deb"
DEB_PKG_VERS[balena-etcher]="1.18.11"
DEB_PKG_MESG[balena-etcher]=""
DEB_PKG_EVAL[balena-etcher]=""
DEB_PKG_FILE[balena-etcher_amd64]="$RESSOURCE_SERVER_DIR/deb/balena-etcher_1.18.11_amd64.deb"
DEB_PKG_CSUM[balena-etcher_amd64]="$RESSOURCE_SERVER_DIR/deb/balena-etcher_1.18.11_amd64.deb.sha"
 DEB_PKG_FILE[balena-etcher_i386]="" # NUR für 64-bit (32-bit verfügbar aber nicht lauffähig)
 DEB_PKG_CSUM[balena-etcher_i386]="" # NUR für 64-bit (32-bit verfügbar aber nicht lauffähig)
DEB_PKG_FILE[balena-etcher_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[balena-etcher_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_FILE[balena-etcher_armhf]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[balena-etcher_armhf]="" # NICHT für ARM verfügbar

# Download von https://github.com/VSCodium/vscodium
DEB_PKG_NAME[codium]="VSCodium"
DEB_PKG_OLDV[codium]=""
DEB_PKG_OLDF[codium]=""
DEB_PKG_VERS[codium]="1.83.0"
DEB_PKG_MESG[codium]=""
DEB_PKG_EVAL[codium]=""
DEB_PKG_FILE[codium_amd64]="$RESSOURCE_SERVER_DIR/deb/codium_1.83.0.23277_amd64.deb"
DEB_PKG_CSUM[codium_amd64]="$RESSOURCE_SERVER_DIR/deb/codium_1.83.0.23277_amd64.deb.sha"
 DEB_PKG_FILE[codium_i386]="" # NUR für 64-bit verfügbar
 DEB_PKG_CSUM[codium_i386]="" # NUR für 64-bit verfügbar
DEB_PKG_FILE[codium_arm64]="$RESSOURCE_SERVER_DIR/deb/codium_1.83.0.23277_arm64.deb"
DEB_PKG_CSUM[codium_arm64]="$RESSOURCE_SERVER_DIR/deb/codium_1.83.0.23277_arm64.deb.sha"
DEB_PKG_FILE[codium_armhf]="" # NUR für 64-bit verfügbar
DEB_PKG_CSUM[codium_armhf]="" # NUR für 64-bit verfügbar

# Erstellt mittels dpkg-repack :)
DEB_PKG_NAME[grub-customizer]="Grub Customizer"
DEB_PKG_OLDV[grub-customizer]="5.1.0"
DEB_PKG_OLDF[grub-customizer]="$RESSOURCE_SERVER_DIR/deb/grub-customizer_5.1.0-3build1_amd64.deb"
DEB_PKG_VERS[grub-customizer]="5.2.2"
DEB_PKG_MESG[grub-customizer]=""
DEB_PKG_EVAL[grub-customizer]=""
DEB_PKG_FILE[grub-customizer_amd64]="$RESSOURCE_SERVER_DIR/deb/grub-customizer_5.2.2-2_amd64.deb"
DEB_PKG_CSUM[grub-customizer_amd64]="$RESSOURCE_SERVER_DIR/deb/grub-customizer_5.2.2-2_amd64.deb.sha"

# Download von https://ftp5.gwdg.de/pub/linux/debian/mint/packages/pool/main/h/hypnotix
# oder https://github.com/linuxmint/hypnotix/releases
# Nicht bei reinen Debian-Systemen, da diesen einige benötigte Libraries fehlen :(
if [ $(uname -a 2>/dev/null | grep -i -c -E "debian") -eq 0 ];
then
  DEB_PKG_NAME[hypnotix]="Hypnotix"
  DEB_PKG_OLDV[hypnotix]="2.6"
  DEB_PKG_OLDF[hypnotix]="$RESSOURCE_SERVER_DIR/deb/hypnotix_2.6_LAST_20.04_all.deb"
  DEB_PKG_VERS[hypnotix]="3.7"
  DEB_PKG_MESG[hypnotix]="Benötigt mindestens gtk-4.0!"
  DEB_PKG_EVAL[hypnotix]="[ -d /usr/share/gtk-4.0 ]"
  DEB_PKG_FILE[hypnotix_amd64]="$RESSOURCE_SERVER_DIR/deb/hypnotix_3.7_all.deb"
  DEB_PKG_CSUM[hypnotix_amd64]="$RESSOURCE_SERVER_DIR/deb/hypnotix_3.7_all.deb.sha"
  DEB_PKG_FILE[hypnotix_i386]="" # NUR für 64-bit verfügbar
  DEB_PKG_CSUM[hypnotix_i386]="" # NUR für 64-bit verfügbar
  DEB_PKG_FILE[hypnotix_arm64]="$RESSOURCE_SERVER_DIR/deb/hypnotix_3.7_all.deb"
  DEB_PKG_CSUM[hypnotix_arm64]="$RESSOURCE_SERVER_DIR/deb/hypnotix_3.7_all.deb.sha"
  DEB_PKG_FILE[hypnotix_armhf]="" # NUR für 64-bit verfügbar
  DEB_PKG_CSUM[hypnotix_armhf]="" # NUR für 64-bit verfügbar
fi

# Download von https://github.com/4gray/iptvnator
DEB_PKG_NAME[iptvnator]="IPTVnator"
DEB_PKG_OLDV[iptvnator]=""
DEB_PKG_OLDF[iptvnator]=""
DEB_PKG_VERS[iptvnator]="0.14.0"
DEB_PKG_MESG[iptvnator]=""
DEB_PKG_EVAL[iptvnator]=""
DEB_PKG_FILE[iptvnator_amd64]="$RESSOURCE_SERVER_DIR/deb/iptvnator_0.14.0_amd64.deb"
DEB_PKG_CSUM[iptvnator_amd64]="$RESSOURCE_SERVER_DIR/deb/iptvnator_0.14.0_amd64.deb.sha"
DEB_PKG_FILE[iptvnator_i386]="" # NUR für 64-bit verfügbar
DEB_PKG_CSUM[iptvnator_i386]="" # NUR für 64-bit verfügbar
DEB_PKG_FILE[iptvnator_arm64]="$RESSOURCE_SERVER_DIR/deb/iptvnator_0.14.0_arm64.deb"
DEB_PKG_CSUM[iptvnator_arm64]="$RESSOURCE_SERVER_DIR/deb/iptvnator_0.14.0_arm64.deb.sha"
DEB_PKG_FILE[iptvnator_armhf]="" # NUR für 64-bit verfügbar
DEB_PKG_CSUM[iptvnator_armhf]="" # NUR für 64-bit verfügbar

# Download von https://angryip.org/download/#linux
DEB_PKG_NAME[ipscan]="Angry IP Scanner"
DEB_PKG_OLDV[ipscan]=""
DEB_PKG_OLDF[ipscan]=""
DEB_PKG_VERS[ipscan]="3.9.1"
DEB_PKG_MESG[ipscan]=""
DEB_PKG_EVAL[ipscan]=""
DEB_PKG_FILE[ipscan_amd64]="$RESSOURCE_SERVER_DIR/deb/ipscan_3.9.1_amd64.deb"
DEB_PKG_CSUM[ipscan_amd64]="$RESSOURCE_SERVER_DIR/deb/ipscan_3.9.1_amd64.deb.sha"
 DEB_PKG_FILE[ipscan_i386]="$RESSOURCE_SERVER_DIR/deb/ipscan_3.9.1_all.deb"
 DEB_PKG_CSUM[ipscan_i386]="$RESSOURCE_SERVER_DIR/deb/ipscan_3.9.1_all.deb.sha"
DEB_PKG_FILE[ipscan_arm64]="$RESSOURCE_SERVER_DIR/deb/ipscan_3.9.1_all.deb"
DEB_PKG_CSUM[ipscan_arm64]="$RESSOURCE_SERVER_DIR/deb/ipscan_3.9.1_all.deb.sha"
DEB_PKG_FILE[ipscan_armhf]="$RESSOURCE_SERVER_DIR/deb/ipscan_3.9.1_all.deb"
DEB_PKG_CSUM[ipscan_armhf]="$RESSOURCE_SERVER_DIR/deb/ipscan_3.9.1_all.deb.sha"

# Erstellt mittels dpkg-repack :)
# In Debian nicht enthalten und ab Ubuntu 22 leider
# nicht mehr lauffähig wegen fehlender Libraries :(
# Hinweis: Als Flatpack verfügbar ...
# DEB_PKG_NAME[lix]="lix"
# DEB_PKG_OLDV[lix]=""
# DEB_PKG_OLDF[lix]=""
# DEB_PKG_VERS[lix]="0.9.29"
# DEB_PKG_MESG[lix]=""
# DEB_PKG_EVAL[lix]=""
# DEB_PKG_FILE[lix_amd64]="$RESSOURCE_SERVER_DIR/deb/lix_0.9.29-1_amd64.deb"
# DEB_PKG_CSUM[lix_amd64]="$RESSOURCE_SERVER_DIR/deb/lix_0.9.29-1_amd64.deb.sha"

# Download von https://www.nomachine.com/download/linux&id=1
DEB_PKG_NAME[nomachine]="NoMachine"
DEB_PKG_OLDV[nomachine]="8.4.2"
DEB_PKG_OLDF[nomachine]="$RESSOURCE_SERVER_DIR/deb/nomachine_8.4.2_1_amd64.deb"
DEB_PKG_VERS[nomachine]="8.8.1"
DEB_PKG_MESG[nomachine]=""
DEB_PKG_EVAL[nomachine]=""
DEB_PKG_FILE[nomachine_amd64]="$RESSOURCE_SERVER_DIR/deb/nomachine_8.8.1_1_amd64.deb"
DEB_PKG_CSUM[nomachine_amd64]="$RESSOURCE_SERVER_DIR/deb/nomachine_8.8.1_1_amd64.deb.sha"
 DEB_PKG_FILE[nomachine_i386]="$RESSOURCE_SERVER_DIR/deb/nomachine_8.8.1_1_i386.deb"
 DEB_PKG_CSUM[nomachine_i386]="$RESSOURCE_SERVER_DIR/deb/nomachine_8.8.1_1_i386.deb.sha"
DEB_PKG_FILE[nomachine_arm64]="$RESSOURCE_SERVER_DIR/deb/nomachine_8.8.1_1_arm64.deb"
DEB_PKG_CSUM[nomachine_arm64]="$RESSOURCE_SERVER_DIR/deb/nomachine_8.8.1_1_arm64.deb.sha"
DEB_PKG_FILE[nomachine_armhf]="$RESSOURCE_SERVER_DIR/deb/nomachine_8.8.1_1_armhf.deb"
DEB_PKG_CSUM[nomachine_armhf]="$RESSOURCE_SERVER_DIR/deb/nomachine_8.8.1_1_armhf.deb.sha"

# Download von https://www.opera.com/de/download
DEB_PKG_NAME[opera-stable]="Opera"
DEB_PKG_OLDV[opera-stable]=""
DEB_PKG_OLDF[opera-stable]=""
DEB_PKG_VERS[opera-stable]="102.0.4880.70"
DEB_PKG_MESG[opera-stable]=""
DEB_PKG_EVAL[opera-stable]=""
DEB_PKG_FILE[opera-stable_amd64]="$RESSOURCE_SERVER_DIR/deb/opera-stable_102.0.4880.70_amd64.deb"
DEB_PKG_CSUM[opera-stable_amd64]="$RESSOURCE_SERVER_DIR/deb/opera-stable_102.0.4880.70_amd64.deb.sha"
 DEB_PKG_FILE[opera-stable_i386]="" # NUR für 64-bit verfügbar
 DEB_PKG_CSUM[opera-stable_i386]="" # NUR für 64-bit verfügbar
DEB_PKG_FILE[opera-stable_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[opera-stable_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_FILE[opera-stable_armhf]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[opera-stable_armhf]="" # NICHT für ARM verfügbar

# Download von https://www.realvnc.com/de/connect/download/vnc/linux
DEB_PKG_NAME[realvnc-vnc-server]="VNC Server"
DEB_PKG_OLDV[realvnc-vnc-server]="6.9.1"
DEB_PKG_OLDF[realvnc-vnc-server]="$RESSOURCE_SERVER_DIR/deb/VNC-Server-6.9.1-Linux-x64.deb"
DEB_PKG_VERS[realvnc-vnc-server]="7.6.1"
DEB_PKG_MESG[realvnc-vnc-server]=""
DEB_PKG_EVAL[realvnc-vnc-server]=""
DEB_PKG_FILE[realvnc-vnc-server_amd64]="$RESSOURCE_SERVER_DIR/deb/VNC-Server-7.6.1-Linux-x64.deb"
DEB_PKG_CSUM[realvnc-vnc-server_amd64]="$RESSOURCE_SERVER_DIR/deb/VNC-Server-7.6.1-Linux-x64.deb.sha"
 DEB_PKG_FILE[realvnc-vnc-server_i386]="" # Ab Version 7 nicht mehr verfügbar für 32bit
 DEB_PKG_CSUM[realvnc-vnc-server_i386]="" # Ab Version 7 nicht mehr verfügbar für 32bit
DEB_PKG_FILE[realvnc-vnc-server_arm64]="$RESSOURCE_SERVER_DIR/deb/VNC-Server-7.6.1-Linux-ARM64.deb"
DEB_PKG_CSUM[realvnc-vnc-server_arm64]="$RESSOURCE_SERVER_DIR/deb/VNC-Server-7.6.1-Linux-ARM64.deb.sha"
DEB_PKG_FILE[realvnc-vnc-server_armhf]="$RESSOURCE_SERVER_DIR/deb/VNC-Server-7.6.1-Linux-ARMHF.deb"
DEB_PKG_CSUM[realvnc-vnc-server_armhf]="$RESSOURCE_SERVER_DIR/deb/VNC-Server-7.6.1-Linux-ARMHF.deb.sha"

# Download von https://www.realvnc.com/de/connect/download/viewer/linux
DEB_PKG_NAME[realvnc-vnc-viewer]="VNC Viewer"
DEB_PKG_OLDV[realvnc-vnc-viewer]="6.22.315"
DEB_PKG_OLDF[realvnc-vnc-viewer]="$RESSOURCE_SERVER_DIR/deb/VNC-Viewer-6.22.315-Linux-x64.deb"
DEB_PKG_VERS[realvnc-vnc-viewer]="7.6.1"
DEB_PKG_MESG[realvnc-vnc-viewer]=""
DEB_PKG_EVAL[realvnc-vnc-viewer]=""
DEB_PKG_FILE[realvnc-vnc-viewer_amd64]="$RESSOURCE_SERVER_DIR/deb/VNC-Viewer-7.6.1-Linux-x64.deb"
DEB_PKG_CSUM[realvnc-vnc-viewer_amd64]="$RESSOURCE_SERVER_DIR/deb/VNC-Viewer-7.6.1-Linux-x64.deb.sha"
 DEB_PKG_FILE[realvnc-vnc-viewer_i386]="" # Ab Version 7 nicht mehr verfügbar für 32bit
 DEB_PKG_CSUM[realvnc-vnc-viewer_i386]="" # Ab Version 7 nicht mehr verfügbar für 32bit
DEB_PKG_FILE[realvnc-vnc-viewer_arm64]="$RESSOURCE_SERVER_DIR/deb/VNC-Viewer-7.6.1-Linux-ARM64.deb"
DEB_PKG_CSUM[realvnc-vnc-viewer_arm64]="$RESSOURCE_SERVER_DIR/deb/VNC-Viewer-7.6.1-Linux-ARM64.deb.sha"
DEB_PKG_FILE[realvnc-vnc-viewer_armhf]="$RESSOURCE_SERVER_DIR/deb/VNC-Viewer-7.6.1-Linux-ARMHF.deb"
DEB_PKG_CSUM[realvnc-vnc-viewer_armhf]="$RESSOURCE_SERVER_DIR/deb/VNC-Viewer-7.6.1-Linux-ARMHF.deb.sha"

# Download von https://github.com/raspberrypi/rpi-imager
DEB_PKG_NAME[rpi-imager]="RPi-Imager"
DEB_PKG_OLDV[rpi-imager]=""
DEB_PKG_OLDF[rpi-imager]=""
DEB_PKG_VERS[rpi-imager]="1.7.5"
DEB_PKG_MESG[rpi-imager]=""
DEB_PKG_EVAL[rpi-imager]=""
DEB_PKG_FILE[rpi-imager_amd64]="$RESSOURCE_SERVER_DIR/deb/rpi-imager_1.7.5_amd64.deb"
DEB_PKG_CSUM[rpi-imager_amd64]="$RESSOURCE_SERVER_DIR/deb/rpi-imager_1.7.5_amd64.deb.sha"
 DEB_PKG_FILE[rpi-imager_i386]="" # NUR für 64-bit verfügbar
 DEB_PKG_CSUM[rpi-imager_i386]="" # NUR für 64-bit verfügbar
DEB_PKG_FILE[rpi-imager_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[rpi-imager_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_FILE[rpi-imager_armhf]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[rpi-imager_armhf]="" # NICHT für ARM verfügbar

# Downloads automatisch von der Herstellerseite (manuell: https://www.teamviewer.com/de/download/linux)
DEB_PKG_NAME[teamviewer]="TeamViewer"
DEB_PKG_OLDV[teamviewer]=""
DEB_PKG_OLDF[teamviewer]=""
DEB_PKG_VERS[teamviewer]=""
DEB_PKG_MESG[teamviewer]=""
DEB_PKG_EVAL[teamviewer]=""
DEB_PKG_FILE[teamviewer_amd64]="https://download.teamviewer.com/download/linux/teamviewer_amd64.deb"
DEB_PKG_CSUM[teamviewer_amd64]=""
 DEB_PKG_FILE[teamviewer_i386]="https://download.teamviewer.com/download/linux/teamviewer_i386.deb"
 DEB_PKG_CSUM[teamviewer_i386]=""
DEB_PKG_FILE[teamviewer_arm64]="https://download.teamviewer.com/download/linux/teamviewer_arm64.deb"
DEB_PKG_CSUM[teamviewer_arm64]=""
DEB_PKG_FILE[teamviewer_armhf]="https://download.teamviewer.com/download/linux/teamviewer_armhf.deb"
DEB_PKG_CSUM[teamviewer_armhf]=""

# Erstellt mittels dpkg-repack :)
# (Ginge aber auch per Download von https://pkgs.org/download/usb-creator-common)
DEB_PKG_NAME[usb-creator-common]="USB-Creator-Common"
DEB_PKG_OLDV[usb-creator-common]=""
DEB_PKG_OLDF[usb-creator-common]=""
DEB_PKG_VERS[usb-creator-common]="0.0.3.13"
DEB_PKG_MESG[usb-creator-common]=""
DEB_PKG_EVAL[usb-creator-common]=""
DEB_PKG_FILE[usb-creator-common_amd64]="$RESSOURCE_SERVER_DIR/deb/usb-creator-common_0.3.13_amd64.deb"
DEB_PKG_CSUM[usb-creator-common_amd64]="$RESSOURCE_SERVER_DIR/deb/usb-creator-common_0.3.13_amd64.deb.sha"
 DEB_PKG_FILE[usb-creator-common_i386]="" # NUR für 64-bit gepackt
 DEB_PKG_CSUM[usb-creator-common_i386]="" # NUR für 64-bit gepackt
DEB_PKG_FILE[usb-creator-common_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[usb-creator-common_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_FILE[usb-creator-common_armhf]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[usb-creator-common_armhf]="" # NICHT für ARM verfügbar

# Erstellt mittels dpkg-repack :)
# (Ginge aber auch per Download von https://pkgs.org/download/usb-creator-gtk)
DEB_PKG_NAME[usb-creator-gtk]="USB-Creator-GTK"
DEB_PKG_OLDV[usb-creator-gtk]=""
DEB_PKG_OLDF[usb-creator-gtk]=""
DEB_PKG_VERS[usb-creator-gtk]="0.0.3.13"
DEB_PKG_MESG[usb-creator-gtk]=""
DEB_PKG_EVAL[usb-creator-gtk]=""
DEB_PKG_FILE[usb-creator-gtk_amd64]="$RESSOURCE_SERVER_DIR/deb/usb-creator-gtk_0.3.13_amd64.deb"
DEB_PKG_CSUM[usb-creator-gtk_amd64]="$RESSOURCE_SERVER_DIR/deb/usb-creator-gtk_0.3.13_amd64.deb.sha"
 DEB_PKG_FILE[usb-creator-gtk_i386]="" # NUR für 64-bit gepackt
 DEB_PKG_CSUM[usb-creator-gtk_i386]="" # NUR für 64-bit gepackt
DEB_PKG_FILE[usb-creator-gtk_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[usb-creator-gtk_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_FILE[usb-creator-gtk_armhf]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[usb-creator-gtk_armhf]="" # NICHT für ARM verfügbar

# -----------------------------------------------------------------------------
# Download von https://veracrypt.fr/en/Downloads.html
# ACHTUNG: BEI ÄNDERUNGEN AUCH DIE DATEI "veracrypt-1.25.9-sha256sum.txt" DOWNLOADEN
#          UND AUF DEM SERVER ALS "veracrypt-1.25.9-sha256sum.sha" SPEICHERN !!!
# VeraCrypt bietet weiter differenzierte Pakete an ----------------------------
OPSYS_PART=""
# Zuerst testen ob Ubuntu ...
if [ $(uname -a 2>/dev/null | grep -i -c -E "ubuntu") -gt 0 ];
then
  OPSYS_PART="Ubuntu-$UBUNTU_VERSION"
else
  # ... danach ob Debian
  if [ $(uname -a 2>/dev/null | grep -i -c -E "debian") -gt 0 ]
  then
    OPSYS_PART="Debian-$DEBIAN_VERSION"
  fi
fi
if [ "$OPSYS_PART" != "" ];
then
  DEB_PKG_NAME[veracrypt]="VeraCrypt"
  DEB_PKG_OLDV[veracrypt]=""
  DEB_PKG_OLDF[veracrypt]=""
  DEB_PKG_VERS[veracrypt]="1.25.9"
  DEB_PKG_MESG[veracrypt]=""
  DEB_PKG_EVAL[veracrypt]=""
  DEB_PKG_FILE[veracrypt_amd64]="$RESSOURCE_SERVER_DIR/deb/veracrypt-1.25.9-$OPSYS_PART-amd64.deb"
  DEB_PKG_CSUM[veracrypt_amd64]="$RESSOURCE_SERVER_DIR/deb/veracrypt-1.25.9-sha256sum.sha"
   DEB_PKG_FILE[veracrypt_i386]="" # Nur als generischer Installer verfügbar (nicht aufgenommen)
   DEB_PKG_CSUM[veracrypt_i386]="" # Nur als generischer Installer verfügbar (nicht aufgenommen)
  DEB_PKG_FILE[veracrypt_arm64]="$RESSOURCE_SERVER_DIR/deb/veracrypt-1.25.9-$OPSYS_PART-arm64.deb"
  DEB_PKG_CSUM[veracrypt_arm64]="$RESSOURCE_SERVER_DIR/deb/veracrypt-1.25.9-sha256sum.sha"
  DEB_PKG_FILE[veracrypt_armhf]="$RESSOURCE_SERVER_DIR/deb/veracrypt-1.25.9-$OPSYS_PART-armhf.deb"
  DEB_PKG_CSUM[veracrypt_armhf]="$RESSOURCE_SERVER_DIR/deb/veracrypt-1.25.9-sha256sum.sha"
fi
# -----------------------------------------------------------------------------

# Download von https://www.xnview.com/de/xnviewmp/#downloads
DEB_PKG_NAME[xnview]="XnView MP"
DEB_PKG_OLDV[xnview]="1.4.4"
DEB_PKG_OLDF[xnview]="$RESSOURCE_SERVER_DIR/deb/XnViewMP_1.00-linux-x64.deb"
DEB_PKG_VERS[xnview]="1.5.5"
DEB_PKG_MESG[xnview]=""
DEB_PKG_EVAL[xnview]=""
DEB_PKG_FILE[xnview_amd64]="$RESSOURCE_SERVER_DIR/deb/XnViewMP_1.5.5-linux-x64.deb"
DEB_PKG_CSUM[xnview_amd64]="$RESSOURCE_SERVER_DIR/deb/XnViewMP_1.5.5-linux-x64.deb.sha"
 DEB_PKG_FILE[xnview_i386]="$RESSOURCE_SERVER_DIR/deb/XnViewMP_0.89-linux-x32.deb"
 DEB_PKG_CSUM[xnview_i386]="$RESSOURCE_SERVER_DIR/deb/XnViewMP_0.89-linux-x32.deb.sha"
DEB_PKG_FILE[xnview_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[xnview_arm64]="" # NICHT für ARM verfügbar
DEB_PKG_FILE[xnview_armhf]="" # NICHT für ARM verfügbar
DEB_PKG_CSUM[xnview_armhf]="" # NICHT für ARM verfügbar

# -----------------------------------------------------------------------------
# Zusätzliche Pakete, die zwar im Standard-Repository von Ubuntu, aber nicht
# in dem von Debian enthalten sind. Da die betroffenen Pakete vermutlich nur
# auf neueren Rechnern laufen, werden diese zudem nur für amd64 angeboten.
# Manche Pakete sind obwohl nicht im Repo trotzdem auf den Debian-Servern
# verfügbar unter: https://www.debian.org/distrib/packages#search_packages
# -----------------------------------------------------------------------------
if [ $(echo "$DEBIAN_CODE" | grep -i -c -E "bookworm") -gt 0 ];
then

  DEB_PKG_NAME[alien-arena]="Alien Arena"
  DEB_PKG_OLDV[alien-arena]=""
  DEB_PKG_OLDF[alien-arena]=""
  DEB_PKG_VERS[alien-arena]="7.71.3"
  DEB_PKG_MESG[alien-arena]=""
  DEB_PKG_EVAL[alien-arena]=""
  DEB_PKG_FILE[alien-arena_amd64]="$RESSOURCE_SERVER_DIR/deb/alien-arena_7.71.3+dfsg-3_amd64.deb"
  DEB_PKG_CSUM[alien-arena_amd64]="$RESSOURCE_SERVER_DIR/deb/alien-arena_7.71.3+dfsg-3_amd64.deb.sha"

  DEB_PKG_NAME[alien-arena-data]="Alien Arena Data"
  DEB_PKG_OLDV[alien-arena-data]=""
  DEB_PKG_OLDF[alien-arena-data]=""
  DEB_PKG_VERS[alien-arena-data]="7.71.3"
  DEB_PKG_MESG[alien-arena-data]=""
  DEB_PKG_EVAL[alien-arena-data]=""
  DEB_PKG_FILE[alien-arena-data_amd64]="$RESSOURCE_SERVER_DIR/deb/alien-arena-data_7.71.3+ds-1_all.deb"
  DEB_PKG_CSUM[alien-arena-data_amd64]="$RESSOURCE_SERVER_DIR/deb/alien-arena-data_7.71.3+ds-1_all.deb.sha"

  DEB_PKG_NAME[astromenace]="Astromenace"
  DEB_PKG_OLDV[astromenace]=""
  DEB_PKG_OLDF[astromenace]=""
  DEB_PKG_VERS[astromenace]="1.3.2"
  DEB_PKG_MESG[astromenace]=""
  DEB_PKG_EVAL[astromenace]=""
  DEB_PKG_FILE[astromenace_amd64]="$RESSOURCE_SERVER_DIR/deb/astromenace_1.3.2+repack-7_amd64.deb"
  DEB_PKG_CSUM[astromenace_amd64]="$RESSOURCE_SERVER_DIR/deb/astromenace_1.3.2+repack-7_amd64.deb.sha"

  DEB_PKG_NAME[astromenace-data-src]="Astromenace Data"
  DEB_PKG_OLDV[astromenace-data-src]=""
  DEB_PKG_OLDF[astromenace-data-src]=""
  DEB_PKG_VERS[astromenace-data-src]="1.3.2"
  DEB_PKG_MESG[astromenace-data-src]=""
  DEB_PKG_EVAL[astromenace-data-src]=""
  DEB_PKG_FILE[astromenace-data-src_amd64]="$RESSOURCE_SERVER_DIR/deb/astromenace-data-src_1.3.2+repack-3_all.deb"
  DEB_PKG_CSUM[astromenace-data-src_amd64]="$RESSOURCE_SERVER_DIR/deb/astromenace-data-src_1.3.2+repack-3_all.deb.sha"

  DEB_PKG_NAME[frogatto]="Frogatto"
  DEB_PKG_OLDV[frogatto]=""
  DEB_PKG_OLDF[frogatto]=""
  DEB_PKG_VERS[frogatto]="1.3.1"
  DEB_PKG_MESG[frogatto]=""
  DEB_PKG_EVAL[frogatto]=""
  DEB_PKG_FILE[frogatto_amd64]="$RESSOURCE_SERVER_DIR/deb/frogatto_1.3.1+dfsg-6+b2_amd64.deb"
  DEB_PKG_CSUM[frogatto_amd64]="$RESSOURCE_SERVER_DIR/deb/frogatto_1.3.1+dfsg-6+b2_amd64.deb.sha"

  DEB_PKG_NAME[frogatto-data]="Frogatto Data"
  DEB_PKG_OLDV[frogatto-data]=""
  DEB_PKG_OLDF[frogatto-data]=""
  DEB_PKG_VERS[frogatto-data]="1.3.1"
  DEB_PKG_MESG[frogatto-data]=""
  DEB_PKG_EVAL[frogatto-data]=""
  DEB_PKG_FILE[frogatto-data_amd64]="$RESSOURCE_SERVER_DIR/deb/frogatto-data_1.3.1+dfsg-3_all.deb"
  DEB_PKG_CSUM[frogatto-data_amd64]="$RESSOURCE_SERVER_DIR/deb/frogatto-data_1.3.1+dfsg-3_all.deb.sha"

  DEB_PKG_NAME[gcompris-qt]="GCompris"
  DEB_PKG_OLDV[gcompris-qt]=""
  DEB_PKG_OLDF[gcompris-qt]=""
  DEB_PKG_VERS[gcompris-qt]="3.1.2"
  DEB_PKG_MESG[gcompris-qt]=""
  DEB_PKG_EVAL[gcompris-qt]=""
  DEB_PKG_FILE[gcompris-qt_amd64]="$RESSOURCE_SERVER_DIR/deb/gcompris-qt_3.1-2_amd64.deb"
  DEB_PKG_CSUM[gcompris-qt_amd64]="$RESSOURCE_SERVER_DIR/deb/gcompris-qt_3.1-2_amd64.deb.sha"

  DEB_PKG_NAME[gcompris-qt-data]="GCompris Data"
  DEB_PKG_OLDV[gcompris-qt-data]=""
  DEB_PKG_OLDF[gcompris-qt-data]=""
  DEB_PKG_VERS[gcompris-qt-data]="3.1.2"
  DEB_PKG_MESG[gcompris-qt-data]=""
  DEB_PKG_EVAL[gcompris-qt-data]=""
  DEB_PKG_FILE[gcompris-qt-data_amd64]="$RESSOURCE_SERVER_DIR/deb/gcompris-qt-data_3.1-2_all.deb"
  DEB_PKG_CSUM[gcompris-qt-data_amd64]="$RESSOURCE_SERVER_DIR/deb/gcompris-qt-data_3.1-2_all.deb.sha"

  DEB_PKG_NAME[libdvd-pkg]="libdvd-pkg"
  DEB_PKG_OLDV[libdvd-pkg]=""
  DEB_PKG_OLDF[libdvd-pkg]=""
  DEB_PKG_VERS[libdvd-pkg]="1.4.3"
  DEB_PKG_MESG[libdvd-pkg]=""
  DEB_PKG_EVAL[libdvd-pkg]=""
  DEB_PKG_FILE[libdvd-pkg_amd64]="$RESSOURCE_SERVER_DIR/deb/libdvd-pkg_1.4.3-1-1_all.deb"
  DEB_PKG_CSUM[libdvd-pkg_amd64]="$RESSOURCE_SERVER_DIR/deb/libdvd-pkg_1.4.3-1-1_all.deb.sha"

  DEB_PKG_NAME[pdfmod]="PDF Mod"
  DEB_PKG_OLDV[pdfmod]=""
  DEB_PKG_OLDF[pdfmod]=""
  DEB_PKG_VERS[pdfmod]="0.9.1"
  DEB_PKG_MESG[pdfmod]=""
  DEB_PKG_EVAL[pdfmod]=""
  DEB_PKG_FILE[pdfmod_amd64]="$RESSOURCE_SERVER_DIR/deb/pdfmod_0.9.1-8.2_all.deb"
  DEB_PKG_CSUM[pdfmod_amd64]="$RESSOURCE_SERVER_DIR/deb/pdfmod_0.9.1-8.2_all.deb.sha"

  DEB_PKG_NAME[pinta]="Pinta"
  DEB_PKG_OLDV[pinta]=""
  DEB_PKG_OLDF[pinta]=""
  DEB_PKG_VERS[pinta]="1.6"
  DEB_PKG_MESG[pinta]=""
  DEB_PKG_EVAL[pinta]=""
  DEB_PKG_FILE[pinta_amd64]="$RESSOURCE_SERVER_DIR/deb/pinta_1.6-2.1_all.deb"
  DEB_PKG_CSUM[pinta_amd64]="$RESSOURCE_SERVER_DIR/deb/pinta_1.6-2.1_all.deb.sha"

  DEB_PKG_NAME[playonlinux]="PlayOnLinux"
  DEB_PKG_OLDV[playonlinux]=""
  DEB_PKG_OLDF[playonlinux]=""
  DEB_PKG_VERS[playonlinux]="4.3.4"
  DEB_PKG_MESG[playonlinux]=""
  DEB_PKG_EVAL[playonlinux]=""
  DEB_PKG_FILE[playonlinux_amd64]="$RESSOURCE_SERVER_DIR/deb/playonlinux_4.3.4-3_all.deb"
  DEB_PKG_CSUM[playonlinux_amd64]="$RESSOURCE_SERVER_DIR/deb/playonlinux_4.3.4-3_all.deb.sha"

  DEB_PKG_NAME[rocksndiamonds]="Rocks n Diamonds"
  DEB_PKG_OLDV[rocksndiamonds]=""
  DEB_PKG_OLDF[rocksndiamonds]=""
  DEB_PKG_VERS[rocksndiamonds]="4.3.5.1"
  DEB_PKG_MESG[rocksndiamonds]=""
  DEB_PKG_EVAL[rocksndiamonds]=""
  DEB_PKG_FILE[rocksndiamonds_amd64]="$RESSOURCE_SERVER_DIR/deb/rocksndiamonds_4.3.5.1+dfsg-1_amd64.deb"
  DEB_PKG_CSUM[rocksndiamonds_amd64]="$RESSOURCE_SERVER_DIR/deb/rocksndiamonds_4.3.5.1+dfsg-1_amd64.deb.sha"

  DEB_PKG_NAME[sauerbraten]="Sauerbraten"
  DEB_PKG_OLDV[sauerbraten]=""
  DEB_PKG_OLDF[sauerbraten]=""
  DEB_PKG_VERS[sauerbraten]="0.0.20021227"
  DEB_PKG_MESG[sauerbraten]=""
  DEB_PKG_EVAL[sauerbraten]=""
  DEB_PKG_FILE[sauerbraten_amd64]="$RESSOURCE_SERVER_DIR/deb/sauerbraten_0.0.20201227-1_all.deb"
  DEB_PKG_CSUM[sauerbraten_amd64]="$RESSOURCE_SERVER_DIR/deb/sauerbraten_0.0.20201227-1_all.deb.sha"

  DEB_PKG_NAME[winetricks]="Winetricks"
  DEB_PKG_OLDV[winetricks]=""
  DEB_PKG_OLDF[winetricks]=""
  DEB_PKG_VERS[winetricks]="20230212"
  DEB_PKG_MESG[winetricks]=""
  DEB_PKG_EVAL[winetricks]=""
  DEB_PKG_FILE[winetricks_amd64]="$RESSOURCE_SERVER_DIR/deb/winetricks_20230212-2_all.deb"
  DEB_PKG_CSUM[winetricks_amd64]="$RESSOURCE_SERVER_DIR/deb/winetricks_20230212-2_all.deb.sha"

  DEB_PKG_NAME[youtube-dl]="Youtube-Dl"
  DEB_PKG_OLDV[youtube-dl]=""
  DEB_PKG_OLDF[youtube-dl]=""
  DEB_PKG_VERS[youtube-dl]="2021.12.17"
  DEB_PKG_MESG[youtube-dl]=""
  DEB_PKG_EVAL[youtube-dl]=""
  DEB_PKG_FILE[youtube-dl_amd64]="$RESSOURCE_SERVER_DIR/deb/youtube-dl_2021.12.17-2_all.deb"
  DEB_PKG_CSUM[youtube-dl_amd64]="$RESSOURCE_SERVER_DIR/deb/youtube-dl_2021.12.17-2_all.deb.sha"

  DEB_PKG_NAME[youtubedl-gui]="YoutubeDl-GUI"
  DEB_PKG_OLDV[youtubedl-gui]=""
  DEB_PKG_OLDF[youtubedl-gui]=""
  DEB_PKG_VERS[youtubedl-gui]="3.0"
  DEB_PKG_MESG[youtubedl-gui]=""
  DEB_PKG_EVAL[youtubedl-gui]=""
  DEB_PKG_FILE[youtubedl-gui_amd64]="$RESSOURCE_SERVER_DIR/deb/youtubedl-gui_3.0-2_amd64.deb"
  DEB_PKG_CSUM[youtubedl-gui_amd64]="$RESSOURCE_SERVER_DIR/deb/youtubedl-gui_3.0-2_amd64.deb.sha"

  DEB_PKG_NAME[yt-dlp]="Yt-Dlp"
  DEB_PKG_OLDV[yt-dlp]=""
  DEB_PKG_OLDF[yt-dlp]=""
  DEB_PKG_VERS[yt-dlp]="2023.03.04"
  DEB_PKG_MESG[yt-dlp]=""
  DEB_PKG_EVAL[yt-dlp]=""
  DEB_PKG_FILE[yt-dlp_amd64]="$RESSOURCE_SERVER_DIR/deb/yt-dlp_2023.03.04-1_all.deb"
  DEB_PKG_CSUM[yt-dlp_amd64]="$RESSOURCE_SERVER_DIR/deb/yt-dlp_2023.03.04-1_all.deb.sha"

  # Download von https://www.virtualbox.org/wiki/Linux_Downloads
  # ACHTUNG: Der Paketname lautet dann "virtualbox-7.0", nicht nur "virtualbox"
  # HINWEIS: Auch als Repo-Erweiterung verfügbar (s.o. ERW)
  if [ $(uname -a 2>/dev/null | grep -i -c -E "debian") ];
  then
    DEB_PKG_NAME[virtualbox-7.0]="VirtualBox 7.0"
    DEB_PKG_OLDV[virtualbox-7.0]=""
    DEB_PKG_OLDF[virtualbox-7.0]=""
    DEB_PKG_VERS[virtualbox-7.0]="7.0.10"
    DEB_PKG_MESG[virtualbox-7.0]=""
    DEB_PKG_EVAL[virtualbox-7.0]=""
    DEB_PKG_FILE[virtualbox-7.0_amd64]="$RESSOURCE_SERVER_DIR/deb/virtualbox-7.0_7.0.10-158379~Debian~bookworm_amd64.deb"
    DEB_PKG_CSUM[virtualbox-7.0_amd64]="$RESSOURCE_SERVER_DIR/deb/virtualbox-7.0_7.0.10-158379~Debian~bookworm_amd64.deb.sha"
  fi

fi
# -----------------------------------------------------------------------------

###############################################################################

###############################################################################
# Ordner zur Einrichtung nur der kopierten Programmpakete von Dritt-Anbietern
# (siehe WEB_PKG_FILE). Je Programmpaket wird darin automatisch ein weiterer
# Unterordner mit dem in WEB_PKG_NAME definierten Namen erstellt.
# ACHTUNG: Angaben OHNE Slash (/) am Ende!
###############################################################################
if [ "$USER_USERNAME" = "root" ];
then
  WEB_PKG_DIR="/opt"
else
  WEB_PKG_DIR="/home/$USER_USERNAME/apps"
fi

###############################################################################
# Alternative Quellen "WEB": Programmpakete aus den oben stehenden Paketlisten,
# die in Form ausführbarer Dateien von Dritt-Anbietern heruntergeladen und
# in einen lokalen Ordner (siehe WEB_PKG_DIR) entpackt/kopiert werden können.
# Diese Programme erscheinen NICHT als mit apt installierte Pakete!
# Die als Index aufgeführten Paketnamen dienen somit nur der Zuordnung zu
# einer Kategorie, sowie zur Auswahl der Installationsart in diesem Script.
# Bei der Notation des Index kann (muss) zudem auch eine Differenzierung nach
# verschiedenen OS-Architekturen erfolgen: [<PAKETNAME>_<SYSTEMARCHITEKTUR>]
# Falls die heruntergeladenen Dateien verifiziert werden sollen, können in dem
# Feld WEB_PKG_CSUM die Prüfsummen dazu direkt (SHA256 oder SHA512), oder eine
# URL zum Download einer entsprechenden Datei mit Prüfsummen angegeben werden.
# Da die meisten Hersteller für die Programme keinen dauerhaft verlässlichen
# Download-Link zur Verfügung stellen, werden diese Programme in der möglichst
# aktuellen und in jedem Fall geprüften Version von migano.de heruntergeladen.
###############################################################################
declare -A WEB_PKG_NAME # Angezeigter Name des Programms und zugleich der Ordnername,
                        # in welchen die jeweiligen Programm-Dateien gespeichert werden
                        # ACHTUNG: Nur der Ordnername, nicht der vollständge Pfad (siehe WEB_PKG_DIR)!
declare -A WEB_PKG_VERS # Auf migano.de zum Download bereitgestellte Version
declare -A WEB_PKG_MESG # Hinweis zur Installation der neuen Version
declare -A WEB_PKG_EVAL # Kommando zum Testen der Voraussetzungen
declare -A WEB_PKG_FILE # Download-URL
declare -A WEB_PKG_CSUM # Prüfsumme ODER URL zu Prüfsummen-Datei
declare -A WEB_PKG_CATY # Kategorie für den Linux-Menü-Eintrag (NICHT unsere Kategorien)
declare -A WEB_PKG_OLDV # Nummer der Vorgänger-Version (nur amd64)
declare -A WEB_PKG_OLDF # Download-URL der Vorgänger-Version (nur amd64)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# ACHTUNG: ÄNDERUNGEN AUCH IN DEN POST-SCRIPTEN UND "EXUPDATE_PKG_LIST" ABGLEICHEN !
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# Download von https://github.com/balena-io/etcher/releases/latest (https://www.balena.io/etcher/)
# ACHTUNG: Auch als DEB eingetragen (s.o.)!
WEB_PKG_NAME[balena-etcher]="balenaEtcher"
WEB_PKG_CATY[balena-etcher]="System;Utility"
WEB_PKG_OLDV[balena-etcher]="1.18.4"
WEB_PKG_OLDF[balena-etcher]="$RESSOURCE_SERVER_DIR/web/balenaEtcher-1.18.4-x64.AppImage"
WEB_PKG_VERS[balena-etcher]="1.18.11"
WEB_PKG_MESG[balena-etcher]=""
WEB_PKG_EVAL[balena-etcher]=""
WEB_PKG_FILE[balena-etcher_amd64]="$RESSOURCE_SERVER_DIR/web/balenaEtcher-1.18.11-x64.AppImage"
WEB_PKG_CSUM[balena-etcher_amd64]="$RESSOURCE_SERVER_DIR/web/balenaEtcher-1.18.11-x64.AppImage.sha"
 WEB_PKG_FILE[balena-etcher_i386]="" # NUR für 64-bit (32-bit verfügbar aber nicht lauffähig)
 WEB_PKG_CSUM[balena-etcher_i386]="" # NUR für 64-bit (32-bit verfügbar aber nicht lauffähig)
WEB_PKG_FILE[balena-etcher_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[balena-etcher_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_FILE[balena-etcher_armhf]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[balena-etcher_armhf]="" # NICHT für ARM verfügbar

# Eigene Zusammenstellung ;)
WEB_PKG_NAME[code-the-classics]="Code-the-Classics"
WEB_PKG_CATY[code-the-classics]="Games"
WEB_PKG_OLDV[code-the-classics]=""
WEB_PKG_OLDF[code-the-classics]=""
WEB_PKG_VERS[code-the-classics]="1.00"
WEB_PKG_MESG[code-the-classics]=""
WEB_PKG_EVAL[code-the-classics]=""
WEB_PKG_FILE[code-the-classics_amd64]="$RESSOURCE_SERVER_DIR/web/Code-the-Classics.tar.gz"
WEB_PKG_CSUM[code-the-classics_amd64]="$RESSOURCE_SERVER_DIR/web/Code-the-Classics.tar.gz.sha"
 WEB_PKG_FILE[code-the-classics_i386]="$RESSOURCE_SERVER_DIR/web/Code-the-Classics.tar.gz"
 WEB_PKG_CSUM[code-the-classics_i386]="$RESSOURCE_SERVER_DIR/web/Code-the-Classics.tar.gz.sha"
WEB_PKG_FILE[code-the-classics_arm64]="$RESSOURCE_SERVER_DIR/web/Code-the-Classics.tar.gz"
WEB_PKG_CSUM[code-the-classics_arm64]="$RESSOURCE_SERVER_DIR/web/Code-the-Classics.tar.gz.sha"
WEB_PKG_FILE[code-the-classics_armhf]="$RESSOURCE_SERVER_DIR/web/Code-the-Classics.tar.gz"
WEB_PKG_CSUM[code-the-classics_armhf]="$RESSOURCE_SERVER_DIR/web/Code-the-Classics.tar.gz.sha"

# Download von https://github.com/qarmin/czkawka/releases
WEB_PKG_NAME[czkawka]="Czkawka"
WEB_PKG_CATY[czkawka]="System;Utility"
WEB_PKG_OLDV[czkawka]="4.1.0"
WEB_PKG_OLDF[czkawka]="$RESSOURCE_SERVER_DIR/web/linux_czkawka_gui_4.1.0"
WEB_PKG_VERS[czkawka]="6.0.0"
WEB_PKG_MESG[czkawka]="Benötigt mindestens gtk-4.0!"
WEB_PKG_EVAL[czkawka]="[ -d /usr/share/gtk-4.0 ]"
WEB_PKG_FILE[czkawka_amd64]="$RESSOURCE_SERVER_DIR/web/linux_czkawka_gui_6.0.0"
WEB_PKG_CSUM[czkawka_amd64]="$RESSOURCE_SERVER_DIR/web/linux_czkawka_gui_6.0.0.sha"
 WEB_PKG_FILE[czkawka_i386]="$RESSOURCE_SERVER_DIR/web/linux_czkawka_gui_6.0.0"
 WEB_PKG_CSUM[czkawka_i386]="$RESSOURCE_SERVER_DIR/web/linux_czkawka_gui_6.0.0.sha"
WEB_PKG_FILE[czkawka_arm64]="" # Ab Ubuntu 21 nur als Snap
WEB_PKG_CSUM[czkawka_arm64]="" # Ab Ubuntu 21 nur als Snap
WEB_PKG_FILE[czkawka_armhf]="" # NICHT verfügbar
WEB_PKG_CSUM[czkawka_armhf]="" # NICHT verfügbar

# Download von https://freefilesync.org/download.php
WEB_PKG_NAME[freefilesync]="FreeFileSync"
WEB_PKG_CATY[freefilesync]="System;Utility"
WEB_PKG_OLDV[freefilesync]="12.2"
WEB_PKG_OLDF[freefilesync]="$RESSOURCE_SERVER_DIR/web/FreeFileSync_12.2_Linux.tar.gz"
WEB_PKG_VERS[freefilesync]="13.0"
WEB_PKG_MESG[freefilesync]=""
WEB_PKG_EVAL[freefilesync]=""
WEB_PKG_FILE[freefilesync_amd64]="$RESSOURCE_SERVER_DIR/web/FreeFileSync_13.0_Linux.tar.gz"
WEB_PKG_CSUM[freefilesync_amd64]="$RESSOURCE_SERVER_DIR/web/FreeFileSync_13.0_Linux.tar.gz.sha"
 WEB_PKG_FILE[freefilesync_i386]="" # NUR für 64-bit (32-bit verfügbar aber nicht lauffähig)
 WEB_PKG_CSUM[freefilesync_i386]="" # NUR für 64-bit (32-bit verfügbar aber nicht lauffähig)
WEB_PKG_FILE[freefilesync_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[freefilesync_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_FILE[freefilesync_armhf]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[freefilesync_armhf]="" # NICHT für ARM verfügbar

# Download von https://fs-uae.net/download#linux
WEB_PKG_NAME[fs-uae]="FS-UAE"
WEB_PKG_CATY[fs-uae]="Games"
WEB_PKG_OLDV[fs-uae]=""
WEB_PKG_OLDF[fs-uae]=""
WEB_PKG_VERS[fs-uae]="3.1.66"
WEB_PKG_MESG[fs-uae]=""
WEB_PKG_EVAL[fs-uae]=""
WEB_PKG_FILE[fs-uae_amd64]="$RESSOURCE_SERVER_DIR/web/FS-UAE_3.1.66_Linux_x86-64.tar.xz"
WEB_PKG_CSUM[fs-uae_amd64]="$RESSOURCE_SERVER_DIR/web/FS-UAE_3.1.66_Linux_x86-64.tar.xz.sha"
 WEB_PKG_FILE[fs-uae_i386]="$RESSOURCE_SERVER_DIR/web/FS-UAE_3.1.66_Linux_x86-64.tar.xz"
 WEB_PKG_CSUM[fs-uae_i386]="$RESSOURCE_SERVER_DIR/web/FS-UAE_3.1.66_Linux_x86-64.tar.xz.sha"
WEB_PKG_FILE[fs-uae_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[fs-uae_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_FILE[fs-uae_armhf]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[fs-uae_armhf]="" # NICHT für ARM verfügbar

# Download von https://fs-uae.net/download#linux
# Wird aktuell auf Debian bookworm leider noch nicht unterstützt :(
# ACHTUNG: Als externes Paket muss FS-USE-Launcher mit FS-UAE
# auf der selben Ordner-Ebene liegen (s.a. POST_INST_CONF)
WEB_PKG_NAME[fs-uae-launcher]="FS-UAE-Launcher"
WEB_PKG_CATY[fs-uae-launcher]="Games"
WEB_PKG_OLDV[fs-uae-launcher]=""
WEB_PKG_OLDF[fs-uae-launcher]=""
WEB_PKG_VERS[fs-uae-launcher]="3.1.68"
WEB_PKG_MESG[fs-uae-launcher]="FS-UAE-Launcher funktioniert nur auf älteren Debian-Versionen."
WEB_PKG_EVAL[fs-uae-launcher]="[ $(echo ${OS_V_CODENAME} | grep -i -c -E "bookworm") -eq 0 ]"
WEB_PKG_FILE[fs-uae-launcher_amd64]="$RESSOURCE_SERVER_DIR/web/FS-UAE-Launcher_3.1.68_Linux_x86-64.tar.xz"
WEB_PKG_CSUM[fs-uae-launcher_amd64]="$RESSOURCE_SERVER_DIR/web/FS-UAE-Launcher_3.1.68_Linux_x86-64.tar.xz.sha"
 WEB_PKG_FILE[fs-uae-launcher_i386]="$RESSOURCE_SERVER_DIR/web/FS-UAE-Launcher_3.1.68_Linux_x86-64.tar.xz"
 WEB_PKG_CSUM[fs-uae-launcher_i386]="$RESSOURCE_SERVER_DIR/web/FS-UAE-Launcher_3.1.68_Linux_x86-64.tar.xz.sha"
WEB_PKG_FILE[fs-uae-launcher_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[fs-uae-launcher_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_FILE[fs-uae-launcher_armhf]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[fs-uae-launcher_armhf]="" # NICHT für ARM verfügbar

# Download von http://oolite.space oder https://github.com/OoliteProject
WEB_PKG_NAME[oolite]="Oolite"
WEB_PKG_CATY[oolite]="Games"
WEB_PKG_OLDV[oolite]=""
WEB_PKG_OLDF[oolite]=""
WEB_PKG_VERS[oolite]="1.90"
WEB_PKG_MESG[oolite]=""
WEB_PKG_EVAL[oolite]=""
WEB_PKG_FILE[oolite_amd64]="$RESSOURCE_SERVER_DIR/web/oolite-1.90.linux-x86_64.tgz"
WEB_PKG_CSUM[oolite_amd64]="$RESSOURCE_SERVER_DIR/web/oolite-1.90.linux-x86_64.tgz.sha"
 WEB_PKG_FILE[oolite_i386]="" # NUR für 64-bit (32-bit verfügbar aber nicht aufgenommen)
 WEB_PKG_CSUM[oolite_i386]="" # NUR für 64-bit (32-bit verfügbar aber nicht aufgenommen)
WEB_PKG_FILE[oolite_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[oolite_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_FILE[oolite_armhf]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[oolite_armhf]="" # NICHT für ARM verfügbar

# Download von https://www.openshot.org/de/download
WEB_PKG_NAME[openshot-qt]="OpenShot"
WEB_PKG_CATY[openshot-qt]="AudioVideo;Video"
WEB_PKG_OLDV[openshot-qt]="2.6.1"
WEB_PKG_OLDF[openshot-qt]="$RESSOURCE_SERVER_DIR/web/OpenShot-v2.6.1-x86_64.AppImage"
WEB_PKG_VERS[openshot-qt]="3.1.1"
WEB_PKG_MESG[openshot-qt]="Mindestens 4GB RAM erforderlich!"
WEB_PKG_EVAL[openshot-qt]="[ $MEMORY_TOTAL -gt 4000000000 ]"
WEB_PKG_FILE[openshot-qt_amd64]="$RESSOURCE_SERVER_DIR/web/OpenShot-v3.1.1-x86_64.AppImage"
WEB_PKG_CSUM[openshot-qt_amd64]="$RESSOURCE_SERVER_DIR/web/OpenShot-v3.1.1-x86_64.AppImage.sha"
 WEB_PKG_FILE[openshot-qt_i386]="" # Für Linux nur als 64-bit verfügbar
 WEB_PKG_CSUM[openshot-qt_i386]="" # Für Linux nur als 64-bit verfügbar
WEB_PKG_FILE[openshot-qt_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[openshot-qt_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_FILE[openshot-qt_armhf]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[openshot-qt_armhf]="" # NICHT für ARM verfügbar

# Download von https://www.torproject.org/de/download/
WEB_PKG_NAME[tor-browser]="Tor Browser"
WEB_PKG_CATY[tor-browser]="Network;WebBrowser"
WEB_PKG_OLDV[tor-browser]="12.0.5"
WEB_PKG_OLDF[tor-browser]="tor-browser-linux64-12.0.5_ALL.tar.xz"
WEB_PKG_VERS[tor-browser]="12.5.5"
WEB_PKG_MESG[tor-browser]=""
WEB_PKG_EVAL[tor-browser]=""
WEB_PKG_FILE[tor-browser_amd64]="$RESSOURCE_SERVER_DIR/web/tor-browser-linux64-12.5.5_ALL.tar.xz"
WEB_PKG_CSUM[tor-browser_amd64]="$RESSOURCE_SERVER_DIR/web/tor-browser-linux64-12.5.5_ALL.tar.xz.sha"
 WEB_PKG_FILE[tor-browser_i386]="" # Für Linux nur als 64-bit verfügbar
 WEB_PKG_CSUM[tor-browser_i386]="" # Für Linux nur als 64-bit verfügbar
WEB_PKG_FILE[tor-browser_arm64]="" # Auf ARM nur für Android verfügbar (Raspberry hat kein SSE2)
WEB_PKG_CSUM[tor-browser_arm64]="" # Auf ARM nur für Android verfügbar (Raspberry hat kein SSE2)
WEB_PKG_FILE[tor-browser_armhf]="" # Auf ARM nur für Android verfügbar (Raspberry hat kein SSE2)
WEB_PKG_CSUM[tor-browser_armhf]="" # Auf ARM nur für Android verfügbar (Raspberry hat kein SSE2)

# Download von https://codeberg.org/ralfhersel/youplay
WEB_PKG_NAME[youplay]="YouPlay"
WEB_PKG_CATY[youplay]="AudioVideo;Video"
WEB_PKG_OLDV[youplay]=""
WEB_PKG_OLDF[youplay]=""
WEB_PKG_VERS[youplay]="0.46"
WEB_PKG_MESG[youplay]="Benötigt mindestens gtk-4.0!"
WEB_PKG_EVAL[youplay]="[ -d /usr/share/gtk-4.0 ]"
WEB_PKG_FILE[youplay_amd64]="$RESSOURCE_SERVER_DIR/web/youplay_v0.46-GTK4-x86_64.AppImage"
WEB_PKG_CSUM[youplay_amd64]="$RESSOURCE_SERVER_DIR/web/youplay_v0.46-GTK4-x86_64.AppImage.sha"
 WEB_PKG_FILE[youplay_i386]="" # Für Linux nur als 64-bit verfügbar
 WEB_PKG_CSUM[youplay_i386]="" # Für Linux nur als 64-bit verfügbar
WEB_PKG_FILE[youplay_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[youplay_arm64]="" # NICHT für ARM verfügbar
WEB_PKG_FILE[youplay_armhf]="" # NICHT für ARM verfügbar
WEB_PKG_CSUM[youplay_armhf]="" # NICHT für ARM verfügbar

###############################################################################

###############################################################################
# Programme aus externen Quellen (DEB und WEB), welche keinen eigenen Eintrag
# im Repo haben und somit von apt auch nicht automatisch aktualisiert werden.
# Dient als Basis für die Updates dieser Programme mit der Option "exupdate".
###############################################################################
EXUPDATE_PKG_LIST=('balena-etcher' 'code-the-classics' 'codium' 'czkawka' 'freefilesync' 'hypnotix' 'ipscan' 'iptvnator' 'nomachine' 'openshot-qt' 'tor-browser' 'veracrypt' 'xnview' 'youplay')

###############################################################################
# Pakete, die warum auch immer vorzugsweise als Snap installiert werden sollen.
###############################################################################
FORCE_SNAPPY_LIST=('chromium')

###############################################################################
# Pakete, die warum auch immer aus externen Quellen installiert werden sollen.
###############################################################################
FORCE_EXTERN_LIST=(  )

###############################################################################
# Auf dem Raspberry Pi grundsätzlich mangels Hardware-Support, Performance
# oder anderen Gründen sinnlose und daher auszuschließende Pakete, obwohl
# diese eventuell sogar im Repository enthalten und installierbar sind.
###############################################################################
# Microsoft-Programme laufen nicht auf einer ARM-Architektur, es sein denn
# síe wurden dafür neu kompiliert - dann braucht man dafür aber kein Wine ;)
TMP_LIST="microsoft-edge-stable microsoft-edge-dev msr-tools"
TMP_LIST+=" ${KATEGORIE_PKGS[w]}"
NOT_ON_RASPBERRY=(${TMP_LIST})

###############################################################################
# Zusätzlich Pakete ausschließen, die auf Raspbian (Pi OS) nicht verfügbar sind
# jedoch in anderen Distribution auf dem Raspberry Pi verfügbar sein können.
###############################################################################
NOT_ON_RASPBIAN=('gnome-software' 'realvnc-vnc-server' 'usbview' 'ubuntu-mate-welcome')

###############################################################################
# Wenn zu Programmpaketen VOR deren Installation eine Konfiguration des Systems
# erforderlich ist, kann diese ebenfalls automatisiert durchgeführt werden.
# Dazu kann das entsprechende Kommando entweder direkt angegeben werden, oder
# eine URL zum Download eines auszuführenden Scripts (s.a. RESSOURCE_SERVER_DIR).
# Hinweis: Nach der Ausführung eines externen Scriptes wird das Hauptscript
# (außer im Quiet-Modus) mit einer Aufforderung zum Drücken der Enter-Taste
# pausiert, um Meldungen des externen Scriptes nicht zu überlesen.
# Nach Kommandos wird das Hauptscript nicht pausiert und sofort fortgeführt.
###############################################################################
declare -A PRE_INST_CONF

PRE_INST_CONF[anydesk]="$RESSOURCE_SERVER_DIR/scripts/anydesk_pre_inst"
PRE_INST_CONF[wine]="$RESSOURCE_SERVER_DIR/scripts/wine_pre_inst"

###############################################################################
# Wenn zu Programmpaketen NACH deren Installation eine weitere Konfiguration
# erforderlich ist, kann diese ebenfalls automatisiert durchgeführt werden.
# Dazu kann das entsprechende Kommando entweder direkt angegeben werden, oder
# eine URL zum Download eines auszuführenden Scripts (s.a. RESSOURCE_SERVER_DIR).
# Hinweis: Nach der Ausführung eines externen Scriptes wird das Hauptscript
# (außer im Quiet-Modus) mit einer Aufforderung zum Drücken der Enter-Taste
# pausiert, um Meldungen des externen Scriptes nicht zu überlesen.
# Nach Kommandos wird das Hauptscript nicht pausiert und sofort fortgeführt.
###############################################################################
declare -A POST_INST_CONF

POST_INST_CONF[anydesk]="$RESSOURCE_SERVER_DIR/scripts/anydesk_post_inst"
POST_INST_CONF[code-the-classics]="$RESSOURCE_SERVER_DIR/scripts/code-the-classics_post_inst"
POST_INST_CONF[czkawka]="$RESSOURCE_SERVER_DIR/scripts/czkawka_post_inst"
POST_INST_CONF[freefilesync]="$RESSOURCE_SERVER_DIR/scripts/freefilesync_post_inst"
POST_INST_CONF[freetuxtv]="$RESSOURCE_SERVER_DIR/scripts/freetuxtv_post_inst"
POST_INST_CONF[fs-uae]="$RESSOURCE_SERVER_DIR/scripts/fs-uae_post_inst"
POST_INST_CONF[fs-uae-launcher]="$RESSOURCE_SERVER_DIR/scripts/fs-uae-launcher_post_inst"
POST_INST_CONF[hypnotix]="$RESSOURCE_SERVER_DIR/scripts/hypnotix_post_inst"
POST_INST_CONF[iptvnator]="$RESSOURCE_SERVER_DIR/scripts/iptvnator_post_inst"
POST_INST_CONF[keepass2]="$RESSOURCE_SERVER_DIR/scripts/keepass2_post_inst"
POST_INST_CONF[libdvd-pkg]="dpkg-reconfigure libdvd-pkg"
POST_INST_CONF[makemkv-bin]="$RESSOURCE_SERVER_DIR/scripts/makemkv-bin_post_inst"
POST_INST_CONF[microsoft-edge-stable]="rm -f /etc/apt/sources.list.d/microsoft-edge-stable.list"
POST_INST_CONF[microsoft-edge-dev]="rm -f /etc/apt/sources.list.d/microsoft-edge-dev.list"
POST_INST_CONF[nextcloud-desktop]="$RESSOURCE_SERVER_DIR/scripts/nextcloud_post_inst"
POST_INST_CONF[oolite]="$RESSOURCE_SERVER_DIR/scripts/oolite_post_inst"
POST_INST_CONF[openssh-server]="echo -n Starte SSH-Dienste ... && service ssh restart &>/dev/null && systemctl enable ssh &>/dev/null && echo ok"
POST_INST_CONF[owncloud-client]="$RESSOURCE_SERVER_DIR/scripts/owncloud_post_inst"
POST_INST_CONF[php]="$RESSOURCE_SERVER_DIR/scripts/php_post_inst"
POST_INST_CONF[proftpd-basic]="$RESSOURCE_SERVER_DIR/scripts/proftpd_post_inst"
# Workaround für VNC-Server auf Linux Mint
if [ $(echo "$OPERATION_SYSTEM" | grep -i -c -E " mint ") -gt 0 ];
then
  POST_INST_CONF[realvnc-vnc-server]="apt install xterm -y"
fi
POST_INST_CONF[rocksndiamonds]="dpkg-reconfigure rocksndiamonds"
POST_INST_CONF[samba]="$RESSOURCE_SERVER_DIR/scripts/samba_post_inst"
POST_INST_CONF[teamviewer]="$RESSOURCE_SERVER_DIR/scripts/teamviewer_post_inst"
POST_INST_CONF[tor-browser]="$RESSOURCE_SERVER_DIR/scripts/tor-browser_post_inst"
POST_INST_CONF[usbauth-notifier]="$RESSOURCE_SERVER_DIR/scripts/usbauth-notifier_post_inst"
POST_INST_CONF[virtualbox]="usermod -a -G vboxusers $USER_USERNAME"
POST_INST_CONF[virtualbox-7.0]="$RESSOURCE_SERVER_DIR/scripts/virtualbox-7.0_post_inst"
POST_INST_CONF[wine]="$RESSOURCE_SERVER_DIR/scripts/wine_post_inst"
POST_INST_CONF[wireguard]="$RESSOURCE_SERVER_DIR/scripts/wireguard_post_inst"

###############################################################################
# Für Progamme, deren Starter / Desktop-Symbole nicht den gleichen Dateinamen
# haben wie das Programm selbst, oder für Programmpakete, zu denen mehrere
# Starter angelegt werden sollen, können deren Dateinamen in den folgenden
# Listen angegeben werden (gesucht werden diese in /usr/share/applications).
# ACHTUNG: Die Starter-Dateien (.desktop) werden dazu nur kopiert und nicht
# neu erzeugt, d.h. diese müssen dazu natürlich vorhanden sein.
###############################################################################
declare -A PKG_ICON_LIST
declare -A PKG_ICON_XDIR # Extra Verzeichnis, falls dieses angelegt werden soll

PKG_ICON_LIST[code-the-classics]="boing bunner cavern myriapod soccer"
PKG_ICON_XDIR[code-the-classics]="Code the Classics"
PKG_ICON_LIST[extremetuxracer]="etr"
PKG_ICON_XDIR[extremetuxracer]=""
PKG_ICON_LIST[freedoom]="io.github.freedoom.Phase1 io.github.freedoom.Phase2"
PKG_ICON_XDIR[freedoom]=""
PKG_ICON_LIST[gnome-games]="aisleriot sol org.gnome.Chess org.gnome.five-or-more org.gnome.Four-in-a-row org.gnome.Hitori org.gnome.Klotski org.gnome.LightsOff org.gnome.Mahjongg org.gnome.Mines org.gnome.Nibbles org.gnome.Quadrapassel org.gnome.Reversi org.gnome.Robots org.gnome.Sudoku org.gnome.SwellFoop org.gnome.Tali org.gnome.Taquin org.gnome.Tetravex org.gnome.TwentyFortyEight"
PKG_ICON_XDIR[gnome-games]="Gnome Games"
PKG_ICON_LIST[oolite]="oolite.org"
PKG_ICON_XDIR[oolite]=""
PKG_ICON_LIST[wine]="wine-browsedrive wine-control wine-explorer wine-iexplore wine-regedit wine-taskmgr wine-uninstaller wine-winecfg wine-wineconsole wine-winemine"
PKG_ICON_XDIR[wine]=""
PKG_ICON_LIST[wine-installer]="${PKG_ICON_LIST[wine]}"
PKG_ICON_XDIR[wine-installer]=""

###############################################################################
# Zusätzliche Desktop-Symbole zur Ergänzung des Ordners "Systemverwaltung".
# Icons, die nur dann erstellt werden, wenn das entsprechende Programmpaket
# bereits installiert ist, OHNE dieses Paket selbst neu zu installieren.
# Das betrifft bspw. Programme aus den Systemerweiterungen oder Tools (GUIs)
# für die Konfiguration von Kernel-Modulen sowie externen Treibern.
###############################################################################
ADD_SYS_ICONS=( 'caja-file-management-properties' 'ccsm' 'htop' 'nvidia-settings' 'nm-connection-editor' 'org.gnome.DiskUtility' 'software-properties-gtk' 'software-properties-qt' 'time-admin' 'update-manager' 'users-admin' 'xarchiver' 'xscreensaver-properties' 'xscreensaver-settings')

###############################################################################
# Raspbian Tools - Namen der Symbole (vollständige Dateinamen ohne Pfadangabe
# und Endung, NICHT Paketnamen!), welche auf Raspbian vorinstalliert sind und
# zusätzlich in einen separaten Ordner auf dem Desktop kopiert werden.
###############################################################################
RASPBIAN_EXT_ICONS=( 'agnostics' 'alacarte' 'arandr' 'Node-RED' 'obconf' 'pcmanfm' 'pcmanfm-desktop-pref' 'piclone' 'pi-gpk-prefs' 'pi-gpk-log' 'pi-gpk-update-viewer' 'pi-packages' 'pipanel' 'rc_gui' 'realvnc-vncviewer' 'rp-bookshelf' 'rp-prefapps' 'sense_emu_gui' 'smartsim' 'sonic-pi' 'wolfram-mathematica' 'wolfram-language' )

###############################################################################
# Beim Erstellen der Desktop-Symbole werden alle passenden .desktop-Dateien
# berücksichtigt, die keinen Eintrag "NoDisplay=true" haben, oder wenn doch
# zudem einen Eintrag "OnlyShowIn=<DESKTOP_NAME>" enthalten. Letzterer fehlt
# jedoch zuweilen - damit diese Icons trotzdem angelegt werden, können deren
# Paketnamen (NICHT Dateinamen!) in dem Array "FORCE_ICONS" angegeben werden.
###############################################################################
FORCE_ICONS=( 'caja' 'pi-gpk-prefs' 'pi-gpk-log' 'pi-gpk-update-viewer' )

###############################################################################
# Auszulassende Desktop-Icons (Teil des DATEInamens ohne Pfadangabe und Endung)
# welche ausgelassen und nicht mit auf den Desktop kopiert werden sollen.
###############################################################################
REJECT_ICONS=( 'alacarte-made' 'caja-autorun-software' 'caja-browser' 'caja-computer' 'caja-folder-handler' 'caja-home' 'clamtk-kde' 'mate-panel' 'mate-network-scheme' 'mate-theme-installer' 'mozo-made' 'NoMachine-base-' 'NoMachine-status-' 'org.gnome.Evolution-alarm-notify')

###############################################################################
# Desktop-Icons die bspw. aufgrund ihres Dateinamens unvermeidbar zusätzlich
# falsch angelegt werden und am Ende des Scriptes gelöscht werden sollen.
###############################################################################
WRONG_ICONS=('Internet/chromium-bsu.desktop')

###############################################################################
# Zu manchen Programmpaketen werden keine Desktop-Symbolbilder installiert oder
# nicht an einem Ort abgelegt, an welchem das System diese findet. Zu den in
# dem Array "LOAD_PIXMAP_ICONS" stehenden Paketnamen wird eine gleichnamige
# Bilddatei im Format .png heruntergeladen und in /usr/share/pixmaps abgelegt.
# HINWEIS: NICHT MEHR VERWENDET!
###############################################################################
# LOAD_PIXMAP_ICONS=('alien-arena' 'hydrogen' 'mandelbulber2')

###############################################################################
# Desktop-Ordner des Benutzers (zur Erstellung der Programmsymbole / Icons)
# Der Übersicht halber werden die Icons nicht alle direkt auf den Desktop
# kopiert, sondern in Ordnern mit den jeweiligen Kategorienamen abgelegt.
# ACHTUNG: Angaben OHNE Slash (/) am Ende!
###############################################################################
DESKTOP_DIR=""
if [ -d "/home/$USER_USERNAME/Schreibtisch" ];
then
  DESKTOP_DIR="/home/$USER_USERNAME/Schreibtisch"
else
  if [ -d "/home/$USER_USERNAME/Desktop" ];
  then
    DESKTOP_DIR="/home/$USER_USERNAME/Desktop"
  fi
fi

###############################################################################
# Parameter und Variablen initialisieren
###############################################################################
# -------
# Zähler
# -------
PAKETS_COUNTER=0       # Zähler der Pakete (Laufende Nummer)
PAKETS_EXIST=0         # Bereits installierte Pakete
PAKETS_AVAIL=0         # Neu installierte bzw. zur Installation verfügbare Pakete
PAKETS_NOAVAIL=0       # Nicht verfügbare Pakete
PAKETS_SIMILAR_EXIST=0 # Bereits installierte alternative Pakete
PAKETS_SIMILAR_AVAIL=0 # Neu installierte bzw. zur Installation verfügbare alternative Pakete
PAKETS_SIMILAR_NOAVA=0 # Nicht verfügbare alternative Pakete
PAKETS_SKIP=0          # Übersprungene Pakete (weil Raspi oder Nein nach Abfrage)

###############################################################################
# Funktion zur Ergänzung der Log-Datei durch die Ausgabe von Systemkommandos
###############################################################################
function add_full_log () {
  if [ ${OPTION_FLAG[logfull]} -eq 1 ] &&
     [ -s "$LOG_TEMP" ];
  then
    echo -e "Meldungen zur Aktion:" >> "$LOG_FILE"
    cat "$LOG_TEMP" >> "$LOG_FILE"
    echo -e "" >> "$LOG_FILE"
    remove_file "$LOG_TEMP"
  fi
}

###############################################################################
# Funktion zur Erstellung von Icons für Alternativen installierter Programme
###############################################################################
function add_similar_icons () {
  CHECK_SIM_PACK="${SIMILAR_PACK[$1]}"
  SHOW_INST_INFO=$2
  while [ "$CHECK_SIM_PACK" != "" ];
  do
    get_install_status "$CHECK_SIM_PACK"
    if [ $? -ne 0 ];
    then
      if [ $SHOW_INST_INFO -eq 1 ];
      then
        e_and_l -n "$PRE_SPACE ${bold_blue}Hinweis:${colors_off} Alternative ${light_green}$CHECK_SIM_PACK${colors_off}"
        if [ "$PKG_VERSION" != "" ] &&
           [ "$PKG_VERSION" != "0" ];
        then
          e_and_l -n " ${light_purple}$PKG_VERSION${colors_off}"
        fi
        e_and_l " ist installiert!"
        ((PAKETS_EXIST+=1))
        ((PAKETS_SIMILAR_EXIST+=1))
      fi
      copy_starter_to_desktop $CHECK_SIM_PACK
    fi
    CHECK_SIM_PACK="${SIMILAR_PACK[$CHECK_SIM_PACK]}"
  done
}

###############################################################################
# Funktion zur Abfrage aus welcher Quelle ein Paket installiert werden soll
# ACHTUNG: Rückgabewerte entsprechen dem Installations-Modus (INSTALL_MODE)!
###############################################################################
function ask_for_install_mode () {
  INST_MODES="$2"
  e_and_l " ${light_yellow}$1${colors_off} ist von mehreren Quellen verfügbar:"
  a=1
  while [ $a -lt 5 ];
  do
    if [ $(echo "$INST_MODES" | grep -c -E "$a") -gt 0 ];
    then
      e_and_l -n "$PRE_SPACE [${bold_yellow}$a${colors_off}]"
      TMP_PKG_VERSION=""
      case $a in
        1) TMP_PKG_VERSION=$(get_pkg_apt_version  "$1" 0) ;;
        2) TMP_PKG_VERSION=$(get_pkg_snap_version "$1" 0) ;;
        3) TMP_PKG_VERSION=$(get_pkg_deb_version  "$1")   ;;
        4) TMP_PKG_VERSION=$(get_pkg_web_version  "$1")   ;;
      esac
      if [ "$TMP_PKG_VERSION" != "" ];
      then
        TMP_PKG_VERSION=" Version ${light_yellow}$TMP_PKG_VERSION${colors_off}"
      fi
      case $a in
        1) e_and_l "$TMP_PKG_VERSION aus dem Repository"        ;;
        2) e_and_l "$TMP_PKG_VERSION als Snap"                  ;;
        3) e_and_l "$TMP_PKG_VERSION als externes Paket (.deb)" ;;
        4) e_and_l "$TMP_PKG_VERSION als ausführbare Datei(en)" ;;
      esac
    fi
    ((a+=1))
  done
  CHECK_SIM_PACK="${SIMILAR_PACK[$1]}"
  while [ "$CHECK_SIM_PACK" != "" ];
  do
    get_install_status "$CHECK_SIM_PACK"
    if [ $? -ne 0 ];
    then
      e_and_l -n "$PRE_SPACE $ACHTUNG_TAG: Alternative ${light_yellow}$CHECK_SIM_PACK${colors_off}"
      if [ "$PKG_VERSION" != "" ] &&
         [ "$PKG_VERSION" != "0" ];
      then
        e_and_l -n " ${light_purple}$PKG_VERSION${colors_off}"
      fi
      e_and_l " ist bereits installiert!"
    fi
    CHECK_SIM_PACK="${SIMILAR_PACK[$CHECK_SIM_PACK]}"
  done
  e_and_l "$PRE_SPACE Bitte auswählen, welche Version installiert werden soll,"
  e_and_l -n "$PRE_SPACE oder ${bold_yellow}0${colors_off} eingeben um die Installation zu überspringen: "
  NEW_INST_MODE=""
  while [ "$NEW_INST_MODE" = "" ] ||
        [ $(echo "$INST_MODES" | grep -c -E "$NEW_INST_MODE") -eq 0 ];
  do
    read -N 1 -r -s NEW_INST_MODE
    NEW_INST_MODE=$(echo $NEW_INST_MODE | sed 's/[^0-9]*//g')
  done
  e_and_l "$NEW_INST_MODE"
  if [ $NEW_INST_MODE -ne 0 ]; then e_and_l -n "$PRE_SPACE"; fi
  return "$NEW_INST_MODE"
}

###############################################################################
# Erweiterte Funktion zur Ja/Nein-Abfrage mit optionaler Anzeige einer Datei
# HINWEIS: Diese Abfrage wird auch mit der Option force NICHT übersprungen
# Rückgaben: 0 = false (Nein)
#            1 = true (Ja)
###############################################################################
function ask_yes_or_no () {
  QUESTION="$1? [${bold_yellow}j${colors_off}]a, [${bold_yellow}n${colors_off}]ein, [${bold_yellow}a${colors_off}]nzeigen: "
  FILE_TO_SHOW="$2"

  if [ "$FILE_TO_SHOW" != "" ];
  then
    REG_CHARS="[^JjNnAa]*"
    e_and_l -n "$QUESTION"
  else
    REG_CHARS="[^JjNn]*"
    e_and_l -n "$1? [${bold_yellow}j${colors_off}]a oder [${bold_yellow}n${colors_off}]ein: "
  fi
  IYN_RESULT=0
  INPUT_OK=0
  while [ $INPUT_OK -eq 0 ]
  do
    # Eingabe-Schleife --------------------------------------------------------
    ANSWER=""
    while [ "$ANSWER" = "" ];
    do
      read -N 1 -r -s ANSWER
      ANSWER=$(echo $ANSWER | sed "s/$REG_CHARS//g")
    done
    e_and_l "$ANSWER"
    # Ja ----------------------------------------------------------------------
    if [ "$ANSWER" = "J" ] ||
       [ "$ANSWER" = "j" ];
    then
      IYN_RESULT=1
      INPUT_OK=1
    fi
    # Nein --------------------------------------------------------------------
    if [ "$ANSWER" = "N" ] ||
       [ "$ANSWER" = "n" ];
    then
      INPUT_OK=1
    fi
    # Datei anzeigen ----------------------------------------------------------
    if [ "$FILE_TO_SHOW" != "" ];
    then
      if [ "$ANSWER" = "A" ] ||
         [ "$ANSWER" = "a" ];
      then
        echo -e "${light_yellow}"
        more "$FILE_TO_SHOW"
        echo -e "${colors_off}"
      fi
    fi
    # Wenn eine Datei angezeigt wurde erneut abfragen -------------------------
    if [ $INPUT_OK -eq 0 ];
    then
      if [ "$FILE_TO_SHOW" != "" ];
      then
        e_and_l -n "$QUESTION"
      fi
    fi
  done
  return $IYN_RESULT
}

###############################################################################
# Erweiterte Funktion zur Ja/Nein-Abfrage mit Info zu Programmpaketen (kann mit
# der Option force übersprungen werden, sofern nicht "trotzdem" angegeben ist!)
# Rückgaben: 0 = false (Nein)
#            1 = true (Ja)
###############################################################################
function ask_yes_no_info () {
  # ------------------------------------------------------
  # Hinweis auf bereits installierte Alternative anzeigen
  # ------------------------------------------------------
  TROTZDEM=""
  SIM_PACK_INSTALLED=0
  CHECK_SIM_PACK="${SIMILAR_PACK[$1]}"
  while [ "$CHECK_SIM_PACK" != "" ];
  do
    get_install_status "$CHECK_SIM_PACK"
    if [ $? -ne 0 ];
    then
      if [ $SIM_PACK_INSTALLED -gt 0 ]; then e_and_l -n "$PRE_SPACE"; fi
      e_and_l -n " $ACHTUNG_TAG: Alternative ${light_yellow}$CHECK_SIM_PACK${colors_off}"
      if [ "$PKG_VERSION" != "" ] &&
         [ "$PKG_VERSION" != "0" ];
      then
        e_and_l -n " ${light_purple}$PKG_VERSION${colors_off}"
      fi
      e_and_l " ist bereits installiert!"
      copy_starter_to_desktop $CHECK_SIM_PACK
      ((SIM_PACK_INSTALLED+=1))
    fi
    CHECK_SIM_PACK="${SIMILAR_PACK[$CHECK_SIM_PACK]}"
  done
  if [ $SIM_PACK_INSTALLED -ne 0 ];
  then
    e_and_l -n "$PRE_SPACE"
    TROTZDEM=" trotzdem"
  fi
  # -------------------------------------------------------------------------
  # Wenn es so gewollt ist (Option force) und nicht bereits ein alternatives
  # Programmpaket installiert ist (welches eventuell in Konflikt steht), dann
  # automatisch ein "Ja" (Installation ohne weitere Rückfrage) zurückgeben
  # -------------------------------------------------------------------------
  if [ ${OPTION_FLAG[force]} -eq 1 ] &&
     [ "$TROTZDEM" = "" ];
  then
    IYN_RESULT=1
  else
    PACKAGE_NAME=$1
    IYN_RESULT=0
    QUESTION_1="Programmpaket ${light_yellow}$PACKAGE_NAME${colors_off}"
    case $INSTALL_MODE in
      1) TMP_PKG_TYPE="STD"
         TMP_PKG_VERSION=$(get_pkg_apt_version "$PACKAGE_NAME" 0)
         ;;
      2) TMP_PKG_TYPE="SNAP"
         TMP_PKG_VERSION=$(get_pkg_snap_version "$PACKAGE_NAME" 0)
         ;;
      3) TMP_PKG_TYPE="DEB"
         TMP_PKG_VERSION=$(get_pkg_deb_version "$PACKAGE_NAME")
         ;;
      4) TMP_PKG_TYPE="WEB"
         TMP_PKG_VERSION=$(get_pkg_web_version "$PACKAGE_NAME")
         ;;
    esac
    if [ "$TMP_PKG_VERSION" != "" ];
    then
      QUESTION_1+=" ${light_yellow}$TMP_PKG_VERSION${colors_off}"
    fi
    QUESTION_1+=" ($TMP_PKG_TYPE)"
    QUESTION_1+="$TROTZDEM installieren?"
    QUESTION_2="[${bold_yellow}j${colors_off}]a [${bold_yellow}n${colors_off}]ein"
    if [ $INSTALL_MODE -lt 3 ];
    then
      REG_CHARS="[^JjNnIi]*"
      QUESTION_2+=" [${bold_yellow}i${colors_off}]nfo"
    else
      REG_CHARS="[^JjNn]*"
    fi
    QUESTION_2+=":"
    e_and_l " $QUESTION_1"
    e_and_l -n "$PRE_SPACE $QUESTION_2 "
    INPUT_OK=0
    while [ $INPUT_OK -eq 0 ]
    do
      # Eingabe-Schleife ------------------------------------------------------
      ANSWER=""
      while [ "$ANSWER" = "" ];
      do
        read -N 1 -r -s ANSWER
        ANSWER=$(echo $ANSWER | sed "s/$REG_CHARS//g")
      done
      e_and_l "$ANSWER"
      # Info anzeigen ---------------------------------------------------------
      if [ "$ANSWER" = "I" ] ||
         [ "$ANSWER" = "i" ];
      then
        echo -e "${light_yellow}"
        if [ $INSTALL_MODE -eq 1 ]; then apt show "$PACKAGE_NAME"; fi
        if [ $INSTALL_MODE -eq 2 ]; then snap info "$PACKAGE_NAME"; fi
        if [ $INSTALL_MODE -gt 2 ]; then echo -e "$PRE_SPACE Zu diesem Paket sind leider keine Informationen verfügbar."; fi
        echo -e "${colors_off}"
        e_and_l "$PRE_SPACE $QUESTION_1"
        e_and_l -n "$PRE_SPACE $QUESTION_2 "
      # Ja oder Nein ----------------------------------------------------------
      else
        if [ "$ANSWER" != "N" ] &&
           [ "$ANSWER" != "n" ];
        then
          e_and_l -n "$PRE_SPACE"
          IYN_RESULT=1
        fi
        INPUT_OK=1
      fi
    done
  fi
  return $IYN_RESULT
}

###############################################################################
# Funktion zur Prüfung, ob ein Programmpaket auf Raspberry oder Raspbian
# übersprungen werden soll
# Rückgaben: 0 = false (nicht überspringen)
#            1 = true (überspringen)
###############################################################################
function check_skip_raspi () {
  SKIP_RASPI=0
  # -------------------------------------------------------
  # Auf dem Raspberry Pi wegzulassende Pakete überspringen
  # -------------------------------------------------------
  if [ $RASPBERRY -ne 0 ];
  then
    for not_on_pi in ${NOT_ON_RASPBERRY[@]};
    do
      if [ "$1" = "$not_on_pi" ];
      then
        SKIP_RASPI=1
        break
      fi
    done
  fi

  # -------------------------------------------------------
  # Auf Raspbian (Pi OS) wegzulassende Pakete überspringen
  # -------------------------------------------------------
  if [ $RASPBIAN -ne 0 ] && [ $SKIP_RASPI -eq 0 ];
  then
    for not_on_pi in ${NOT_ON_RASPBIAN[@]};
    do
      if [ "$1" = "$not_on_pi" ];
      then
        SKIP_RASPI=1
        break
      fi
    done
  fi

  return $SKIP_RASPI
}

###############################################################################
# Funktion zur Verifizierung der Existenz einer downloadbaren Datei im Internet
# Rückgaben: 0 = OK (URL existiert)
#            1 = Fehler (URL existiert nicht)
###############################################################################
function check_url_file () {
  wget --spider "$1" &>/dev/null
  return $?
}

###############################################################################
# Funktion zum Aufräumen bei Programmende
###############################################################################
function clean_on_exit () {
  remove_file "$LOG_TEMP"
  if [ "$DOWNLOAD_DIR" != "" ] &&
     [ "$DOWNLOAD_DIR" != "/" ] &&
     [ "$DOWNLOAD_DIR" != "/tmp" ] &&
     [ -d "$DOWNLOAD_DIR" ];
  then
    # Wenn gewünscht alle Dateien im Download-Verzeichnis löschen
    # (dabei eigene Log-Dateien auslassen)
    if [ ${OPTION_FLAG[cleantmp]} -eq 1 ];
    then
      find "$DOWNLOAD_DIR" -type f -not -name "${LOG_FILE##*/}" -delete
    fi
    # Alle verbliebenen Dateien dem Benutzer zu eigen machen
    chown -R "$USER_USERNAME:$USER_USERNAME" "$DOWNLOAD_DIR" &>/dev/null
    # Download-Verzeichnis ganz löschen wenn keine Dateien mehr darin sind
    if [ $(ls -A "$DOWNLOAD_DIR" | wc -w) -eq 0 ];
    then
      rmdir "$DOWNLOAD_DIR" &>/dev/null
    fi
  fi
  setterm -cursor on 2>/dev/null
}

###############################################################################
# Funktion zur Bereinigung des Repo nach nicht erfolgreicher Installation
# (Löschen der Datei mit den Quell-Angaben um System-Updates nicht zu stören)
###############################################################################
function clear_repo () {
  REPO_FILE="$1"
  # Durch uns angelegte Datei
  LOCAL_REPO_FILE="/etc/apt/sources.list.d/$REPO_FILE.list"
  remove_file "$LOCAL_REPO_FILE"
  # Soweit bekannt durch das Paket/PPA selbst angelegte Dateien
  LOCAL_REPO_FILE=${PPA_REPO_SRC["$REPO_FILE"]}
  if [ "$LOCAL_REPO_FILE" != "" ];
  then
    # ACHTUNG: NICHT mit remove_file und OHNE Anführungszeichen, da mit * gelöscht werden kann
    rm -f /etc/apt/sources.list.d/$LOCAL_REPO_FILE &>/dev/null
  fi
}

###############################################################################
# Funktion zum Kopieren einer Liste von Icons
###############################################################################
function copy_icon_list () {
  # Ergebnisliste in Array umwandeln
  IFS=$'\n' FILE_LIST_ARRAY=(${SEARCH_ICON_RESULT})
  IFS=' '
  # Wenn Dateien gefunden wurden, diese kopieren
  if [ ${#FILE_LIST_ARRAY[@]} -gt 0 ];
  then
    for desktop_icon in ${FILE_LIST_ARRAY[@]};
    do
      DESKTOP_ICON_NAME="${desktop_icon##*/}"
      DESKTOP_ICON_NAME="${DESKTOP_ICON_NAME/.desktop/}"
      REJECT_THIS=0
      # Grundsätzlich auszulassende Icons prüfen
      for reject_file in ${REJECT_ICONS[@]};
      do
        if [ "$reject_file" = "$DESKTOP_ICON_NAME" ];
        then
          REJECT_THIS=1
          break
        fi
      done
      # Individuell (in dieser Kategorie) auszulassende Icons prüfen
      if [ "$EXCLUDE_ICON_LIST" != "" ];
      then
        for reject_file in ${EXCLUDE_ICON_LIST[@]};
        do
          if [ "$reject_file" = "$DESKTOP_ICON_NAME" ];
          then
            REJECT_THIS=1
            break
          fi
        done
      fi
      # Auszulassende Dateien nicht kopieren
      if [ $REJECT_THIS -eq 0 ];
      then
        create_extra_icon "$DESKTOP_ICON_NAME"
      fi
    done
  fi
  e_and_l " Es wurden ${bold_green}$NEW_ICON_COUNTER${colors_off} neue Programmsymbole erstellt"
  e_and_l "$FULL_LINE"
  ((ALL_ICON_COUNTER+=NEW_ICON_COUNTER))
}

###############################################################################
# Erstellung einer Autostart-Datei
###############################################################################
function create_autostart_file () {
  if [ ! -d "$USER_CONFIG_DIR/autostart" ];
  then
    mkdir -p "$USER_CONFIG_DIR/autostart" &>/dev/null
    chown "$USER_USERNAME:$USER_USERNAME" "$USER_CONFIG_DIR/autostart" &>/dev/null
  fi
  echo -e "[Desktop Entry]" > "$1" 2>/dev/null
  echo -e "Type=Application" >> "$1" 2>/dev/null
  echo -e "Name=$2" >> "$1" 2>/dev/null
  echo -e "Comment=$3" >> "$1" 2>/dev/null
  echo -e "Exec=$4" >> "$1" 2>/dev/null
  echo -e "Icon=$5" >> "$1" 2>/dev/null
  echo -e "Terminal=false" >> "$1" 2>/dev/null
  echo -e "NoDisplay=false" >> "$1" 2>/dev/null
  echo -e "Hidden=false" >> "$1" 2>/dev/null
  echo -e "X-GNOME-Autostart-enabled=true" >> "$1" 2>/dev/null
  echo -e "X-MATE-Autostart-enabled=true" >> "$1" 2>/dev/null
  chown "$USER_USERNAME:$USER_USERNAME" "$1" &>/dev/null
  chmod 0644 "$1" &>/dev/null
  return $?
}

###############################################################################
# Funktion zur Erstellung eines Desktop-Icons (Kopie des Menü-Eintrags ;)
# Rückgaben: 0 = OK, Desktop-Symbol erstellt
#            1 = Fehler, Desktop-Symbol NICHT erstellt
###############################################################################
function copy_starter_to_desktop () {
  if [ "$DESKTOP_ENVIRONMENT" = "GNOME" ] ||
     [ ${OPTION_FLAG[addicons]} -ne 1 ];
  then
    return 1
  fi

  # echo -e "Starter for $1" # NUR ZUM TESTEN!

  CREATE_DESKTOP_RESULT=1

  if [ "$DESKTOP_DIR" != "" ];
  then

    # Kategorien mit Programmpaketen ohne Desktop-Symbole auslassen
    if [ "$CURRENT_CATEGORY" != "a" ] &&
       [ "$CURRENT_CATEGORY" != "f" ] &&
       [ "$CURRENT_CATEGORY" != "u" ] &&
       [ "$CURRENT_CATEGORY" != "x" ];
    then

      # Hauptordner "Neue Icons" erstellen
      DESKTOP_ICON_DIR="$DESKTOP_DIR/Neue Icons"
      if [ ! -d "$DESKTOP_ICON_DIR" ];
      then
        mkdir "$DESKTOP_ICON_DIR" &>/dev/null
        if [ $? -eq 0 ];
        then
          chown "$USER_USERNAME:$USER_USERNAME" "$DESKTOP_ICON_DIR" &>/dev/null
          chmod 0755 "$DESKTOP_ICON_DIR" &>/dev/null
        fi
      fi

      # Nur weitermachen wenn der Hauptordner existiert
      if [ -d "$DESKTOP_ICON_DIR" ];
      then

        # Unterordner für aktuelle Kategorie erstellen
        ICON_TARGET_DIR="$DESKTOP_ICON_DIR/${KAT_SHORT_NAME%% (*}"
        if [ ! -d "$ICON_TARGET_DIR" ];
        then
          mkdir "$ICON_TARGET_DIR" &>/dev/null
          if [ $? -eq 0 ];
          then
            chown "$USER_USERNAME:$USER_USERNAME" "$ICON_TARGET_DIR" &>/dev/null
            chmod 0755 "$ICON_TARGET_DIR" &>/dev/null
          else
            ICON_TARGET_DIR="$DESKTOP_ICON_DIR";
          fi
        fi

        # Nur weitermachen wenn der Ziel-Ordner existiert
        if [ -d "$ICON_TARGET_DIR" ];
        then

          # -----------------------------------------------------------
          # Suchen des zum Paket passenden Starter-(.desktop)-Eintrags
          # Ein leidiges Thema, umso mehr wenn Snap dazukommt ...
          # -----------------------------------------------------------
          # "Erweiterte" Paketnamen bereinigen auf Basisnamen
          SEARCH_NAME="$1"
          SEARCH_NAME="${SEARCH_NAME/-7.0/}"    # VirtualBox
          SEARCH_NAME="${SEARCH_NAME/-bin/}"
          SEARCH_NAME="${SEARCH_NAME/-client/}"
          SEARCH_NAME="${SEARCH_NAME/-common/}"
          if [ $(echo "$SEARCH_NAME" | grep -i -c "mate") -eq 0 ];
          then
            SEARCH_NAME="${SEARCH_NAME/-desktop/}"
          fi
          SEARCH_NAME="${SEARCH_NAME/-stable/}"
          # Bekannte Unterschiede zwischen Paket- und Dateinamen anpassen
          SEARCH_NAME="${SEARCH_NAME/realvnc-vnc-server/realvnc-vncserver-service}"
          SEARCH_NAME="${SEARCH_NAME/realvnc-vnc-viewer/realvnc-vncviewer}"

          SEARCH_RESULT_ALL=(  )

          # -------------------------------------------------------------------
          # Paketname = Dateiname ---------------------------------------------
          # -------------------------------------------------------------------
          # 1. Datei mit Paketnamen im Raspi-Ordner suchen
          if [ -d "/usr/share/raspi-ui-overrides/applications" ];
          then
            SEARCH_RESULT_TMP=$(find "/usr/share/raspi-ui-overrides/applications" -iname "$SEARCH_NAME".desktop -print 2>/dev/null)
            if [ "$SEARCH_RESULT_TMP" != "" ]; then SEARCH_RESULT_ALL+=$'\n'"$SEARCH_RESULT_TMP"; fi
          fi

          # 2. Datei mit Paketnamen im Benutzer-Ordner suchen
          SEARCH_RESULT_TMP=$(find "$USER_HOME_DIR/.local/share/applications/" -iname "$SEARCH_NAME".desktop -print 2>/dev/null)
          if [ "$SEARCH_RESULT_TMP" != "" ]; then SEARCH_RESULT_ALL+=$'\n'"$SEARCH_RESULT_TMP"; fi

          # 3. Datei mit Paketnamen im System-Ordner suchen
          SEARCH_RESULT_TMP=$(find /usr/share/applications/ -iname "$SEARCH_NAME".desktop -print 2>/dev/null)
          if [ "$SEARCH_RESULT_TMP" != "" ]; then SEARCH_RESULT_ALL+=$'\n'"$SEARCH_RESULT_TMP"; fi

          # 4. Datei mit Paketnamen im Snap-Ordner suchen
          if [ -d "/var/lib/snapd/desktop/applications" ];
          then
            SEARCH_RESULT_TMP=$(find /var/lib/snapd/desktop/applications -iname "$SEARCH_NAME".desktop -print 2>/dev/null)
            if [ "$SEARCH_RESULT_TMP" != "" ]; then SEARCH_RESULT_ALL+=$'\n'"$SEARCH_RESULT_TMP"; fi
          fi

          # -------------------------------------------------------------------
          # Paketname kommt in Datei vor --------------------------------------
          # -------------------------------------------------------------------
          # 5. Auftreten des Paketnamens an relevanten Stellen innerhalb der Dateien im Benutzer-Ordner suchen
          SEARCH_RESULT_TMP=$(grep -i -l -o -r -E "^(exec|name|icon|comment)\s*=\s*(/usr/bin/)*\b$SEARCH_NAME\b" "$USER_HOME_DIR"/.local/share/applications/* 2>/dev/null)
          if [ "$SEARCH_RESULT_TMP" != "" ]; then SEARCH_RESULT_ALL+=$'\n'"$SEARCH_RESULT_TMP"; fi

          # 6. Auftreten des Paketnamens an relevanten Stellen innerhalb der Dateien im System-Ordner suchen
          SEARCH_RESULT_TMP=$(grep -i -l -o -r -E "^(exec|name|icon|comment)\s*=\s*(/usr/bin/)*\b$SEARCH_NAME\b" /usr/share/applications/* 2>/dev/null)
          if [ "$SEARCH_RESULT_TMP" != "" ]; then SEARCH_RESULT_ALL+=$'\n'"$SEARCH_RESULT_TMP"; fi

          # 7. Auftreten des Paketnamens an spezifischen Stellen innerhalb der Dateien im System-Ordner suchen
          SEARCH_RESULT_TMP=$(grep -i -l -o -r -E "(X-Ubuntu-Gettext-Domain)=\b$SEARCH_NAME\b" /usr/share/applications/* 2>/dev/null)
          if [ "$SEARCH_RESULT_TMP" != "" ]; then SEARCH_RESULT_ALL+=$'\n'"$SEARCH_RESULT_TMP"; fi

          # 8. Auftreten des Paketnamens an relevanten Stellen innerhalb der Dateien im Snap-Ordner suchen
          if [ -d "/var/lib/snapd/desktop/applications" ];
          then
            SEARCH_RESULT_TMP=$(grep -i -l -o -r -E "^(exec|name|icon|comment)\s*=\s*(/usr/bin/)*\b$SEARCH_NAME\b" /var/lib/snapd/desktop/applications/* 2>/dev/null)
            if [ "$SEARCH_RESULT_TMP" != "" ]; then SEARCH_RESULT_ALL+=$'\n'"$SEARCH_RESULT_TMP"; fi
          fi

          # 9. Auftreten des Paketnamens an spezifischen Stellen innerhalb der Dateien im System-Ordner suchen
          SEARCH_RESULT_TMP=$(grep -i -l -o -r -E "(X-SnapInstanceName)=\b$SEARCH_NAME\b" /var/lib/snapd/desktop/applications/* 2>/dev/null)
          if [ "$SEARCH_RESULT_TMP" != "" ]; then SEARCH_RESULT_ALL+=$'\n'"$SEARCH_RESULT_TMP"; fi

          # -------------------------------------------------------------------
          # 10. Dateinamen aus vordefinierter Liste in PKG_ICON_LIST verwenden
          # -------------------------------------------------------------------
          tmp_list=${PKG_ICON_LIST[$SEARCH_NAME]};
          if [ "$tmp_list" != "" ]
          then
            for icon_file in ${tmp_list[@]};
            do
              full_icon_file_path="/usr/share/applications/$icon_file.desktop"
              if [ -s "$full_icon_file_path" ];
              then
                SEARCH_RESULT_TMP+=$full_icon_file_path
                SEARCH_RESULT_TMP+=$'\n'
              fi
            done
            # Wenn Icons aus vordefinierter Liste gefunden wurden,
            # dann auch Extra-Verzeichnis prüfen und ggf. anlegen
            if [ "$SEARCH_RESULT_TMP" != "" ];
            then
              if [ "${PKG_ICON_XDIR[$SEARCH_NAME]}" != "" ];
              then
                ICON_TARGET_DIR+="/${PKG_ICON_XDIR[$SEARCH_NAME]}"
                if [ ! -d "$ICON_TARGET_DIR" ];
                then
                  ORG_ICON_TARGET_DIR="$ICON_TARGET_DIR"
                  mkdir "$ICON_TARGET_DIR" &>/dev/null
                  if [ $? -eq 0 ];
                  then
                    chown "$USER_USERNAME:$USER_USERNAME" "$ICON_TARGET_DIR" &>/dev/null
                    chmod 0755 "$ICON_TARGET_DIR" &>/dev/null
                  else
                    ICON_TARGET_DIR="$ORG_ICON_TARGET_DIR"
                  fi
                fi
              fi
            fi
            SEARCH_RESULT_ALL+=$'\n'"$SEARCH_RESULT_TMP"
          fi

          # -------------------------------------------------------------------
          # Ende der Suche nach Starter(.desktop)-Dateien
          # -------------------------------------------------------------------

          # Ergebnisliste in Array umwandeln
          IFS=$'\n' ICON_LIST_ARRAY=(${SEARCH_RESULT_ALL})
          IFS=' '

          # Wenn Dateien gefunden wurden, diese kopieren
          if [ ${#ICON_LIST_ARRAY[@]} -gt 0 ];
          then
            LAST_BASE_NAME=""
            for desktop_file in ${ICON_LIST_ARRAY[@]};
            do
              # Nur .desktop-Dateien kopieren
              if [ "${desktop_file:(-8):8}" = ".desktop" ];
              then
                FILE_BASE_NAME="${desktop_file##*/}"
                if [ "$FILE_BASE_NAME" != "$LAST_BASE_NAME" ];
                then
                  LAST_BASE_NAME="$FILE_BASE_NAME"
                  # Nur nicht auszulassende Dateien kopieren
                  REJECT_THIS=0
                  for reject_file in ${REJECT_ICONS[@]};
                  do
                    # if [ "$reject_file.desktop" = "$FILE_BASE_NAME" ];
                    if [ $(echo -n "$FILE_BASE_NAME" | grep -i -c -E "$reject_file") -gt 0 ];
                    then
                      REJECT_THIS=1
                      break
                    fi
                  done
                  if [ $REJECT_THIS -eq 0 ];
                  then
                    # Nur nicht per Parameter in der Datei auszublendende Symbole anzeigen
                    SKIP_THIS_ICON=0
                    NO_DISPLAY_TXT="\s*NoDisplay\s*=\s*true"
                    NOTSHOWIN_TXT="\s*NotShowIn\s*=(.*)$DESKTOP_ENVIRONMENT\;"
                    if [ $(grep -i -c -E "$NO_DISPLAY_TXT" "$desktop_file") -gt 0 ] ||
                       [ $(grep -i -c -E "$NOTSHOWIN_TXT" "$desktop_file") -gt 0 ];
                    then
                      SKIP_THIS_ICON=1
                    fi
                    FORCE_THIS=0
                    for force_pkg_file in ${FORCE_ICONS[@]};
                    do
                      if [ "$force_pkg_file" = "$1" ];
                      then
                        FORCE_THIS=1
                        break
                      fi
                    done
                    ONLYSHOWIN_TXT="\s*OnlyShowIn\s*=(.*)$DESKTOP_ENVIRONMENT\;"
                    if [ $FORCE_THIS -eq 1 ] ||                                             # Bei force immer, ansonsten
                       [ $(echo -n "$desktop_file" | grep -i -c -E "overrides" ) -gt 0 ] || # auch wenn "Override" enthalten
                       [ $(grep -i -c -E "$ONLYSHOWIN_TXT" "$desktop_file") -gt 0 ];        # auch wenn "OnlyShowIn=DESKTOP" enthalten
                    then
                      SKIP_THIS_ICON=0
                    fi
                    if [ $SKIP_THIS_ICON -eq 0 ];
                    then
                      # Nur fehlende Dateien/Symbole kopieren
                      TARGET_FILE_NAME="$ICON_TARGET_DIR/$FILE_BASE_NAME"
                      if [ ! -s "$TARGET_FILE_NAME" ];
                      then
                        cp -f "$desktop_file" "$TARGET_FILE_NAME" &>/dev/null
                        if [ $? -eq 0 ];
                        then
                          do_log "$PRE_SPACE Icon für $SEARCH_NAME angelegt: $TARGET_FILE_NAME"
                          ((NEW_ICON_COUNTER+=1))
                          # Sicherheitshalber nochmals Zugriffsrechte setzen
                          chown "$USER_USERNAME:$USER_USERNAME" "$TARGET_FILE_NAME" &>/dev/null
                          chmod 0755 "$TARGET_FILE_NAME" &>/dev/null
                          CREATE_DESKTOP_RESULT=0
                        else
                          do_log "$PRE_SPACE $ERROR_TAG beim Kopieren des Programmsymbols für $SEARCH_NAME nach $TARGET_FILE_NAME"
                        fi
                      fi
                      # Die Datei als vertrauenswürdig markieren, um sie korrekt anzuzeigen
                      # und die Sicherheitsabfrage beim Anklicken zu vermeiden (Puh, dieses
                      # neue "Feature" von Ubuntu war ganz schön gut versteckt ... ;))
                      if [ -s "$TARGET_FILE_NAME" ];
                      then
                        sudo -u ${USER_USERNAME} DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/${USER_UID}/bus" gio set "$TARGET_FILE_NAME" "metadata::trusted" true &>/dev/null # < Ubuntu 21 (opt.: yes)
                        sudo -u ${USER_USERNAME} DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/${USER_UID}/bus" gio set "$TARGET_FILE_NAME" "metadata::caja-trusted-launcher" true &>/dev/null # Ubuntu 21
                      fi
                      # ALT: Nur fest definierte fehlende Bild-Dateien runterladen
                      # LOAD_THIS_ICON=0
                      # for load_pix_pkg in ${LOAD_PIXMAP_ICONS[@]};
                      # do
                      #   if [ "$load_pix_pkg" = "$1" ];
                      #   then
                      #     LOAD_THIS_ICON=1
                      #     break
                      #   fi
                      # done
                      # if [ $LOAD_THIS_ICON -eq 1 ];
                      # then
                      #   download_icon_file "$SEARCH_NAME"
                      # fi
                      # NEU: Immer nach fehlenden Bild-Dateien suchen und diese runterladen
                      download_icon_file "$(echo ${FILE_BASE_NAME} | sed 's/.desktop//g')"
                    fi
                  fi
                fi
              fi
            done
          fi
        fi
      fi
    fi
  fi
  return $CREATE_DESKTOP_RESULT
}

###############################################################################
# Sub-Funktion zur Erstellung von Tool-Icons auf dem Desktop
###############################################################################
function create_extra_icon () {
  copy_starter_to_desktop $1
  if [ $? -eq 0 ];
  then
    LFD_NR=$(show_nr $NEW_ICON_COUNTER)
    echo -e "$LFD_NR ${light_green}$1${colors_off}"
    # Zur besseren Sichtbarkeit eine kleine Pause einbauen ;)
    (sleep 0.05 &>/dev/null)
    echo -e -n "${clear_last_line}"
  fi
}

###############################################################################
# Bereinigt einen Text um seine Farbcodes und
###############################################################################
function clear_text () {
  NEW_TEXT="$1"
  # Zur Ausgabe in eine Textdatei alle Farbcodes entfernen
  NEW_TEXT=${NEW_TEXT//\\033\[0m/}
  NEW_TEXT=${NEW_TEXT//\\033\[[0-9][0-9]m/}
  NEW_TEXT=${NEW_TEXT//\\033\[[0-9]\;[0-9][0-9]m/}
  NEW_TEXT=${NEW_TEXT//[1m/}
  NEW_TEXT=${NEW_TEXT//(B[m/}
  NEW_TEXT=${NEW_TEXT//[0;90m/}
  NEW_TEXT=${NEW_TEXT//[0m/}
  # Nicht installierte Programme und Fehler hervorheben
  NEW_TEXT=${NEW_TEXT//error/ERROR}
  NEW_TEXT=${NEW_TEXT//Fehler/FEHLER}
  NEW_TEXT=${NEW_TEXT// nicht / NICHT }
  NEW_TEXT=${NEW_TEXT//Warnung/WARNUNG}
  echo -e -n "$NEW_TEXT"
}

###############################################################################
# Schreibt einen Text nur in die Log-Datei
###############################################################################
function do_log () {
  if [ ${OPTION_FLAG[log]} -eq 1 ];
  then
    if [ "$1" = "-n" ];
    then
      TEXT_TO_LOG="$2"
      NEWLINE=''
    else
      TEXT_TO_LOG="$1"
      NEWLINE=$'\n'
    fi
    LOG_TEXT=$(clear_text "$TEXT_TO_LOG")
    echo -e -n "$LOG_TEXT$NEWLINE" >> "$LOG_FILE"
  fi
}

###############################################################################
# Gibt einen Text aus und schreibt diesen in die Log-Datei
###############################################################################
function e_and_l () {
  if [ "$1" = "-n" ];
  then
    TEXT_TO_WRITE="$2"
    NEWLINE=''
  else
    TEXT_TO_WRITE="$1"
    NEWLINE=$'\n'
  fi
  echo -e -n "$TEXT_TO_WRITE$NEWLINE"
  if [ ${OPTION_FLAG[log]} -eq 1 ];
  then
    LOG_TEXT=$(clear_text "$TEXT_TO_WRITE")
    echo -e -n "$LOG_TEXT$NEWLINE" >> "$LOG_FILE"
  fi
}

###############################################################################
# Funktion zum Aufräumen nach der Beendigung des Auswahl-Menüs
###############################################################################
function exit_from_menu () {
  dialog --clear
  clear
  setterm -cursor on 2>/dev/null
  # Wenn es vorher keine Konfigurations-Datei gab,
  # dann die selbst erstellte auch wieder löschen
  if [ -f "$DIALOG_RC_FILE" ] &&
     [ $REMOVE_DIALOG_RC -eq 1 ];
  then
    remove_file "$DIALOG_RC_FILE"
  fi
  unset DIALOGRC
}

###############################################################################
# Funktion zur Erweiterung des Repository für ein externes Programmpaket "ERW"
# HINWEIS: Diese Funktion verwendet bereits die Verwaltung ohne apt-key ;o)
###############################################################################
function extend_repo_erw () {
  ERW_PAKET_NAME=$1
  e_and_l " ${light_yellow}$ERW_PAKET_NAME${colors_off} ist ein externes Programmpaket (ERW):"
  # ---------------------------------
  # Dateinamen und Befehle erstellen
  # ---------------------------------
  REPO_KEY_URL="${ERW_AUTH_KEY[$ERW_PAKET_NAME]}" # URL zum Download der Schlüssel-Datei
  LOCAL_KEY_FILE="/etc/apt/trusted.gpg.d/$ERW_PAKET_NAME" # Ziel-Datei mit Schlüssel für Quellangaben
  LOCAL_REPO_FILE="/etc/apt/sources.list.d/$ERW_PAKET_NAME.list" # Ziel-Datei für die Quellangaben
  REPO_SRC_TXT="${ERW_REPO_TXT[$ERW_PAKET_NAME]}" # Text zum Eintrag in die Datei mit den Quellangaben
  REPO_CMD="echo -e \"$REPO_SRC_TXT\" | tee \"$LOCAL_REPO_FILE\""
  # -----------------------------------------------------------------
  # Quell-Listen durch Anlegen des Authentifizierungs-Schlüssels und
  # einer entsprechenden Datei in /etc/apt/sources.list.d/ erweitern
  # -----------------------------------------------------------------
  # Authentifizierungs-Schlüssel erstellen
  do_log "$PRE_SPACE Authentifizierungs-Schlüssel: $REPO_KEY_URL"
  do_log "$PRE_SPACE Repository-Quelldatei-Eintrag: $REPO_SRC_TXT"
  e_and_l -n "$PRE_SPACE Erweitere die Paketquellen, bitte warten ... "
  # -----------------------------------------------
  # 1. Datei mit Schlüssel runterladen und anlegen
  # -----------------------------------------------
  LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$ERW_PAKET_NAME.ikey"
  wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$REPO_KEY_URL" &>"$LOG_TEMP"
  DOWNLOAD_RESULT=$?
  if [ $DOWNLOAD_RESULT -eq 0 ] &&
     [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
     [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
  then
    if [ $(echo "$REPO_KEY_URL" | grep -c -i -E "\.asc$") -gt 0 ] ||
       [[ $(cat "$LOCAL_DOWNLOAD_FILE" 2>/dev/null | grep -c -i -E "BEGIN PGP") -gt 0 &&
          $(cat "$LOCAL_DOWNLOAD_FILE" 2>/dev/null | grep -c -i -E "END PGP") -gt 0 ]];
    then
      LOCAL_KEY_FILE+=".asc"
    else
      LOCAL_KEY_FILE+=".gpg"
    fi
    create_backup_file "$LOCAL_KEY_FILE"
    cp -f "$LOCAL_DOWNLOAD_FILE" "$LOCAL_KEY_FILE" &>"$LOG_TEMP"
    if [ $? -eq 0 ];
    then
      chown -R "root:root" "$LOCAL_KEY_FILE" &>/dev/null
      chmod 0644 "$LOCAL_KEY_FILE" &>/dev/null
      remove_file "$LOCAL_DOWNLOAD_FILE"
      # ------------------------------------
      # 2. Datei mit Quellangaben erstellen
      # ------------------------------------
      # Wenn es die Quellen-Datei, aber noch kein Backup gibt, Backup erstellen
      create_backup_file "$LOCAL_REPO_FILE"
      # Quellen-Datei erstellen und Repository aktualisieren
      eval " $REPO_CMD" &>"$LOG_TEMP"
      if [ $? -eq 0 ] &&
         [ -s "$LOCAL_REPO_FILE" ];
      then
        e_and_l "$OK_TAG"
        repo_update "$PRE_SPACE Aktualisiere das Repository, bitte warten ... "
      else
        e_and_l ""
        e_and_l "$PRE_SPACE $ERROR_TAG beim Erstellen der Quellen-Datei!"
        add_full_log
      fi
    else
      e_and_l "$ERROR_TAG $LINENO"
      add_full_log
    fi
  else
    e_and_l ""
    e_and_l "$PRE_SPACE $ERROR_TAG beim Download des Authentifizierungs-Schlüssels!"
    add_full_log
    remove_file "$LOCAL_DOWNLOAD_FILE"
  fi
}

###############################################################################
# Funktion zur Erweiterung des Repository für ein externes Programmpaket "PPA"
###############################################################################
function extend_repo_ppa () {
  PPA_PAKET_NAME=$1
  e_and_l " ${light_yellow}$PPA_PAKET_NAME${colors_off} ist ein externes Programmpaket (PPA):"
  REPO_SRC_TXT="${PPA_REPO_TXT[$PPA_PAKET_NAME]}"
  do_log "$PRE_SPACE Repository-Eintrag: $REPO_SRC_TXT"
  e_and_l -n "$PRE_SPACE Erweitere die Paketquellen, bitte warten ... "
  add-apt-repository -y "$REPO_SRC_TXT" &>"$LOG_TEMP"
  if [ $? -eq 0 ];
  then
    e_and_l "$OK_TAG"
    repo_update "$PRE_SPACE Aktualisiere das Repository, bitte warten ... "
  else
    e_and_l ""
    e_and_l "$PRE_SPACE $ERROR_TAG beim Erweitern des Repository!"
    add_full_log
  fi
}

###############################################################################
# Funktion zur Prüfung ob ein Paket schon installiert ist
# Rückgaben: 0 = nicht installiert
#            1 = installiert mit der normalen Paketverwaltung (apt/dpkg)
#            2 = installiert als Snap-Paket
#            3 = Ordner mit ausführbaren Dateien in /opt gefunden
#            4 = Ordner mit ausführbaren Dateien in /home/USER/apps gefunden
#            5 = Ordner mit ausführbaren Dateien in /usr/share gefunden
# ACHTUNG: Der Rückgabewert entspricht NICHT dem INSTALL_MODE!
###############################################################################
function get_install_status () {
  PKG_INSTALL_STATUS=0
  PKG_VERSION=""
  # ---------------------------------------------------------------------
  # 1. Prüfen ob in der Standard dpkg-Datenbank als installiert vermerkt
  # ---------------------------------------------------------------------
  if [ $(LANG=en dpkg-query -W -f='${Status}' "$1" 2>/dev/null | grep -i -c -E "ok installed") -ne 0 ];
  then
    PKG_INSTALL_STATUS=1
    PKG_VERSION=$(get_pkg_apt_version "$1" 1)
  fi
  # ----------------------------------------
  # 2. Prüfen ob als Snap-Paket installiert
  # ----------------------------------------
  if [ $PKG_INSTALL_STATUS -eq 0 ] && [ $SNAP_INSTALLED -ne 0 ];
  then
    if [ $(LANG=en snap info "$1" 2>/dev/null | grep -i -c -E "installed\:") -ne 0 ];
    then
      PKG_INSTALL_STATUS=2
      PKG_VERSION=$(get_pkg_snap_version "$1" 1)
    fi
  fi
  # ------------------------------------------------------------------
  # 3. Prüfen ob es im System-Anwendungs-Ordner "/opt" einen
  # entsprechenden Programmordner mit ausführbaren Dateien gibt
  # ------------------------------------------------------------------
  if [ $PKG_INSTALL_STATUS -eq 0 ];
  then
    THE_PKG_TEST_NAME="${DEB_PKG_NAME[$1]}"
    if [ "$THE_PKG_TEST_NAME" = "" ];
    then
      THE_PKG_TEST_NAME="${WEB_PKG_NAME[$1]}"
      if [ "$THE_PKG_TEST_NAME" = "" ];
      then
        THE_PKG_TEST_NAME="$1"
      fi
    fi
    if [ "$THE_PKG_TEST_NAME" != "" ];
    then
      THE_PKG_INST_DIR="/opt/$THE_PKG_TEST_NAME"
      if [ -d "$THE_PKG_INST_DIR" ];
      then
        if [ $(find "$THE_PKG_INST_DIR" -maxdepth 1 -executable 2>/dev/null | wc -l) -gt 1 ];
        then
          PKG_INSTALL_STATUS=3
          PKG_VERS_FILE="$THE_PKG_INST_DIR/.$1"
          PKG_VERS_FILE+="_version"
          if [ -s "$PKG_VERS_FILE" ];
          then
            PKG_VERSION=$(cat "$PKG_VERS_FILE" | xargs)
          else
            PKG_VERSION=""
          fi
        fi
      fi
    fi
  fi
  # ------------------------------------------------------------------
  # 4. Prüfen ob es im eigenen Anwendungs-Ordner (siehe WEB_PKG_DIR)
  # einen entsprechenden Programmordner mit ausführbaren Dateien gibt
  # ------------------------------------------------------------------
  if [ $PKG_INSTALL_STATUS -eq 0 ];
  then
    if [ "${WEB_PKG_NAME[$1]}" != "" ];
    then
      THE_PKG_INST_DIR="$WEB_PKG_DIR/${WEB_PKG_NAME[$1]}"
      if [ -d "$THE_PKG_INST_DIR" ];
      then
        if [ $(find "$THE_PKG_INST_DIR" -maxdepth 1 -executable 2>/dev/null | wc -l) -gt 1 ];
        then
          PKG_INSTALL_STATUS=4
          PKG_VERS_FILE="$THE_PKG_INST_DIR/.$1"
          PKG_VERS_FILE+="_version"
          if [ -s "$PKG_VERS_FILE" ]; then PKG_VERSION=$(cat "$PKG_VERS_FILE" | xargs); fi
        fi
      fi
    fi
  fi
  # ------------------------------------------------------------------
  # 5. Prüfen ob es im System-Anwendungs-Ordner "/usr/share" einen
  # entsprechenden Programmordner mit ausführbaren Dateien gibt
  # (nur für externe DEB/WEB-Pakete, da es für einige Pakete aus dem Repo
  # bereits vorkonfigurierte Ordner sogar mit ausführbaren Dateien gibt!)
  # ------------------------------------------------------------------
  if [ $PKG_INSTALL_STATUS -eq 0 ];
  then
    if [ "${DEB_PKG_NAME[$1]}" != "" ] ||
       [ "${WEB_PKG_NAME[$1]}" != "" ];
    then
      THE_PKG_INST_DIR="/usr/share/$1"
      if [ -d "$THE_PKG_INST_DIR" ];
      then
        if [ $(find "$THE_PKG_INST_DIR" -maxdepth 1 -executable 2>/dev/null | wc -l) -gt 1 ];
        then
          PKG_INSTALL_STATUS=5
          PKG_VERS_FILE="$THE_PKG_INST_DIR/.$1"
          PKG_VERS_FILE+="_version"
          if [ -s "$PKG_VERS_FILE" ];
          then
            PKG_VERSION=$(cat "$PKG_VERS_FILE" | xargs)
          else
            PKG_VERSION=""
          fi
        fi
      fi
    fi
  fi
  # -----------------------------------------------------------------
  return $PKG_INSTALL_STATUS
}

###############################################################################
# Funktion zur Ermittlung der internen Paketart (Zuordnung gemäß o.s. Listen)
# mit Prüfung, ob dazu (unabhängig von deren Gültigkeit) vollständige Angaben
# zu deren Installation vorhanden sind. Hier wird nicht geprüft, ob die Pakete
# auch tatsächlich zur Installation oder zum Download verfügbar stehen.
# Rückgaben: "STD"  = in keiner alternativen Quell-Liste => Standard-Repository
#            "ERW"  = installierbar durch Erweiterung des Repository
#            "PPA"  = installierbar durch Erweiterung des Repository
#            "DEB"  = installierbar mit downloadbarer .deb-Datei
#            "WEB"  = ausführbare Datei zum Download, Entpacken und Kopieren
#            "NONE" = unvollständige Angaben in den alternativen Quell-Listen
###############################################################################
function get_package_type () {
  if [ "$PACKAGE_TYPE" = "" ]; then PACKAGE_TYPE="STD"; fi
  # ------------------------------------------------------------------
  # 1. Paket-Typ ERW
  # ------------------------------------------------------------------
  if [ "$PACKAGE_TYPE" = "STD" ];
  then
    if [ "${ERW_AUTH_KEY[$1]}" != "" ] ||
       [ "${ERW_REPO_TXT[$1]}" != "" ];
    then
      if [ "${ERW_AUTH_KEY[$1]}" != "" ] &&
         [ "${ERW_REPO_TXT[$1]}" != "" ];
      then
        PACKAGE_TYPE="ERW"
      else
        PACKAGE_TYPE="NONE"
      fi
    fi
  fi
  # --------------------------------------------------------------
  # 2. Paket-Typ PPA
  # --------------------------------------------------------------
  if [ "$PACKAGE_TYPE" = "STD" ] ||
     [ "$PACKAGE_TYPE" = "NONE" ];
  then
    if [ "${PPA_REPO_TXT[$1]}" != "" ];
    then
      PACKAGE_TYPE="PPA"
    fi
  fi
  # --------------------------------------------------------------
  # 3. Paket-Typ DEB
  # --------------------------------------------------------------
  if [ "$PACKAGE_TYPE" = "STD" ] ||
     [ "$PACKAGE_TYPE" = "NONE" ];
  then
    FOUND_PKG=0
    for arch_name in ${ARCH_NAME_LIST[@]};
    do
      IDX_NAME="$1"
      IDX_NAME+="_"
      IDX_NAME+="$arch_name"
      if [ "${DEB_PKG_FILE[$IDX_NAME]}" != "" ];
      then
        FOUND_PKG=1
        break
      fi
    done
    if [ $FOUND_PKG -eq 1 ];
    then
      PACKAGE_TYPE="DEB"
    fi
  fi
  # -----------------------------------------------------
  # 4. Paket-Typ WEB
  # -----------------------------------------------------
  if [ "$PACKAGE_TYPE" = "STD" ] ||
     [ "$PACKAGE_TYPE" = "NONE" ];
  then
    if [ "${WEB_PKG_NAME[$1]}" != "" ];
    then
      FOUND_PKG=0
      for arch_name in ${ARCH_NAME_LIST[@]};
      do
        IDX_NAME="$1"
        IDX_NAME+="_"
        IDX_NAME+="$arch_name"
        if [ "${WEB_PKG_FILE[$IDX_NAME]}" != "" ];
        then
          FOUND_PKG=1
          break
        fi
      done
      if [ $FOUND_PKG -eq 1 ];
      then
        PACKAGE_TYPE="WEB"
      else
        PACKAGE_TYPE="NONE"
      fi
    fi
  fi
}

###############################################################################
# Funktion zur Ermittlung einer Paket-Version aus dem Standard-Repository (APT)
###############################################################################
function get_pkg_apt_version () {
  INFO_TYPE=$2 # 0 = verfügbare Version, 1 = installierte Version ermitteln
  if [ $INFO_TYPE -eq 0 ];
  then
    PKG_APT_VERSION=$(LANG=en apt show "$1" 2>/dev/null | \
      grep -i -E "^\s*Version" | \
      sed -E "s/^\s*version\s*:\s*//i")
  else
    PKG_APT_VERSION=$(LANG=en dpkg-query -W -f='${Version}' "$1" 2>/dev/null)
  fi
  echo -e $(clean_pkg_version "$PKG_APT_VERSION")
}

###############################################################################
# Funktion zur Ermittlung einer Paket-Version eines externen Pakets (DEB)
###############################################################################
function get_pkg_deb_version () {
  THE_PKG_TEST_NAME="${DEB_PKG_NAME[$1]}"
  if [ "$THE_PKG_TEST_NAME" = "" ];
  then
    THE_PKG_TEST_NAME="${WEB_PKG_NAME[$1]}"
    if [ "$THE_PKG_TEST_NAME" = "" ];
    then
      THE_PKG_TEST_NAME="$1"
    fi
  fi
  PKG_VERS_FILE="/opt/$THE_PKG_TEST_NAME/.$1"
  PKG_VERS_FILE+="_version"
  if [ -s "$PKG_VERS_FILE" ];
  then
    PKG_VERSION=$(cat "$PKG_VERS_FILE" | xargs)
  else
    PKG_VERSION=${DEB_PKG_VERS["$1"]}
  fi
  echo -e $PKG_VERSION
}

###############################################################################
# Funktion zur Ermittlung einer Paket-Version als Snap (SNAP)
###############################################################################
function get_pkg_snap_version () {
  INFO_TYPE=$2 # 0 = verfügbare Version, 1 = installierte Version ermitteln
  PKG_SNAP_CHANNEL="" # Leer = Standard (stable)
  if [ $INFO_TYPE -eq 0 ];
  then
    FULL_PKG_SNAP_INFO=$(LANG=en snap info "$1" 2>/dev/null | sed -E "s/^\s*(latest)\s*\/\s*//g")
    # Zuerst auf stable-Version prüfen
    PKG_SNAP_VERSION=$(echo "$FULL_PKG_SNAP_INFO" | \
      grep -i -E "^\s*stable" | \
      sed -E "s/^\s*stable\s*\:*\s*//")
    # Wenn keine stable-Version gefunden, dann auf candidate prüfen
    if [ $(echo "$PKG_SNAP_VERSION" | grep -c -E "[0-9]") -eq 0 ];
    then
      PKG_SNAP_VERSION=$(echo "$FULL_PKG_SNAP_INFO" | \
        grep -i -E "^\s*candidate" | \
        sed -E "s/^\s*candidate\s*\:*\s*//")
      # Wenn keine candidate-Version gefunden, dann auf beta prüfen
      if [ $(echo "$PKG_SNAP_VERSION" | grep -c -E "[0-9]") -gt 0 ];
      then
        PKG_SNAP_CHANNEL="candidate"
      else
        PKG_SNAP_VERSION=$(echo "$FULL_PKG_SNAP_INFO" | \
          grep -i -E "^\s*beta" | \
          sed -E "s/^\s*beta\s*\:*\s*//")
        # Wenn keine beta-Version gefunden, dann auf edge prüfen
        if [ $(echo "$PKG_SNAP_VERSION" | grep -c -E "[0-9]") -gt 0 ];
        then
          PKG_SNAP_CHANNEL="beta"
        else
          PKG_SNAP_VERSION=$(echo "$FULL_PKG_SNAP_INFO" | \
            grep -i -E "^\s*edge" | \
            sed -E "s/^\s*edge\s*\:*\s*//")
          if [ $(echo "$PKG_SNAP_VERSION" | grep -c -E "[0-9]") -gt 0 ];
          then
            PKG_SNAP_CHANNEL="edge"
          fi
        fi
      fi
    fi
  else
    FULL_PKG_SNAP_INFO=$(LANG=en snap list "$1" 2>/dev/null | awk 'NR>1' | head -n 1)
    PKG_SNAP_VERSION=$(echo "$FULL_PKG_SNAP_INFO" | awk '{print $2}' | sed -E "s/\-//g" | xargs)
    # PKG_SNAP_REVISION=$(echo "$FULL_PKG_SNAP_INFO" | awk '{print $3}' | sed -E "s/\-//g" | xargs)
    PKG_SNAP_TRACKING=$(echo "$FULL_PKG_SNAP_INFO" | awk '{print $4}' | sed -E "s/\-//g" | xargs)
    if [ $(echo "$PKG_SNAP_TRACKING" | grep -i -c -E "candidate") -gt 0 ];
    then
      PKG_SNAP_CHANNEL="candidate"
    else
      if [ $(echo "$PKG_SNAP_TRACKING" | grep -i -c -E "beta") -gt 0 ];
      then
        PKG_SNAP_CHANNEL="beta"
      else
        if [ $(echo "$PKG_SNAP_TRACKING" | grep -i -c -E "edge") -gt 0 ];
        then
          PKG_SNAP_CHANNEL="edge"
        fi
      fi
    fi
    PKG_SNAP_NOTES=$(echo "$FULL_PKG_SNAP_INFO" | awk '{print $6}' | sed -E "s/\-//g" | xargs)
  fi
  # Versionsnummer bereinigen
  THE_SNAP_PKG_VERSION=$(clean_pkg_version "$PKG_SNAP_VERSION")
  # Ggf. Zusatzinfos anhängen
  if [ "$PKG_SNAP_CHANNEL" != "" ];
  then
    THE_SNAP_PKG_VERSION+=" "
    if [ $INFO_TYPE -eq 0 ];
    then
      THE_SNAP_PKG_VERSION+="${light_red}"
    else
      THE_SNAP_PKG_VERSION+="${light_purple}"
    fi
    THE_SNAP_PKG_VERSION+="$PKG_SNAP_CHANNEL${colors_off}"
  fi
  # Ggf. Hinweis auf Classic-Mode anhängen
  if [ $(echo "$PKG_SNAP_VERSION" | grep -i -c -E " classic") -gt 0 ] || # aus snap info
     [ $(echo "$PKG_SNAP_NOTES" | grep -i -c -E "classic") -gt 0 ];      # aus snap list
  then
    THE_SNAP_PKG_VERSION+=" ${light_red}classic${colors_off}"
  fi
  echo -e "$THE_SNAP_PKG_VERSION"
}

###############################################################################
# Funktion zur Ermittlung einer Paket-Version einer ausführbaren Datei (WEB)
###############################################################################
function get_pkg_web_version () {
  PKG_VERS_FILE="$WEB_PKG_DIR/${WEB_PKG_NAME[$1]}/.$1"
  PKG_VERS_FILE+="_version"
  if [ -s "$PKG_VERS_FILE" ];
  then
    PKG_VERSION=$(cat "$PKG_VERS_FILE" | xargs)
  else
    PKG_VERSION=${WEB_PKG_VERS["$1"]}
  fi
  echo -e $PKG_VERSION
}

###############################################################################
# Funktion zur Bereinigung einer Paketversion auf ihre ersten drei Teile
###############################################################################
function clean_pkg_version () {
  echo -e $(echo "$1" | \
  awk '{print $1}' | \
  sed -E "s/^(.*:)*(.*)/\2/" | \
  sed -E "s/[^0-9\.]/./g" | \
  sed -E "s/\.\.*/./g" | \
  sed -E "s/^\.//" | \
  sed -E "s/\.$//" | \
  sed -E "s/([0-9]*\.*[0-9]*\.*[0-9]*).*/\1/" | \
  xargs)
}

###############################################################################
# Funktion zur Ermittlung der maximalen Größe eines tmpfs
###############################################################################
function get_tmpfs_size () {
  MOUNT_POINT="$1"
  # Größe nur berechnen, wenn das tmpfs in der fstab enthalten und aktiviert ist
  if [ "$MOUNT_POINT" != "" ] &&
     [ $(cat "/etc/fstab" | grep -i -c -E "^\s*tmpfs\s*${MOUNT_POINT}\s") -gt 0 ];
  then
    # Wenn die Größe explizit angegeben ist, diese auslesen und umwandeln ...
    if [ $(cat "/etc/fstab" | grep -i -c -E "^\s*tmpfs\s*${MOUNT_POINT}\s.*size\s*=") -gt 0 ];
    then
      THE_RAMDISK_SIZE=$(cat "/etc/fstab" | grep -i -E "^\s*tmpfs\s*${MOUNT_POINT}" | sed 's/.*size\s*=\s*//g' | cut -d" " -f 1 | cut -d"," -f 1 | xargs)
      THE_RAMSIZE_UNIT=$(echo $THE_RAMDISK_SIZE | sed 's/[0-9]*//g')
      THE_RAMDISK_SIZE=$(echo $THE_RAMDISK_SIZE | sed 's/[^0-9]*//g')
      case $THE_RAMSIZE_UNIT in
        "%") THE_RAMDISK_SIZE=$((MEMORY_TOTAL / 1024 / 1024 * THE_RAMDISK_SIZE / 100)) ;;
        "M") THE_RAMDISK_SIZE=$((THE_RAMDISK_SIZE)) ;;
        "G") THE_RAMDISK_SIZE=$((THE_RAMDISK_SIZE * 1024)) ;;
        "T") THE_RAMDISK_SIZE=$((THE_RAMDISK_SIZE * 1024 * 1024)) ;;
      esac
    else # ... sonst 50% des Hauptspeichers (Linux-Standard)
      THE_RAMDISK_SIZE=$((MEMORY_TOTAL / 1024 / 1024 / 2))
    fi
  else
    THE_RAMDISK_SIZE=0
  fi
  echo -e "$THE_RAMDISK_SIZE"
}

###############################################################################
# Funktion zur Ermittlung der Anzahl Benutzer und Existenz von Superusern
###############################################################################
function get_user_list () {
  IFS=$'\n' HOME_DIR_LIST=($(find /home * -mindepth 1 -maxdepth 1 -type d -print 2>/dev/null | sort))
  IFS=' '
  ANZAHL_USER=${#HOME_DIR_LIST[@]}
  SUDOER_EXIST=0
  if [ $ANZAHL_USER -gt 0 ];
  then
    for userdir in ${HOME_DIR_LIST[@]};
    do
      TEST_USER_NAME=${userdir/\/home\//}
      if [ "$TEST_USER_NAME" != "$USER_USERNAME" ] &&
         [ $(id $TEST_USER_NAME 2>/dev/null | grep -i -c -E "\(sudo\)") -gt 0 ];
      then
        ((SUDOER_EXIST+=1))
        break
      fi
    done
  fi
  # ---------------------------------------------------------------------------
  # Da der Aufruf dieser Funktion nur als Benutzer "root" oder "pi" erfolgt,
  # anbieten das Script abzubrechen, wenn es auch noch andere Sudoer gibt
  # ---------------------------------------------------------------------------
  if [ $SUDOER_EXIST -gt 0 ];
  then
    e_and_l " Es sind auch schon andere Benutzer als ${light_cyan}Superuser${colors_off} (Sudoer) eingerichtet,"
    e_and_l " so dass dieses Script auch von solchen Benutzern ausgeführt werden kann."
    ask_yes_or_no " Willst Du jetzt trotzdem als ${bold_yellow}$USER_USERNAME${colors_off} weitermachen"
    if [ $? -ne 1 ];
    then
      exit 0
    fi
  fi
}

###############################################################################
# Funktion zur Einfügung von Leerzeichen
###############################################################################
function insert_spaces () {
  i=1
  while [ $i -lt $1 ];
  do
    e_and_l -n " "
    ((i+=1))
  done
}

###############################################################################
# Haupt-Funktion zur Installation eines Programmpakets
###############################################################################
function install_pkg () {
  PAKET=$1
  INSTALL_TRY=$2
  IS_SIMILAR_PKG=$3
  IS_UPDATE=$4

  # echo -e "| $PAKET | $INSTALL_TRY | $IS_SIMILAR_PKG | $IS_UPDATE |" # NUR ZUM TESTEN

  # ------------------------------------------------------------------
  # Beim ersten Versuch ein Trennzeichen und laufende Nummer anzeigen
  # ------------------------------------------------------------------
  LFD_NR=""
  if [ $INSTALL_TRY = 0 ];
  then
    if [ $IS_UPDATE -eq 1 ];
    then
      e_and_l -n "$PRE_SPACE"
    else
      e_and_l "$HALF_LINE"
      LFD_NR=$(show_nr $PAKETS_COUNTER)
      e_and_l -n "$LFD_NR"
    fi
  fi

  # -------------------------------------------------------------
  # Nur weitermachen, wenn das Paket nicht schon installiert ist
  # -------------------------------------------------------------
  get_install_status $PAKET
  INST_RES=$?
  if [ $INST_RES -eq 0 ];
  then

    # ------------------------------------------------------------------
    # Nach der zweiten Iteration abbrechen um Endlosschleife abzufangen
    # => zugunsten mehrstufiger Alternativen-Suche erstmal weggelassen
    # ------------------------------------------------------------------
    # if [ $INSTALL_TRY -gt 1 ];
    # then
    #   ((PAKETS_NOAVAIL+=1))
    #   ((PAKETS_COUNTER+=1))
    #   e_and_l "$PRE_SPACE $ERROR_TAG: Das Programmpaket ${light_red}$PAKET${colors_off} konnte nicht gefunden werden."
    #   return 0
    # fi

    SKIP_THIS=0
    SKIP_REASON=""
    # -----------------------------------------------------------
    # Per Parameter angegebene wegzulassende Pakete überspringen
    # -----------------------------------------------------------
    if [ ${#SKIP_LIST[@]} -ne 0 ];
    then
      for skip_this_pkg in ${SKIP_LIST[@]};
      do
        if [ "$PAKET" = "$skip_this_pkg" ];
        then
          SKIP_THIS=1
          SKIP_REASON=" (mit skip ausgeschlossen)"
          break
        fi
      done
    fi

    # ------------------------------------------------------------
    # Nicht verfügbare Pakete auf Raspberry/Raspbian überspringen
    # ------------------------------------------------------------
    if [ $SKIP_THIS -eq 0 ];
    then
      check_skip_raspi $PAKET
      SKIP_THIS=$?
      SKIP_REASON=" (in Ausschlussliste)"
    fi

    # -----------------------------------------------------------------
    # Paket überspringen, wenn dessen Basispaket nicht installiert ist
    # -----------------------------------------------------------------
    # ALT (mit DEPENDS_PACK)
    # -----------------------
    # DEPENDS_ON_PACK="${DEPENDS_PACK[$PAKET]}"
    # if [ "$DEPENDS_ON_PACK" != "" ];
    # then
    #   ORG_PKG_VERSION="$PKG_VERSION"
    #   get_install_status "$DEPENDS_ON_PACK"
    #   if [ $? -eq 0 ];
    #   then
    #     SKIP_THIS=1
    #     SKIP_REASON=" (unerfüllte Abhängigkeit)"
    #   fi
    #   PKG_VERSION="$ORG_PKG_VERSION"
    # fi
    # ------------------------
    # NEU (mit AUTO_ADD_PKGS)
    # ------------------------
    BASE_PACK_FOUND=0
    for base_pack in ${!AUTO_ADD_PKGS[@]};
    do
      if [ $BASE_PACK_FOUND -eq 0 ];
      then
      BASE_PACK_ADD_LIST="${AUTO_ADD_PKGS[$base_pack]}"
      for add_pack in ${BASE_PACK_ADD_LIST};
      do
        if [ "$PAKET" == "$add_pack" ] &&
           [ "${AUTO_ADD_PPOS[$base_pack]}" != "true" ];
        then
          ORG_PKG_VERSION="$PKG_VERSION"
          get_install_status "$base_pack"
          if [ $? -eq 0 ];
          then
            SKIP_THIS=1
            # SKIP_REASON=" (unerfüllte Abhängigkeit)"
            SKIP_REASON=" (${light_cyan}$base_pack${colors_off} ist nicht installiert)"
          fi
          PKG_VERSION="$ORG_PKG_VERSION"
          BASE_PACK_FOUND=1
          break
        fi
      done
      fi
    done

    # ----------------------------------------------------------------
    # Nur weitermachen, wenn das Paket nicht übersprungen werden soll
    # ----------------------------------------------------------------
    if [ $SKIP_THIS -eq 0 ];
    then

      # ---------------------------------------------------------------
      # 1. Ermitteln, auf welche Art das Paket installiert werden kann
      # ---------------------------------------------------------------
      INST_MODE_LIST="0" # Liste der möglichen Installations-Modi
      INSTALL_MODE=0     # Tatsächlich ausgewählter Installations-Modus

      IDX_NAME="$PAKET"
      IDX_NAME+="_"
      IDX_NAME+="$ARCHITECTURE_MAIN"
      OTHER_ARCH_TEXT=""
      PKG_FOREIGN_ARCH=""

      # ----------------------------------------------------------
      # Prüfen ob das Paket in der Force-Snap-Liste enthalten ist,
      # also bevorzugt als Snap zu installieren ist
      # ----------------------------------------------------------
      FORCE_THIS_SNAPPY=0
      if [ ${OPTION_FLAG[nosnap]} -eq 0 ] &&
         [ $SNAP_INSTALLED -ne 0 ] &&
         [ ${#FORCE_SNAPPY_LIST[@]} -ne 0 ];
      then
        for snap_this_pkg in ${FORCE_SNAPPY_LIST[@]};
        do
          if [ "$PAKET" = "$snap_this_pkg" ];
          then
            FORCE_THIS_SNAPPY=1
            break
          fi
        done
      fi

      # ------------------------------------------------------------
      # Prüfen ob das Paket in der Force-Extern-Liste enthalten ist,
      # also bevorzugt aus einer externen Quelle zu installieren ist
      # ------------------------------------------------------------
      FORCE_THIS_EXTERN=0
      if [ ${#FORCE_EXTERN_LIST[@]} -ne 0 ];
      then
        for extern_this_pkg in ${FORCE_EXTERN_LIST[@]};
        do
          if [ "$PAKET" = "$extern_this_pkg" ];
          then
            FORCE_THIS_EXTERN=1
            break
          fi
        done
      fi

      # -------------------------------------------------------------
      # 1.1. Prüfen ob Paket im Standard-Repository (oder im zweiten
      #      Durchlauf mit erweitertem Repository) verfügbar ist,
      #      sofern nicht Snap- oder externe Pakete bevorzugt werden
      # -------------------------------------------------------------
      if [ $FORCE_THIS_SNAPPY -eq 0 ] &&
         [ $FORCE_THIS_EXTERN -eq 0 ];
      then
        if [ $(apt list "$PAKET" -a 2>/dev/null | grep -i -E "$PAKET" | grep -i -c -E "$ARCHITECTURE_ALL") -gt 0 ];
        then
          INST_MODE_LIST+=",1"
          INSTALL_MODE=1
        fi
      fi

      # -----------------------------------------------------------------------
      # 1.2. Prüfen ob das Programmpaket als Snap-Paket verfügbar ist (SNAP)
      #      (Bei Aufruf von install_pkg nach Erweiterung der Repos auslassen)
      # -----------------------------------------------------------------------
      if [ ${OPTION_FLAG[nosnap]} -eq 0 ] &&
         [ $SNAP_INSTALLED -ne 0 ] &&
         [ "$LAST_ERW_PACK" = "" ] &&
         [ "$LAST_PPA_PACK" = "" ];
      then
        snap info "$PAKET" &>/dev/null
        if [ $? -eq 0 ];
        then
          INST_MODE_LIST+=",2"
          INSTALL_MODE=2
        fi
      fi

      if [ $FORCE_THIS_SNAPPY -eq 0 ] &&
         [ $FORCE_THIS_EXTERN -eq 0 ];
      then
        # -----------------------------------------------------------------------
        # 1.3. Prüfen ob es für das Paket Eintragungen zur Erweiterung des Repo
        #      gibt, diese ggf. durchführen und install_pkg neu aufrufen (ERW),
        #      sofern nicht Snap- oder externe Pakete bevorzugt werden
        # -----------------------------------------------------------------------
        if [ ${OPTION_FLAG[norepo]} -eq 0 ] &&
           [ "$LAST_ERW_PACK" != "$PAKET" ];
        then
          LAST_ERW_PACK="$PAKET"
          if [ "${ERW_AUTH_KEY[$PAKET]}" != "" ] &&
             [ "${ERW_REPO_TXT[$PAKET]}" != "" ];
          then
            if [ $INSTALL_TRY -eq 0 ];
            then
              extend_repo_erw "$PAKET"
              e_and_l -n "$PRE_SPACE"
            fi
            ((INSTALL_TRY+=1))
            install_pkg $PAKET $INSTALL_TRY 0 0
            return 0
          fi
        fi
        # -----------------------------------------------------------------------
        # 1.4. Prüfen ob es für das Paket Eintragungen zur Erweiterung des Repo
        #      gibt, diese ggf. durchführen und install_pkg neu aufrufen (PPA)
        # -----------------------------------------------------------------------
        if [ ${OPTION_FLAG[norepo]} -eq 0 ] &&
           [ "$LAST_PPA_PACK" != "$PAKET" ];
        then
          LAST_PPA_PACK="$PAKET"
          if [ "${PPA_REPO_TXT[$PAKET]}" != "" ];
          then
            # if [ $INSTALL_TRY -eq 0 ];
            # then
            extend_repo_ppa "$PAKET"
            # fi
            e_and_l -n "$PRE_SPACE"
            ((INSTALL_TRY+=1))
            install_pkg $PAKET $INSTALL_TRY 0 0
            return 0
          fi
        fi
      fi

      # -----------------------------------------------------------------
      # 1.5. Prüfen ob das Paket in der .deb-Datei-Liste enthalten ist
      #      und diese Datei auch als Download zur Verfügung steht (DEB)
      # -----------------------------------------------------------------
      # Installations-Kandidaten für Haupt-Architekturen suchen
      PACKAGE_FILE_DEB_URL="${DEB_PKG_FILE[$IDX_NAME]}"
      PACKAGE_CSUM_DEB_URL="${DEB_PKG_CSUM[$IDX_NAME]}"
      if [ "$PACKAGE_FILE_DEB_URL" != "" ];
      then
        check_url_file "$PACKAGE_FILE_DEB_URL"
        if [ $? -eq 0 ];
        then
          INST_MODE_LIST+=",3"
          INSTALL_MODE=3
        fi
      fi
      # Wenn kein Installations-Kandidat für die Haupt-Architektur gefunden
      # wurde, dann Installations-Kandidaten für Fremd-Architekturen suchen
      if [ $INSTALL_MODE -ne 3 ];
      then
        for other_arch in ${ARCH_NAME_LIST[@]};
        do
          if [ "$other_arch" != "$ARCHITECTURE_MAIN" ];
          then
            OTHER_IDX_NAME="$PAKET"
            OTHER_IDX_NAME+="_"
            OTHER_IDX_NAME+="$other_arch"
            PACKAGE_FILE_DEB_URL="${DEB_PKG_FILE[$OTHER_IDX_NAME]}"
            PACKAGE_CSUM_DEB_URL="${DEB_PKG_CSUM[$OTHER_IDX_NAME]}"
            if [ "$PACKAGE_FILE_DEB_URL" != "" ];
            then
              if [ ${OPTION_FLAG[foreign]} -ne 0 ] &&
                 [ "$other_arch" = "$ARCHITECTURE_OTHER" ];
              then
                check_url_file "$PACKAGE_FILE_DEB_URL"
                if [ $? -eq 0 ];
                then
                  INST_MODE_LIST+=",3"
                  INSTALL_MODE=3
                  PKG_FOREIGN_ARCH="$other_arch"
                  OTHER_ARCH_TEXT=""
                  break
                fi
              else
                if [ ! "$OTHER_ARCH_TEXT" = "" ]; then OTHER_ARCH_TEXT+=", "; fi
                OTHER_ARCH_TEXT+="$other_arch"
              fi
            fi
          fi
        done
      fi

      # --------------------------------------------------------------
      # 1.6. Prüfen ob das Paket in der Liste der Downloads enthalten
      #      und als solcher auch verfügbar ist (WEB)
      # --------------------------------------------------------------
      # Installations-Kandidaten für Haupt-Architekturen suchen
      PACKAGE_FILE_WEB_URL="${WEB_PKG_FILE[$IDX_NAME]}"
      PACKAGE_CSUM_WEB_URL="${WEB_PKG_CSUM[$IDX_NAME]}"
      if [ "$PACKAGE_FILE_WEB_URL" != "" ];
      then
        check_url_file "$PACKAGE_FILE_WEB_URL"
        if [ $? -eq 0 ];
        then
          INST_MODE_LIST+=",4"
          INSTALL_MODE=4
          PACKAGE_INST_DIR="$WEB_PKG_DIR/${WEB_PKG_NAME[$PAKET]}"
        fi
      fi
      # Wenn kein Installations-Kandidat für die Haupt-Architektur gefunden
      # wurde, dann Installations-Kandidaten für Fremd-Architekturen suchen
      if [ $INSTALL_MODE -ne 4 ];
      then
        for other_arch in ${ARCH_NAME_LIST[@]};
        do
          if [ "$other_arch" != "$ARCHITECTURE_MAIN" ];
          then
            OTHER_IDX_NAME="$PAKET"
            OTHER_IDX_NAME+="_"
            OTHER_IDX_NAME+="$other_arch"
            PACKAGE_FILE_WEB_URL="${WEB_PKG_FILE[$OTHER_IDX_NAME]}"
            PACKAGE_CSUM_WEB_URL="${WEB_PKG_CSUM[$OTHER_IDX_NAME]}"
            if [ "$PACKAGE_FILE_WEB_URL" != "" ];
            then
              if [ ${OPTION_FLAG[foreign]} -ne 0 ] &&
                 [ "$other_arch" = "$ARCHITECTURE_OTHER" ];
              then
                check_url_file "$PACKAGE_FILE_WEB_URL"
                if [ $? -eq 0 ];
                then
                  INST_MODE_LIST+=",4"
                  INSTALL_MODE=4
                  PKG_FOREIGN_ARCH="$other_arch"
                  OTHER_ARCH_TEXT=""
                  PACKAGE_INST_DIR="$WEB_PKG_DIR/${WEB_PKG_NAME[$PAKET]}"
                  break
                fi
              else
                if [ ! "$OTHER_ARCH_TEXT" = "" ]; then OTHER_ARCH_TEXT+=", "; fi
                OTHER_ARCH_TEXT+="$other_arch"
              fi
            fi
          fi
        done
      fi

      # -------------------------------------------------------------
      # 1.7. Prüfen ob Paket im Standard-Repository vorhanden ist,
      #      sofern Snap- oder externe Pakete bevorzugt wurden,
      #      aber kein solches Paket gefunden wurde
      # -------------------------------------------------------------
      if [ $INSTALL_MODE -eq 0 ];
      then
        if [ $FORCE_THIS_SNAPPY -ne 0 ] ||
           [ $FORCE_THIS_EXTERN -ne 0 ];
        then
          if [ $(apt list "$PAKET" -a 2>/dev/null | grep -i -E "$PAKET" | grep -i -c -E "$ARCHITECTURE_ALL") -gt 0 ];
          then
            INST_MODE_LIST+=",1"
            INSTALL_MODE=1
          fi
        fi
      fi

      # -----------------------------------------------------------
      # 1.8. Wenn kein Installations-Kandidat gefunden wurde, dann
      #      eine neue Suche nach einem ähnlichen Paket starten,
      #      sofern dazu ein "SIMILAR_PACK" angegeben ist
      # -----------------------------------------------------------
      if [ $INSTALL_MODE -eq 0 ];
      then
        if [ "$OTHER_ARCH_TEXT" != "" ];
        then
          AVAIL_TEXT="nur verfügbar für ${bold_purple}$OTHER_ARCH_TEXT${colors_off}"
        else
          AVAIL_TEXT="$NA_TXT"
        fi
        e_and_l " ${light_red}$PAKET${colors_off} ist $AVAIL_TEXT"
        # Wenn es vor der erfolglosen Suche des Pakets eine Erweiterung
        # des Repository gegeben hat, diese wieder bereinigen
        if [ "$LAST_ERW_PACK" != "" ] &&
           [ "$OTHER_ARCH_TEXT" = "" ];
        then
          clear_repo "$PAKET"
        fi
        # Wenn angegeben mit Alternativ-Paket durchstarten
        if [ "${SIMILAR_PACK[$PAKET]}" != "" ];
        then
          ((PAKETS_NOAVAIL+=1))
          if [ $IS_SIMILAR_PKG -eq 1 ]; then ((PAKETS_SIMILAR_NOAVA+=1)) ; fi
          e_and_l -n "$PRE_SPACE Alternative"
          ((INSTALL_TRY+=1))
          install_pkg "${SIMILAR_PACK[$PAKET]}" $INSTALL_TRY 1 0
          return 0
        fi
      fi

      # ---------------------------------------------------------------------
      # 2. Wenn ein Installations-Kandidat gefunden wurde, dann Installation
      #    und ggf, weitere Aktionen wie Konfiguration etc. durchführen
      #    (der Übersicht halber wieder nacheinander und nicht mit elseifs ;)
      # ---------------------------------------------------------------------
      if [ $INSTALL_MODE -ne 0 ];
      then

        if [ ${OPTION_FLAG[status]} -eq 0 ];
        then

          # -------------------------------------------------------------------
          # Wenn das Paket in mehreren Quellen zur Verfügung steht, den
          # Benutzer vor der Installation eine Auswahl treffen lassen
          # -------------------------------------------------------------------
          CONTINUE_INSTALL=1
          if [ ${#INST_MODE_LIST} -gt 3 ]; # "0,n" z.B. "0,2,4"
          then
            ask_for_install_mode "$PAKET" "$INST_MODE_LIST"
            INSTALL_MODE=$?
            if [ $INSTALL_MODE -eq 0 ];
            then
              CONTINUE_INSTALL=0
            fi
          fi

          # -------------------------------------------------------------------
          # Ja/Nein-Abfrage (wird automatisch mit Ja beantwortet, wenn die
          # Option "force" gewählt wurde und es auch keinen Konflikt gibt)
          # Wird alles in "ask_yes_no_info" überprüft ;)
          # -------------------------------------------------------------------
          if [ $CONTINUE_INSTALL -eq 1 ];
          then
            ask_yes_no_info "$PAKET"
            CONTINUE_INSTALL=$?
          fi

          # -------------------------------------------------------------------
          # Wenn Hinweise oder Tests zu Voraussetzungen existieren,
          # diese vorher anzeigen bzw. durchführen
          # -------------------------------------------------------------------
          if [ $CONTINUE_INSTALL -eq 1 ];
          then
            if [ "${DEB_PKG_MESG["$PAKET"]}" != "" ] ||
               [ "${WEB_PKG_MESG["$PAKET"]}" != "" ];
            then
              if [ ${OPTION_FLAG[force]} -ne 0 ];
              then
                e_and_l " Installation von ${light_yellow}$PAKET${colors_off} ..."
                e_and_l -n "$PRE_SPACE"
              fi
              # Falls vorhanden Voraussetzungen anzeigen und evaluieren
              FILL_WORD="wirklich"
              SHOW_PKG_MSG=""
              TMP_PACK_MSG="${WEB_PKG_MESG[$PAKET]}"
              if [ "$TMP_PACK_MSG" = "" ]; then TMP_PACK_MSG="${DEB_PKG_MESG[$PAKET]}"; fi
              if [ "$TMP_PACK_MSG" != "" ];
              then
                SHOW_PKG_MSG="${bold_red}Achtung:${colors_off} ${light_yellow}$TMP_PACK_MSG${colors_off}"
              fi
              EVAL_TEST="${WEB_PKG_EVAL["$PAKET"]}"
              if [ "$EVAL_TEST" = "" ]; then EVAL_TEST="${DEB_PKG_EVAL["$PAKET"]}"; fi
              if [ "$EVAL_TEST" != "" ];
              then
                eval "$EVAL_TEST" &>/dev/null
                if [ $? -ne 0 ];
                then
                  e_and_l " $SHOW_PKG_MSG"
                  e_and_l " ${PRE_SPACE}Diese Voraussetzung scheint ${bold_red}nicht${colors_off} erfüllt zu sein!"
                  FILL_WORD="trotzdem"
                fi
              else
                e_and_l " $SHOW_PKG_MSG"
                e_and_l " ${PRE_SPACE}Bitte prüfe vor der Installation, ob diese Voraussetzung erfüllt ist."
              fi
              ask_yes_or_no " ${PRE_SPACE}Dieses Programmpaket jetzt $FILL_WORD installieren"
              CONTINUE_INSTALL=$?
              if [ $CONTINUE_INSTALL -eq 1 ]; then e_and_l -n "${PRE_SPACE}"; fi
            fi
          fi

          # -------------------------------------------------------------------
          # Die Installation kann beginnen ...
          # -------------------------------------------------------------------
          if [ $CONTINUE_INSTALL -eq 1 ];
          then

            # -----------------------------------------------------------------
            # VOR der Installation ggf. vorbereitende Konfiguration durchführen
            # -----------------------------------------------------------------
            PRE_CONF_RESULT=0
            if [ "${PRE_INST_CONF[$PAKET]}" != "" ];
            then
              e_and_l ""
              e_and_l -n " Führe vorbereitende ${light_yellow}Konfiguration${colors_off} für ${light_yellow}$PAKET${colors_off} durch ... "
              PRE_ACTION="${PRE_INST_CONF[$PAKET]}"
              if [ $(echo -n "$PRE_ACTION" | grep -i -c -E "^\s*http") -gt 0 ];
              then
                CONFIG_FILE_NAME="${PRE_ACTION##*/}"
                CONFIG_URL="$PRE_ACTION"
                LOCAL_CONFIG_FILE="$DOWNLOAD_DIR/$CONFIG_FILE_NAME"
                wget -nv -O "$LOCAL_CONFIG_FILE" "$CONFIG_URL" &>"$LOG_TEMP"
                if [ $? -eq 0 ] &&
                   [ -s "$LOCAL_CONFIG_FILE" ] &&
                   [ $(grep -i -c -E "Error\s*404" "$LOCAL_CONFIG_FILE") -eq 0 ];
                then
                  # Heruntergeladenes Konfigurations-Script ausführen mit dem Benutzernamen
                  # als erstem Parameter zur Verwendung im aufgerufenen Konfigurations-Script
                  chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_CONFIG_FILE" &>/dev/null
                  chmod a+x "$LOCAL_CONFIG_FILE" &>/dev/null
                  echo -e ""
                  ( "$LOCAL_CONFIG_FILE" ${USER_USERNAME} ${DOWNLOAD_DIR} ${RESSOURCE_SERVER_DIR} ${OS_V_CODENAME} 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; ) | tee "$LOG_TEMP"
                  if [ $(cat "$LAST_EXIT_CODE") -eq 0 ];
                  then
                    do_log "$OK_TAG"
                  else
                    do_log "$ERROR_TAG"
                    PRE_CONF_RESULT=1
                  fi
                  # Konfigurations-Script löschen
                  # remove_file "$LOCAL_CONFIG_FILE"
                else
                  e_and_l ""
                  e_and_l "$PRE_SPACE $ERROR_TAG: Das Konfigurations-Script konnte nicht geladen werden!"
                  # Durch wget eventuell angelegte unbrauchbare Datei löschen
                  remove_file "$LOCAL_CONFIG_FILE"
                  PRE_CONF_RESULT=1
                fi
                echo -e ""
                if [ ${OPTION_FLAG[quiet]} -eq 0 ]; then echo -e -n "$PRE_SPACE Bitte ${bold_white}Enter${colors_off} drücken zum Weitermachen ... "; read dummy; fi
              else
                echo -e ""
                { eval "$PRE_ACTION" 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
                if [ $(cat "$LAST_EXIT_CODE") -eq 0 ];
                then
                  do_log "$OK_TAG"
                else
                  do_log "$ERROR_TAG"
                  PRE_CONF_RESULT=1
                fi
              fi
              remove_file "$LAST_EXIT_CODE"
              do_log "Aktion: $PRE_ACTION"
              add_full_log
              echo -e ""
              if [ $PRE_CONF_RESULT -eq 0 ]; then e_and_l -n "$PRE_SPACE"; fi
            fi

            INSTALL_RESULT=1

            if [ $PRE_CONF_RESULT -eq 0 ]; # Ggf. nur weitermachen, wenn die vorbereitende Konfiguration erfolgreich war
            then

              e_and_l -n " Installiere ${light_yellow}$PAKET${colors_off} ... "
              if [ ${OPTION_FLAG[quiet]} -eq 0 ]; then echo -e ""; fi

              # -----------------------------------------------------------------
              # Installation mit apt
              # -----------------------------------------------------------------
              if [ $INSTALL_MODE -eq 1 ];
              then
                if [ ${OPTION_FLAG[quiet]} -eq 1 ];
                then
                  echo -n '\n\n\n' | apt install "$PAKET" -y &>"$LOG_TEMP"
                  INSTALL_RESULT=$?
                else
                  { apt install "$PAKET" -y 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
                  INSTALL_RESULT=$(cat "$LAST_EXIT_CODE")
                  remove_file "$LAST_EXIT_CODE"
                fi
                if [ ${OPTION_FLAG[quiet]} -eq 1 ];
                then
                  if [ $INSTALL_RESULT -eq 0 ];
                  then
                    e_and_l "$OK_TAG"
                  else
                    e_and_l "$ERROR_TAG"
                  fi
                else
                  if [ $INSTALL_RESULT -eq 0 ];
                  then
                    do_log "$OK_TAG"
                  else
                    do_log "$ERROR_TAG"
                  fi
                fi
                add_full_log
              fi

              # -----------------------------------------------------------------
              # Installation mit snap
              # -----------------------------------------------------------------
              if [ $INSTALL_MODE -eq 2 ];
              then
                # -----------------------------------------
                # Sicherheitsbafrage für "non-stable" Snaps
                SNAP_CHECK_1=1
                SNAP_VERSION_OPTION=""
                TMP_PKG_VERSION=$(get_pkg_snap_version "$PAKET" 0)
                if [ $(echo "$TMP_PKG_VERSION" | grep -i -c -E "candidate") -gt 0 ];
                then
                  SNAP_VERSION_OPTION="--candidate"
                fi
                if [ $(echo "$TMP_PKG_VERSION" | grep -i -c -E "beta") -gt 0 ];
                then
                  SNAP_VERSION_OPTION="--beta --devmode"
                fi
                if [ $(echo "$TMP_PKG_VERSION" | grep -i -c -E "edge") -gt 0 ];
                then
                  SNAP_VERSION_OPTION="--edge --devmode"
                fi
                if [ "$SNAP_VERSION_OPTION" != "" ];
                then
                  SHOW_VERSION_TEXT=${SNAP_VERSION_OPTION//--/}
                  SHOW_VERSION_TEXT=${SHOW_VERSION_TEXT/ devmode/}
                  SHOW_VERSION_TEXT=${SHOW_VERSION_TEXT/ jailmode/}
                  e_and_l "$PRE_SPACE $ACHTUNG_TAG: Die Version \"${light_red}$SHOW_VERSION_TEXT${colors_off}\" ist nicht für den produktiven Einsatz"
                  ask_yes_or_no "$PRE_SPACE gedacht und ohne Support. Trotzdem installieren"
                  SNAP_CHECK_1=$?
                fi
                # -----------------------------------------------------
                # Sicherheitsbafrage für "klassische" Snaps
                # Hinweis: Wenn das System keinen jailmode unterstützt,
                # wird die Installation danach ohne jailmode versucht!
                # (Snap ist ja soo inkonsistent ... :(
                SNAP_CHECK_2=1
                SNAP_CLASSIC_OPTION=""
                TMP_PKG_VERSION=$(get_pkg_snap_version "$PAKET" 0)              
                if [ $(echo "$TMP_PKG_VERSION" | grep -i -c -E "classic") -gt 0 ];
                then
                  SNAP_CLASSIC_OPTION="--classic --jailmode"
                  e_and_l "$PRE_SPACE $ACHTUNG_TAG: Diese klassische Version ist nicht durch die Sicherheitssandbox"
                  e_and_l "$PRE_SPACE von Snap geschützt und kann möglicherweise ohne manuelle Nacharbeit auch"
                  ask_yes_or_no "$PRE_SPACE nicht lauffähig sein. Trotzdem installieren"
                  SNAP_CHECK_2=$?
                  if [ $SNAP_CHECK_2 -eq 1 ];
                  then
                    e_and_l ""
                    e_and_l " OK, ich versuche erstmal die Installation in einer ${bold_yellow}Sandbox${colors_off} zu erzwingen ..."
                    e_and_l ""
                  fi
                fi
                # -----------------------------------------
                if [ $SNAP_CHECK_1 -eq 1 ] &&
                   [ $SNAP_CHECK_2 -eq 1 ];
                then
                  if [ ${OPTION_FLAG[quiet]} -eq 1 ];
                  then
                    echo -n '\n\n\n' | snap install ${SNAP_VERSION_OPTION} ${SNAP_CLASSIC_OPTION} "$PAKET" &>"$LOG_TEMP"
                    INSTALL_RESULT=$?
                    if [ $INSTALL_RESULT -ne 0 ] &&
                       [ "$SNAP_CLASSIC_OPTION" != "" ];
                    then
                      SNAP_CLASSIC_OPTION=${SNAP_CLASSIC_OPTION/--jailmode/}
                      echo -n '\n\n\n' | snap install ${SNAP_VERSION_OPTION} ${SNAP_CLASSIC_OPTION} "$PAKET" &>"$LOG_TEMP"
                      INSTALL_RESULT=$?
                    fi
                  else
                    { snap install ${SNAP_VERSION_OPTION} ${SNAP_CLASSIC_OPTION} "$PAKET" 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
                    INSTALL_RESULT=$(cat "$LAST_EXIT_CODE")
                    if [ $INSTALL_RESULT -ne 0 ] &&
                       [ "$SNAP_CLASSIC_OPTION" != "" ];
                    then
                      e_and_l ""
                      e_and_l " Schade, das hat wohl ${bold_red}nicht${colors_off} funktioniert, also Installation ${bold_yellow}ohne Sandbox${colors_off} ..."
                      e_and_l ""
                      SNAP_CLASSIC_OPTION=${SNAP_CLASSIC_OPTION/--jailmode/}
                      { snap install ${SNAP_VERSION_OPTION} ${SNAP_CLASSIC_OPTION} "$PAKET" 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
                      INSTALL_RESULT=$(cat "$LAST_EXIT_CODE")
                    fi
                    remove_file "$LAST_EXIT_CODE"
                  fi
                  if [ ${OPTION_FLAG[quiet]} -eq 1 ];
                  then
                    if [ $INSTALL_RESULT -eq 0 ];
                    then
                      e_and_l "$OK_TAG"
                    else
                      e_and_l "$ERROR_TAG"
                    fi
                  else
                    if [ $INSTALL_RESULT -eq 0 ];
                    then
                      do_log "$OK_TAG"
                    else
                      do_log "$ERROR_TAG"
                    fi
                  fi
                  add_full_log
                else
                  INSTALL_RESULT=1
                  e_and_l "$PRE_SPACE ${light_cyan}$PAKET${colors_off} wurde ${light_red}nicht${colors_off} installiert"
                  ((PAKETS_SKIP+=1))
                  ((PAKETS_NOAVAIL-=1))
                fi
              fi

              # -----------------------------------------------------------------
              # Download einer Datei zum Installieren oder Entpacken / Kopieren
              # -----------------------------------------------------------------
              if [ $INSTALL_MODE -eq 3 ] ||
                 [ $INSTALL_MODE -eq 4 ];
              then
                if [ $INSTALL_MODE -eq 3 ];
                then
                  PACKAGE_FILE_URL="$PACKAGE_FILE_DEB_URL"
                  PACKAGE_CSUM_URL="$PACKAGE_CSUM_DEB_URL"
                fi
                if [ $INSTALL_MODE -eq 4 ];
                then
                  PACKAGE_FILE_URL="$PACKAGE_FILE_WEB_URL"
                  PACKAGE_CSUM_URL="$PACKAGE_CSUM_WEB_URL"
                fi
                DOWNLOAD_FILE_NAME="${PACKAGE_FILE_URL##*/}"
                LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$DOWNLOAD_FILE_NAME"
                do_log ""
                e_and_l -n "$PRE_SPACE Download von ${light_yellow}$DOWNLOAD_FILE_NAME${colors_off}, bitte warten ... "
                wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$PACKAGE_FILE_URL" &>"$LOG_TEMP"
                DOWNLOAD_RESULT=$?
                if [ $DOWNLOAD_RESULT -eq 0 ] &&
                   [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
                   [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
                then
                  e_and_l "$OK_TAG"
                  chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
                  FAIL_TEXT="$PRE_SPACE Das Paket ${light_yellow}$PAKET${colors_off} wird daher zur Sicherheit ${light_red}nicht${colors_off} installiert!"
                  # Checksumme überprüfen falls vorhanden
                  if [ "$PACKAGE_CSUM_URL" != "" ];
                  then
                    e_and_l -n "$PRE_SPACE Verifiziere heruntergeladene Datei ... "
                    # Checksummen berechnen und formatieren
                    CHECKSUM256=$(shasum -a 256 "$LOCAL_DOWNLOAD_FILE" 2>/dev/null)
                    CHECKSUM256=${CHECKSUM256% *}
                    CHECKSUM512=$(shasum -a 512 "$LOCAL_DOWNLOAD_FILE" 2>/dev/null)
                    CHECKSUM512=${CHECKSUM512% *}
                    CHECKSUM_OK="no"
                    # Wenn es sich um eine URL handelt, dann Download der Checksummen-Datei ...
                    if [ $(echo -n "$PACKAGE_CSUM_URL" | grep -i -c -E "^\s*http") -gt 0 ];
                    then
                      CSUM_FILE_NAME="${PACKAGE_CSUM_URL##*/}"
                      LOCAL_CSUM_DATA="$DOWNLOAD_DIR/$CSUM_FILE_NAME"
                      wget -nv -O "$LOCAL_CSUM_DATA" "$PACKAGE_CSUM_URL" &>"$LOG_TEMP"
                      DOWNLOAD_RESULT=$?
                      if [ $DOWNLOAD_RESULT -eq 0 ] &&
                         [ -s "$LOCAL_CSUM_DATA" ] &&
                         [ $(grep -i -c -E "Error\s*404" "$LOCAL_CSUM_DATA") -eq 0 ];
                      then
                        chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_CSUM_DATA" &>/dev/null
                        # Checksummen vergleichen
                        if [ $(grep -i -c ${CHECKSUM256} "$LOCAL_CSUM_DATA") -gt 0 ] ||
                           [ $(grep -i -c ${CHECKSUM512} "$LOCAL_CSUM_DATA") -gt 0 ];
                        then
                          CHECKSUM_OK="yes"
                        fi
                      else
                        e_and_l "$ERROR_TAG"
                        e_and_l "$PRE_SPACE Die Prüfsummen-Datei konnte nicht heruntergeladen werden!"
                        e_and_l "$FAIL_TEXT"
                        # Durch wget eventuell angelegte unbrauchbare Datei löschen
                        remove_file "$LOCAL_CSUM_DATA"
                        add_full_log
                      fi
                    else # ... sonst ist der Eintrag selbst schon die Checksumme
                      # Checksummen vergleichen
                      if [ $(echo -n "$CHECKSUM256" | grep -i -c "$PACKAGE_CSUM_URL") -gt 0 ] ||
                         [ $(echo -n "$CHECKSUM512" | grep -i -c "$PACKAGE_CSUM_URL") -gt 0 ];
                      then
                        CHECKSUM_OK="yes"
                      fi
                    fi
                    if [ "$CHECKSUM_OK" = "yes" ];
                    then
                      e_and_l "$OK_TAG"
                    else
                      if [ $DOWNLOAD_RESULT -eq 0 ];
                      then
                        e_and_l "$ERROR_TAG: Keine gültige Prüfsumme gefunden!"
                        e_and_l "$FAIL_TEXT"
                      fi
                      INSTALL_RESULT=1
                      DOWNLOAD_RESULT=1 # NICHT Weitermachen
                    fi
                  else
                    e_and_l "$PRE_SPACE $WARN_TAG: Datei kann wegen fehlender Prüfsumme nicht verifiziert werden!"
                    ask_yes_or_no "$PRE_SPACE ${bold_yellow}$DOWNLOAD_FILE_NAME${colors_off} trotzdem installieren"
                    if [ $? -eq 1 ];
                    then
                      e_and_l "$PRE_SPACE $USER_CHOICE_YES"
                    else
                      e_and_l "$PRE_SPACE $USER_CHOICE_NO"
                      ((PAKETS_SKIP+=1))
                      ((PAKETS_NOAVAIL-=1))
                      if [ $IS_SIMILAR_PKG -eq 1 ]; then ((PAKETS_SIMILAR_NOAVA-=1)); fi
                      INSTALL_RESULT=1
                      DOWNLOAD_RESULT=1 # NICHT Weitermachen
                    fi
                  fi
                else
                  # Durch wget eventuell angelegte unbrauchbare Datei löschen
                  remove_file "$LOCAL_DOWNLOAD_FILE"
                  e_and_l "$ERROR_TAG"
                  e_and_l "$PRE_SPACE Die Datei konnte ${bold_red}nicht${colors_off} heruntergeladen werden!"
                  add_full_log
                  INSTALL_RESULT=1
                fi

              fi

              FOREIGN_WARNING="$PRE_SPACE $ACHTUNG_TAG: Dieses Programmpaket ist nicht für die Haupt-Architektur dieses"$'\n'
              FOREIGN_WARNING+="$PRE_SPACE Systems, sondern für die Fremd-Architektur ${bold_blue}$PKG_FOREIGN_ARCH${colors_off} gedacht. Das Programm"$'\n'
              FOREIGN_WARNING+="$PRE_SPACE ist daher eventuell nicht lauffähig und kann das System destabilisieren!"
              # -----------------------------------------------------------------
              # Installation eines .deb-Pakets
              # -----------------------------------------------------------------
              if [ $INSTALL_MODE -eq 3 ] &&
                 [ $DOWNLOAD_RESULT -eq 0 ];
              then
                if [ "$PKG_FOREIGN_ARCH" != "" ];
                then
                  e_and_l "$FOREIGN_WARNING"
                  ask_yes_or_no "$PRE_SPACE ${bold_yellow}$PAKET${colors_off} trotzdem installieren"
                  if [ $? -eq 1 ];
                  then
                    e_and_l "$PRE_SPACE $USER_CHOICE_YES"
                  else
                    e_and_l "$PRE_SPACE $USER_CHOICE_NO"
                    ((PAKETS_SKIP+=1))
                    ((PAKETS_NOAVAIL-=1))
                    if [ $IS_SIMILAR_PKG -eq 1 ]; then ((PAKETS_SIMILAR_NOAVA-=1)); fi
                    INSTALL_RESULT=1
                    DOWNLOAD_RESULT=1 # NICHT Weitermachen
                  fi
                fi
                if [ $DOWNLOAD_RESULT -eq 0 ];
                then
                  e_and_l -n "$PRE_SPACE Installation von ${light_yellow}$LOCAL_DOWNLOAD_FILE${colors_off} ... "
                  if [ ${OPTION_FLAG[quiet]} -eq 0 ]; then echo -e ""; fi
                  chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
                  chmod 0664 "$LOCAL_DOWNLOAD_FILE" &>/dev/null
                  if [ ${OPTION_FLAG[quiet]} -eq 1 ];
                  then
                    echo -n '\n\n\n' | apt install "$LOCAL_DOWNLOAD_FILE" -y &>"$LOG_TEMP"
                    INSTALL_RESULT=$?
                  else
                    { apt install "$LOCAL_DOWNLOAD_FILE" -y 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
                    INSTALL_RESULT=$(cat "$LAST_EXIT_CODE")
                    remove_file "$LAST_EXIT_CODE"
                  fi
                  if [ ${OPTION_FLAG[quiet]} -eq 1 ];
                  then
                    if [ $INSTALL_RESULT -eq 0 ];
                    then
                      e_and_l "$OK_TAG"
                    else
                      e_and_l "$ERROR_TAG"
                    fi
                  else
                    if [ $INSTALL_RESULT -eq 0 ];
                    then
                      do_log "$OK_TAG"
                    else
                      do_log "$ERROR_TAG"
                    fi
                  fi
                  add_full_log
                fi
              fi # Ende INSTALL_MODE 3 (DEB)

              # -----------------------------------------------------------------
              # Entpacken und Kopieren eines Fremd-Pakets
              # -----------------------------------------------------------------
              if [ $INSTALL_MODE -eq 4 ] &&
                 [ $DOWNLOAD_RESULT -eq 0 ];
              then
                if [ "$PKG_FOREIGN_ARCH" != "" ];
                then
                  e_and_l "$FOREIGN_WARNING"
                  ask_yes_or_no "$PRE_SPACE ${bold_yellow}$PAKET${colors_off} trotzdem installieren"
                  if [ $? -eq 1 ];
                  then
                    e_and_l "$PRE_SPACE $USER_CHOICE_YES"
                  else
                    e_and_l "$PRE_SPACE $USER_CHOICE_NO"
                    ((PAKETS_SKIP+=1))
                    ((PAKETS_NOAVAIL-=1))
                    if [ $IS_SIMILAR_PKG -eq 1 ]; then ((PAKETS_SIMILAR_NOAVA-=1)); fi
                    INSTALL_RESULT=1
                    DOWNLOAD_RESULT=1 # NICHT Weitermachen
                  fi
                fi
                if [ $DOWNLOAD_RESULT -eq 0 ];
                then
                  # ---------------------
                  # App-Ordner erstellen
                  # ---------------------
                  e_and_l -n "$PRE_SPACE Erstelle Ordner $PACKAGE_INST_DIR ... "
                  # 1. Sicherheitshalber Hauptordner anlegen und Zugriffsrechte setzen
                  if [ ! -d "$WEB_PKG_DIR" ];
                  then
                    mkdir "$WEB_PKG_DIR" &>"$LOG_TEMP"
                    if [ $? -eq 0 ];
                    then
                      chown -R "$USER_USERNAME:$USER_USERNAME" "$WEB_PKG_DIR" &>/dev/null
                      chmod -R 0755 "$WEB_PKG_DIR" &>/dev/null
                    fi
                  fi
                  # 2. Unterordner mit Paketnamen
                  if [ ! -d "$PACKAGE_INST_DIR" ];
                  then
                    mkdir -p "$PACKAGE_INST_DIR" &>"$LOG_TEMP"
                    if [ $? -eq 0 ];
                    then
                      chown -R "$USER_USERNAME:$USER_USERNAME" "$PACKAGE_INST_DIR" &>/dev/null
                      chmod -R 0755 "$PACKAGE_INST_DIR" &>/dev/null
                      e_and_l "$OK_TAG"
                    else
                      e_and_l "$ERROR_TAG"
                    fi
                  else
                    e_and_l "$OK_TAG"
                  fi
                  add_full_log
                  # ------------------------
                  # Entpacken bzw. Kopieren
                  # ------------------------
                  # Datei-Attribute setzen
                  chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
                  chmod 0664 "$LOCAL_DOWNLOAD_FILE" &>/dev/null
                  # Datei-Format ermitteln
                  AFTER_ACTION="Entpacke"
                  if [ $(echo -n "$LOCAL_DOWNLOAD_FILE" | grep -i -c ".ZIP") -ne 0 ] ||
                     [ $(echo -n "$LOCAL_DOWNLOAD_FILE" | grep -i -c ".7Z") -ne 0 ];
                  then
                    DOWNLOAD_FORMAT="ZIP"
                  else
                    if [ $(echo -n "$LOCAL_DOWNLOAD_FILE" | grep -i -c ".tar") -ne 0 ] ||
                       [ $(echo -n "$LOCAL_DOWNLOAD_FILE" | grep -i -c ".tgz") -ne 0 ];
                    then
                      DOWNLOAD_FORMAT="TAR"
                    else
                      DOWNLOAD_FORMAT="EXE"
                      AFTER_ACTION="Kopiere"
                    fi
                  fi

                  WPKG_CLEAN_NAME=$(echo "$PAKET" | tr A-Z a-z | sed 's/ /-/g' | xargs)

                  # Je nach Datei-Format entpacken oder kopieren
                  e_and_l -n "$PRE_SPACE $AFTER_ACTION ${light_yellow}$LOCAL_DOWNLOAD_FILE${colors_off}\n$PRE_SPACE nach ${light_yellow}$PACKAGE_INST_DIR${colors_off} ... "
                  if [ "$DOWNLOAD_FORMAT" = "ZIP" ];
                  then
                    7z x "$LOCAL_DOWNLOAD_FILE" -o"$PACKAGE_INST_DIR" -y &>"$LOG_TEMP"
                    INSTALL_RESULT=$?
                  else
                    if [ "$DOWNLOAD_FORMAT" = "TAR" ];
                    then
                      tar -axf "$LOCAL_DOWNLOAD_FILE" -C "$PACKAGE_INST_DIR" &>"$LOG_TEMP"
                      INSTALL_RESULT=$?
                      if [ $INSTALL_RESULT -ne 0 ];
                      then
                        tar -xzf "$LOCAL_DOWNLOAD_FILE" -C "$PACKAGE_INST_DIR" &>"$LOG_TEMP"
                        INSTALL_RESULT=$?
                      fi
                    else # DOWNLOAD_FORMAT "EXE"
                      cp -f "$LOCAL_DOWNLOAD_FILE" "$PACKAGE_INST_DIR" &>"$LOG_TEMP"
                      INSTALL_RESULT=$?
                      # Für ausführbare Programme, die nur als Datei kopiert und nicht installiert worden sind,
                      # und auch nicht aus einen Archiv entpackt wurden, zusätzlich einen Menü-Eintrag hinzufügen
                      if [ $INSTALL_RESULT -eq 0 ];
                      then
                        chmod -R 0755 "$PACKAGE_INST_DIR" &>/dev/null
                        APPIMG_FILE_NAME="$DOWNLOAD_FILE_NAME"
                        if [ -s "$PACKAGE_INST_DIR/$APPIMG_FILE_NAME" ];
                        then
                          # Icon runterladen und mit im Programmordner hinterlegen
                          # (ggf. redundant mit Suche einer Bilddatei weiter unten)
                          IMAGE_FILE_NAME="$WPKG_CLEAN_NAME.png"
                          ICON_TARGET_FILE="$PACKAGE_INST_DIR/$IMAGE_FILE_NAME"
                          LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$IMAGE_FILE_NAME"
                          wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$RESSOURCE_SERVER_DIR/png/$IMAGE_FILE_NAME" &>/dev/null
                          DOWNLOAD_RESULT=$?
                          if [ $DOWNLOAD_RESULT -eq 0 ] &&
                             [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
                             [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
                          then
                            cp -f "$LOCAL_DOWNLOAD_FILE" "$ICON_TARGET_FILE" &>/dev/null
                            chown "root:root" "$ICON_TARGET_FILE" &>/dev/null
                            chmod 0644 "$ICON_TARGET_FILE" &>/dev/null
                          fi
                          # .desktop-Datei anlegen
                          # ACHTUNG: Derzeit nur als Zubehör (Utility)
                          DESKTOP_FILE="/usr/share/applications/$WPKG_CLEAN_NAME.desktop"
                          echo -e "[Desktop Entry]" > "$DESKTOP_FILE" 2>/dev/null
                          if [ $? -eq 0 ];
                          then
                            echo -e "Type=Application" >> "$DESKTOP_FILE" 2>/dev/null
                            echo -e "Name=${WEB_PKG_NAME[$PAKET]}" >> "$DESKTOP_FILE" 2>/dev/null
                            echo -e "Comment=${WEB_PKG_NAME[$PAKET]} starten" >> "$DESKTOP_FILE" 2>/dev/null
                            echo -e "Exec=$PACKAGE_INST_DIR/$APPIMG_FILE_NAME" >> "$DESKTOP_FILE" 2>/dev/null
                            echo -e "Icon=$ICON_TARGET_FILE" >> "$DESKTOP_FILE" 2>/dev/null
                            echo -e "Categories=${WEB_PKG_CATY[$PAKET]};" >> "$DESKTOP_FILE" 2>/dev/null
                            echo -e "Terminal=false" >> "$DESKTOP_FILE" 2>/dev/null
                            echo -e "StartupNotify=true" >> "$DESKTOP_FILE" 2>/dev/null
                            echo -e "NoDisplay=false" >> "$DESKTOP_FILE" 2>/dev/null
                            chown "root:root" "$DESKTOP_FILE" &>/dev/null
                            chmod 0644 "$DESKTOP_FILE" &>/dev/null
                          fi
                        fi
                      fi
                    fi
                  fi

                  # -----------------------------------------------------------
                  # Wenn alles ok, Programm-Version notieren und
                  # den gesamten Programm-Ordner zu eigen machen
                  # -----------------------------------------------------------
                  if [ $INSTALL_RESULT -eq 0 ];
                  then
                    # Programm-Version als Datei speichern -------------
                    PKG_VERS_FILE="$PACKAGE_INST_DIR/.$PAKET"
                    PKG_VERS_FILE+="_version"
                    echo -e "${WEB_PKG_VERS[$PAKET]}" > "$PKG_VERS_FILE" 2>/dev/null
                    # --------------------------------------------------
                    e_and_l "$OK_TAG"
                    e_and_l "$PRE_SPACE $HINWEIS_TAG: Eventuell müssen die Zugriffsrechte noch angepasst werden!"
                    chown -R "$USER_USERNAME:$USER_USERNAME" "$PACKAGE_INST_DIR" &>/dev/null
                  else
                    e_and_l "$ERROR_TAG"
                  fi
                  add_full_log

                  # -----------------------------------------------------------
                  # Wenn alles ok, zudem prüfen ob es ein Icon zu dem Paket
                  # gibt und ggf. eine passende Bilddatei herunterladen
                  # -----------------------------------------------------------
                  if [ $INSTALL_RESULT -eq 0 ];
                  then
                    # Kategorien mit Programmpaketen ohne Desktop-Symbole auslassen
                    if
                     [ "$CURRENT_CATEGORY" != "a" ] &&
                     [ "$CURRENT_CATEGORY" != "f" ] &&
                     [ "$CURRENT_CATEGORY" != "u" ] &&
                     [ "$CURRENT_CATEGORY" != "x" ];
                    then
                      download_icon_file "$WPKG_CLEAN_NAME"
                    fi
                  fi

                fi # Fehler beim Download
              fi # Ende INSTALL_MODE 4 (WEB)

            fi

            if [ $INSTALL_RESULT -eq 0 ]; # 0 = Installation OK
            then
              ((PAKETS_AVAIL+=1))
              if [ $IS_SIMILAR_PKG -eq 1 ]; then ((PAKETS_SIMILAR_AVAIL+=1)); fi
            else
              ((PAKETS_NOAVAIL+=1))
              if [ $IS_SIMILAR_PKG -eq 1 ]; then ((PAKETS_SIMILAR_NOAVA+=1)); fi
            fi

            # -----------------------------------------------------------------
            # NACH erfolgreicher Installation ggf. Konfiguration durchführen
            # -----------------------------------------------------------------
            if [ $INSTALL_RESULT -eq 0 ];
            then
              if [ "${POST_INST_CONF[$PAKET]}" != "" ];
              then
                e_and_l ""
                e_and_l -n "$PRE_SPACE Führe weitere ${light_yellow}Konfiguration${colors_off} durch ... "
                POST_ACTION="${POST_INST_CONF[$PAKET]}"
                if [ $(echo -n "$POST_ACTION" | grep -i -c -E "^\s*http") -gt 0 ];
                then
                  CONFIG_FILE_NAME="${POST_ACTION##*/}"
                  CONFIG_URL="$POST_ACTION"
                  LOCAL_CONFIG_FILE="$DOWNLOAD_DIR/$CONFIG_FILE_NAME"
                  wget -nv -O "$LOCAL_CONFIG_FILE" "$CONFIG_URL" &>"$LOG_TEMP"
                  if [ $? -eq 0 ] &&
                     [ -s "$LOCAL_CONFIG_FILE" ] &&
                     [ $(grep -i -c -E "Error\s*404" "$LOCAL_CONFIG_FILE") -eq 0 ];
                  then
                    # Heruntergeladenes Konfigurations-Script ausführen mit dem Benutzernamen
                    # als erstem Parameter zur Verwendung im aufgerufenen Konfigurations-Script
                    chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_CONFIG_FILE" &>/dev/null
                    chmod a+x "$LOCAL_CONFIG_FILE" &>/dev/null
                    echo -e ""
                    ( "$LOCAL_CONFIG_FILE" ${USER_USERNAME} ${DOWNLOAD_DIR} ${RESSOURCE_SERVER_DIR} ${OS_V_CODENAME} 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; ) | tee "$LOG_TEMP"
                    if [ $(cat "$LAST_EXIT_CODE") -eq 0 ];
                    then
                      do_log "$OK_TAG"
                    else
                      do_log "$ERROR_TAG"
                    fi
                    # Konfigurations-Script löschen
                    # remove_file "$LOCAL_CONFIG_FILE"
                  else
                    e_and_l ""
                    e_and_l "$PRE_SPACE $ERROR_TAG: Das Konfigurations-Script konnte nicht geladen werden!"
                    # Durch wget eventuell angelegte unbrauchbare Datei löschen
                    remove_file "$LOCAL_CONFIG_FILE"
                  fi
                  echo -e ""
                  if [ ${OPTION_FLAG[quiet]} -eq 0 ]; then echo -e -n "$PRE_SPACE Bitte ${bold_white}Enter${colors_off} drücken zum Weitermachen ... "; read dummy; fi
                else
                  echo -e ""
                  { eval "$POST_ACTION" 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
                  if [ $(cat "$LAST_EXIT_CODE") -eq 0 ];
                  then
                    do_log "$OK_TAG"
                  else
                    do_log "$ERROR_TAG"
                  fi
                fi
                remove_file "$LAST_EXIT_CODE"
                do_log "Aktion: $POST_ACTION"
                add_full_log
                echo -e ""
              fi
            fi

            # -----------------------------------------------------------------
            # Nach NICHT erfolgreicher Installation das Repo wieder bereinigen
            # -----------------------------------------------------------------
            if [ $INSTALL_RESULT -ne 0 ];
            then
              clear_repo "$PAKET"
            fi

            # -----------------------------------------------------------------
            # Nach erfolgreicher Installation ggf. Desktop-Icon anlegen
            # -----------------------------------------------------------------
            if [ $INSTALL_RESULT -eq 0 ]; then copy_starter_to_desktop $PAKET; fi

          else # wenn Ja-Nein-Abfrage negativ ausgefallen

            # do_log "$PRE_SPACE $PAKET wurde nicht installiert"
            e_and_l "$PRE_SPACE ${light_cyan}$PAKET${colors_off} wurde ${light_red}nicht${colors_off} installiert"
            ((PAKETS_SKIP+=1))

          fi

        else # wenn OPTION_FLAG[status] = 1

          # -----------------------------------------------------------
          # Möglichkeiten zur Installation des Programmpakets anzeigen
          # -----------------------------------------------------------
          IMODE_MSG=" ${light_yellow}$PAKET${colors_off}"
          # -----------------------------------------------------
          # Wenn nur eine Version (Quelle) existiert, dann auch
          # die Versionsnummer eines verfügbaren Pakets ermitteln
          PKG_VERSION=""
          if [ ${#INST_MODE_LIST} -eq 3 ]; # "0,n" z.B. "0,2"
          then
            case $INSTALL_MODE in
              1) PKG_VERSION=$(get_pkg_apt_version  "$PAKET" 0) ;;
              2) PKG_VERSION=$(get_pkg_snap_version "$PAKET" 0) ;;
              3) PKG_VERSION=$(get_pkg_deb_version  "$PAKET")   ;;
              4) PKG_VERSION=$(get_pkg_web_version  "$PAKET")   ;;
            esac
            if [ "$PKG_VERSION" != "" ] &&
               [ "$PKG_VERSION" != "0" ];
            then
              IMODE_MSG+=" ${light_yellow}$PKG_VERSION${colors_off}"
            fi
          fi
          # -----------------------------------------------------
          IMODE_MSG+=" ist nicht installiert, aber"
          # -----------------------------------------
          # Wenn nur eine Version (Quelle) existiert,
          # dann diese Quelle auch benennen
          if [ ${#INST_MODE_LIST} -gt 3 ]; # "0,n" z.B. "0,2,4"
          then
            IMODE_MSG+=" ${light_purple}mehrfach${colors_off}"
          else
            case "$INSTALL_MODE" in
              1) IMODE_MSG+="" ;;
              2) IMODE_MSG+=" als ${light_purple}Snap${colors_off}" ;;
            3|4) if [ "$PKG_FOREIGN_ARCH" = "" ];
                then
                  # IMODE_MSG+=" als ${light_purple}Download ("
                  # if [ $INSTALL_MODE -eq 3 ]; then IMODE_MSG+="DEB"; else IMODE_MSG+="WEB"; fi
                  # IMODE_MSG+=")${colors_off}"
                  IMODE_MSG+=" von ${light_purple}extern${colors_off}"
                else
                  IMODE_MSG+=" für ${light_purple}$PKG_FOREIGN_ARCH${colors_off}"
                fi
                ;;
            esac
          fi
          # -----------------------------------------
          IMODE_MSG+=" verfügbar"
          e_and_l "$IMODE_MSG"

          ((PAKETS_AVAIL+=1))
          if [ $IS_SIMILAR_PKG -eq 1 ]; then ((PAKETS_SIMILAR_AVAIL+=1)); fi

          # -----------------------------------------------------------
          # Hinweis auf bereits installierte Alternativen anzeigen
          # und dabei auch deren Desktop-Icon mit anlegen
          # -----------------------------------------------------------
          add_similar_icons $PAKET 1

        fi

      else # Wenn kein Installations-Kandidat gefunden wurde

        ((PAKETS_NOAVAIL+=1))
        if [ $IS_SIMILAR_PKG -eq 1 ]; then ((PAKETS_SIMILAR_NOAVA+=1)); fi

      fi

    else # Wenn das Paket übersprungen werden soll

      e_and_l " ${light_cyan}$PAKET${colors_off} wird übersprungen$SKIP_REASON"

      ((PAKETS_SKIP+=1))

    fi

  else # Wenn das Paket schon installiert ist

    IMODE_MSG=" ${light_green}$PAKET${colors_off}"
    if [ "$PKG_VERSION" != "" ] &&
       [ "$PKG_VERSION" != "0" ];
    then
      IMODE_MSG+=" ${light_purple}$PKG_VERSION${colors_off}"
    fi
    IMODE_MSG+=" ist "

    case "$INST_RES" in
        1) IMODE_MSG+="bereits" ;;
        2) IMODE_MSG+="als ${light_purple}Snap${colors_off}" ;;
      3|4) IMODE_MSG+="in ${light_purple}$THE_PKG_INST_DIR${colors_off}" ;;
        5) IMODE_MSG+="in ${light_purple}$THE_PKG_INST_DIR${colors_off}" ;;
    esac
    e_and_l "$IMODE_MSG installiert"

    ((PAKETS_EXIST+=1))

    if [ $IS_SIMILAR_PKG -eq 1 ]; then ((PAKETS_SIMILAR_EXIST+=1)); fi

    # ------------------------------------------------------------------------
    # "Auf Wunsch" auch für schon installierte Programme sowie
    #  deren installierte Alternativen ein Desktop-Icon anlegen
    # ------------------------------------------------------------------------
    copy_starter_to_desktop $PAKET
    add_similar_icons $PAKET 0

  fi

  ((PAKETS_COUNTER+=1))
}

###############################################################################
# Funktion zur Prüfung einer sinnvollen Auswahl zur Verarbeitung
###############################################################################
function ready_for_action () {
  # ---------------------
  # Paket-Liste erzeugen
  # ---------------------
  TMP_LIST="$INST_ONLY_PKG"
  for k in ${KAT_KEY_LIST[@]};
  do
    if [ ${KATEGORIE_FLAG[$k]} -eq 1 ];
    then
      TMP_LIST+=" ${KATEGORIE_PKGS[$k]}"
    fi
  done
  # --------------------------------------------
  # Automatisch zu ergänzende Pakete hinzufügen
  # --------------------------------------------
  for p in ${TMP_LIST};
  do
    ADDITIONAL_PACKS="${AUTO_ADD_PKGS[$p]}"
    if [ "$ADDITIONAL_PACKS" != "" ];
    then
      if [ "${AUTO_ADD_PPOS[$p]}" != "true" ];
      then
        # Zusätzliche Pakete NACH Basispaket einfügen
        TMP_LIST=$(echo " $TMP_LIST " | sed -E "s/ $p / $p $ADDITIONAL_PACKS /")
      else
        # Zusätzliche Pakete VOR Basispaket einfügen
        TMP_LIST=$(echo " $TMP_LIST " | sed -E "s/ $p / $ADDITIONAL_PACKS $p /")
      fi
    fi
  done
  # -----------------------------
  # Liste in ein Array umwandeln
  # -----------------------------
  ALL_PKG_LIST=(${TMP_LIST})
  TOTAL_PACKS=${#ALL_PKG_LIST[@]}
  # echo -e "AUSWAHL: ${ALL_PKG_LIST[@]} ($TOTAL_PACKS)" # NUR ZUM TESTEN
  # echo -e "SKIP:${SKIP_LIST[@]} (${#SKIP_LIST[@]})" # NUR ZUM TESTEN
  # exit # NUR ZUM TESTEN
  if [[ $TOTAL_PACKS             -eq 0 &&
        ${OPTION_FLAG[cleansys]} -eq 0 &&
        ${OPTION_FLAG[dload]}    -eq 0 &&
        ${OPTION_FLAG[dsave]}    -eq 0 &&
        ${OPTION_FLAG[extras]}   -eq 0 &&
        ${OPTION_FLAG[exupdate]} -eq 0 &&
        ${OPTION_FLAG[infoonly]} -eq 0 &&
        ${OPTION_FLAG[kuplock]}  -eq 0 &&
        ${OPTION_FLAG[kunlock]}  -eq 0 &&
        ${OPTION_FLAG[optimize]} -eq 0 &&
        ${OPTION_FLAG[personal]} -eq 0 &&
        ${OPTION_FLAG[remove]}   -eq 0 &&
        ${OPTION_FLAG[udrivers]} -eq 0 ]];
  then
    return 1
  else
    return 0
  fi
}

###############################################################################
# Funktion zum Löschen einer bestimmten einzelnen Datei
###############################################################################
function remove_file () {
  if [ "$1" != "" ] &&
     [ -f "$1" ];
  then
    rm -f "$1" &>/dev/null
  fi
}

###############################################################################
# Funktion zum Ermittlung der benutzerspezifischen Konfigurations-Daten eines
# Programmpakets zur nachfolgenden Löschung
###############################################################################
function remove_cfg () {
  echo -e ""
  e_and_l " ${light_blue}Schritt 2/$REMOVE_ACTION:${colors_off} Löschen der Konfiguration"
  echo -e -n " Starte Suche, bitte warten ... "
  NOTHING_FOUND_TEXT="Es wurde keine individuelle Konfiguration gefunden"
  # Betroffene Ordner und Dateien ermitteln und daraus eine Liste erstellen ---
  REMOVE_ITEM_LIST="$DOWNLOAD_DIR/remove_config_list"
  echo -e -n "" > "$REMOVE_ITEM_LIST"
  if [ $INST_STATUS -eq 2 ] ||
     [ $2 -eq 1 ];
  then
    find ${USER_HOME_DIR} -iname "$1" -type d,f 2>/dev/null | grep -i -E "snap\/" >> "$REMOVE_ITEM_LIST"
    find ${USER_HOME_DIR} -iname ".$1" -type d,f 2>/dev/null | grep -i -E "snap\/" >> "$REMOVE_ITEM_LIST"
  fi
  if [ $INST_STATUS -ne 2 ] ||
     [ $2 -eq 1 ];
  then
    find ${USER_HOME_DIR} -iname "$1" -type d,f 2>/dev/null | grep -v -i -E "snap\/" >> "$REMOVE_ITEM_LIST"
    find ${USER_HOME_DIR} -iname ".$1" -type d,f 2>/dev/null | grep -v -i -E "snap\/" >> "$REMOVE_ITEM_LIST"
  fi
  echo -e "$FERTIG_TAG"
  do_remove_items 0
}

###############################################################################
# Funktion zum Ermittlung aller Daten zu einem Programmpaket
###############################################################################
function remove_dat () {
  echo -e ""
  e_and_l " ${light_blue}Schritt 3/$REMOVE_ACTION:${colors_off} Löschen weiterer zugehöriger Daten"
  echo -e -n " Starte Suche, bitte warten ... "
  NOTHING_FOUND_TEXT="Es wurden keine weiteren Daten gefunden"
  # Betroffene Ordner und Dateien ermitteln und daraus eine Liste erstellen ---
  REMOVE_ITEM_LIST="$DOWNLOAD_DIR/remove_item_list"
  echo -e -n "" > "$REMOVE_ITEM_LIST"
# -----------------------------------------------------------------------------
# DIE INTENSIVE SUCHE WIRD DERZEIT MICHT DURCHGEFÜHRT / ANGEBOTEN
# -----------------------------------------------------------------------------
#   e_and_l " Wie soll die Suche nach weiteren zugehörigen Daten erfolgen?"
#   e_and_l " [${bold_white}e${colors_off}] Erweiterte Vorkommen in den Namen von Ordnern und Dateien"
#   e_and_l " [${bold_white}i${colors_off}] Zusätzlich intensive Suche nach Vorkommen ${bold_white}in${colors_off} allen Dateien (langsam!)"
#   e_and_l -n " Bitte eine Option auswählen: "
#   SEARCH_METHOD=""
#   while [ "$SEARCH_METHOD" != "e" ] &&
#         [ "$SEARCH_METHOD" != "E" ] &&
#         [ "$SEARCH_METHOD" != "i" ] &&
#         [ "$SEARCH_METHOD" != "I" ];
#   do
#     read -N 1 -r -s SEARCH_METHOD
#   done
#   e_and_l "$SEARCH_METHOD"
# -----------------------------------------------------------------------------
  find / -iname "*$1*" -type d,f 1>>"$REMOVE_ITEM_LIST" 2>/dev/null
# -----------------------------------------------------------------------------
#   if [ "$SEARCH_METHOD" = "i" ] ||
#      [ "$SEARCH_METHOD" = "I" ];
#   then
#     grep -i -l "$REMOVE_PKG_NAME" ... ... ... 1>>"$REMOVE_ITEM_LIST" 2>/dev/null
#   fi
# -----------------------------------------------------------------------------
  # Doppelte Einträge entfernen
  if [ -s "$REMOVE_ITEM_LIST" ];
  then
    THE_TEMP_FILE="$DOWNLOAD_DIR/tmp_rm_item_list.tmp"
    awk '!seen[$0]++' "$REMOVE_ITEM_LIST" > "$THE_TEMP_FILE" 2>/dev/null
    remove_file "$REMOVE_ITEM_LIST"
    mv "$THE_TEMP_FILE" "$REMOVE_ITEM_LIST" &>/dev/null
  fi
  echo -e "$FERTIG_TAG"
  do_remove_items 1
}

###############################################################################
# Funktion zum Löschen einer Liste von Ordnern und Dateien
###############################################################################
function do_remove_items () {
  if [ -s "$REMOVE_ITEM_LIST" ];
  then
    chown "$USER_USERNAME:$USER_USERNAME" "$REMOVE_ITEM_LIST" &>/dev/null
    chmod 0664 "$REMOVE_ITEM_LIST" &>/dev/null
    declare -A REMOVE_ITEM_TABLE
    REMOVE_TABLE_IDX=0
    while read config_path;
    do
      if [ "$config_path" != "" ] &&
         [ "$config_path" != "$USER_HOME_DIR" ];
      then
        e_and_l " - ${light_cyan}$config_path${colors_off}"
        REMOVE_ITEM_TABLE[$REMOVE_TABLE_IDX]="$config_path"
        ((REMOVE_TABLE_IDX+=1))
      fi
    done < "$REMOVE_ITEM_LIST"
    if [ $REMOVE_TABLE_IDX -gt 0 ];
    then
      if [ $1 -eq 1 ];
      then
        e_and_l " ------------------------------------------------------------------------------"
        e_and_l " $ACHTUNG_TAG: Die gefunden Dateien können aufgrund der stark erweiterten Suche"
        e_and_l " eventuell auch zu anderen, ähnlich lautenden Programmpaketen, oder auch zu"
        e_and_l " benötigten Systemkomponenten gehören! Daher vor dem Löschen alle gefundenen"
        e_and_l " Einträge sorgfältig auf ihre Zugehörigkeit prüfen! Im Zweifel mit Option [1]"
        e_and_l " nicht bekannte Einträge überspringen, oder die Aktion abbrechen und mit Hilfe"
        e_and_l " der dabei gespeicherten Liste alle Dateien später prüfen und manuell löschen!"
        e_and_l " ------------------------------------------------------------------------------"
      fi
      e_and_l " Zum Löschen dieser Ordner und Dateien stehen folgende Optionen zur Verfügung:"
      e_and_l " [${bold_white}0${colors_off}] Abbrechen, nichts löschen und die Liste als Datei speichern"
      e_and_l " [${bold_white}1${colors_off}] Löschen mit Abfrage vor jedem/r einzelnen Ordner/Datei"
      e_and_l " [${bold_white}2${colors_off}] Alle Ordner und Dateien ohne einzelne Abfragen löschen"
      e_and_l -n " Bitte eine Option auswählen: "
      REMOVE_ITEMS_ACTION=-1
      while [ $REMOVE_ITEMS_ACTION -lt 0 ] ||
            [ $REMOVE_ITEMS_ACTION -gt 2 ];
      do
        read -N 1 -r -s REMOVE_ITEMS_ACTION
        REMOVE_ITEMS_ACTION=$(echo $REMOVE_ITEMS_ACTION | sed 's/[^0-9]*//g')
        if [ "$REMOVE_ITEMS_ACTION" = "" ]; then REMOVE_ITEMS_ACTION=-1; fi
      done
      e_and_l "$REMOVE_ITEMS_ACTION"
      # Wenn alle, dann VORHER noch eine Sicherheitsabfrage
      if [ $REMOVE_ITEMS_ACTION -eq 2 ];
      then
        e_and_l " Hast Du die Liste ganz genau geprüft, so dass nichts ungewollt gelöscht wird?"
        ask_yes_or_no " Wirklich ${bold_red}alle${colors_off} vorstehenden Ordner und Dateien löschen"
        if [ $? -eq 0 ];
        then
          e_and_l " $USER_CHOICE_NO"
          REMOVE_ITEMS_ACTION=0
        else
          e_and_l " $USER_CHOICE_YES"
        fi
      else
        echo -e ""
      fi
      if [ $REMOVE_ITEMS_ACTION -ne 0 ];
      then
        echo -e -n "" > "$LOG_TEMP"
        i=0
        while [ $i -lt $REMOVE_TABLE_IDX ];
        do
          config_path="${REMOVE_ITEM_TABLE[$i]}"
          if [ "$config_path" != "" ] &&
             [ "$config_path" != "$USER_HOME_DIR" ];
          then
            DO_REMOVE_ITEM=1
            # Wenn mit einzelner Bestätigung, dann noch die Sicherheitsabfrage
            if [ $REMOVE_ITEMS_ACTION -eq 1 ];
            then
              if [ $i -gt 0 ];
              then
                echo -e "$HALF_MINUS_LINE"
              fi
              e_and_l " ${light_cyan}$config_path${colors_off}"
              ask_yes_or_no " Löschen"
              if [ $? -eq 0 ];
              then
                DO_REMOVE_ITEM=0
              fi
            fi
            # Löschen ...
            if [ $DO_REMOVE_ITEM -eq 1 ];
            then
              e_and_l -n " Lösche ${light_yellow}$config_path${colors_off} ... "
              rm -f -r "$config_path" &>>"$LOG_TEMP"
              if [ $? -eq 0 ];
              then
                e_and_l "$OK_TAG"
              else
                e_and_l "$ERROR_TAG"
              fi
            fi
          fi
          ((i+=1))
        done
        remove_file "$REMOVE_ITEM_LIST"
        add_full_log
      else
        e_and_l " $HINWEIS_TAG: Die Liste der gefundenen Ordner und Dateien ist gespeichert in:"
        e_and_l " ${light_yellow}$REMOVE_ITEM_LIST${colors_off}"
      fi
    else
      remove_file "$REMOVE_ITEM_LIST"
      e_and_l " $NOTHING_FOUND_TEXT ... $OK_TAG"
    fi
  else
    remove_file "$REMOVE_ITEM_LIST"
    e_and_l " $NOTHING_FOUND_TEXT ... $OK_TAG"
  fi
}

###############################################################################
# Funktion zum Löschen der Starter / Desktopsymbole eines Programmpakets
###############################################################################
function remove_ico {
  THE_PKG_REAL_NAME="$1"
  do_log " Lösche Starter zu $THE_PKG_REAL_NAME"
  # Starter mit dem gleichen Dateinamen wie das Programm selbst
  remove_file "/usr/share/applications/$THE_PKG_REAL_NAME.desktop"
  find "$USER_HOME_DIR" -type f -iname "$THE_PKG_REAL_NAME.desktop" -delete &>"$LOG_TEMP"
  # Starter mit anderem Dateinamen als das Programm selbst
  tmp_list=${PKG_ICON_LIST[$THE_PKG_REAL_NAME]};
  if [ "$tmp_list" != "" ]
  then
    for icon_file in ${tmp_list[@]};
    do
      remove_file "/usr/share/applications/$icon_file.desktop"
      find "$USER_HOME_DIR" -type f -iname "$icon_file.desktop" -delete &>"$LOG_TEMP"
    done
  fi
  add_full_log
}

###############################################################################
# Funktion zum Löschen eines Programmpakets
###############################################################################
function remove_pkg () {
  THE_PKG_REAL_NAME="$1"
  THE_REMOVE_MODE=$2 # 0 = einfaches entfernen, 1 = entfernen mit purge
  e_and_l -n " Löschen von ${bold_yellow}$THE_PKG_REAL_NAME${colors_off} ... "
  # ----------------------------
  # Mit apt installierte Pakete
  if [ $INST_STATUS -eq 1 ];
  then
    e_and_l ""
    if [ $THE_REMOVE_MODE -eq 0 ];
    then
      { apt remove "$THE_PKG_REAL_NAME" -y 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
    else
      { apt purge "$THE_PKG_REAL_NAME" -y 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
    fi
    REMOVE_RESULT=$(cat "$LAST_EXIT_CODE")
  fi
  # -----------------------------
  # Als Snap installierte Pakete
  if [ $INST_STATUS -eq 2 ];
  then
    e_and_l ""
    if [ $THE_REMOVE_MODE -eq 0 ];
    then
      { snap remove "$THE_PKG_REAL_NAME" 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
    else
      { snap remove --purge "$THE_PKG_REAL_NAME" 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
    fi
    REMOVE_RESULT=$(cat "$LAST_EXIT_CODE")
  fi
  # ---------------------------------------------------------
  # In /opt oder dem Benutzerverzeichnis gespeicherte Pakete
  if [ $INST_STATUS -gt 2 ];
  then
    # Dateien und Paket-Ordner in /opt löschen
    REMOVE_OPT_RESULT=0
    if [ $INST_STATUS -eq 3 ];
    then
      TMP_PKG_INST_NAME="${DEB_PKG_NAME[$THE_PKG_REAL_NAME]}"
      if [ "$TMP_PKG_INST_NAME" = "" ];
      then
        TMP_PKG_INST_NAME="${WEB_PKG_NAME[$THE_PKG_REAL_NAME]}"
        if [ "$TMP_PKG_INST_NAME" = "" ];
        then
          TMP_PKG_INST_NAME="$THE_PKG_REAL_NAME"
        fi
      fi
      TMP_PKG_INST_DIR="/opt/$TMP_PKG_INST_NAME"
      if [ -d "$TMP_PKG_INST_DIR" ];
      then
        rm -d -f -r "$TMP_PKG_INST_DIR" &>"$LOG_TEMP"
        REMOVE_OPT_RESULT=$?
      fi
    fi
    # Dateien und Paket-Ordner in /home/USER/apps löschen
    REMOVE_HOME_RESULT=0
    if [ $INST_STATUS -eq 4 ];
    then
      TMP_PKG_INST_NAME="${WEB_PKG_NAME[$THE_PKG_REAL_NAME]}"
      if [ "$TMP_PKG_INST_NAME" = "" ];
      then
        TMP_PKG_INST_NAME="$THE_PKG_REAL_NAME"
      fi
      TMP_PKG_INST_DIR="$WEB_PKG_DIR/$TMP_PKG_INST_NAME"
      if [ -d "$TMP_PKG_INST_DIR" ];
      then
        rm -d -f -r "$TMP_PKG_INST_DIR" &>"$LOG_TEMP"
        REMOVE_HOME_RESULT=$?
      fi
    fi
    # Dateien und Paket-Ordner in /usr/share löschen
    REMOVE_SHARE_RESULT=0
    if [ $INST_STATUS -eq 5 ] &&
       [ "$THE_PKG_REAL_NAME" != "" ];
    then
      TMP_PKG_INST_DIR="/usr/share/$THE_PKG_REAL_NAME"
      if [ -d "$TMP_PKG_INST_DIR" ];
      then
        rm -d -f -r "$TMP_PKG_INST_DIR" &>"$LOG_TEMP"
        REMOVE_SHARE_RESULT=$?
      fi
    fi
    # ---
    if [ $REMOVE_OPT_RESULT -eq 0 ] &&
       [ $REMOVE_HOME_RESULT -eq 0 ] &&
       [ $REMOVE_SHARE_RESULT -eq 0 ];
    then
      REMOVE_RESULT=0
      e_and_l "$OK_TAG"
    else
      REMOVE_RESULT=1
      e_and_l "$ERROR_TAG"
    fi
  fi
  add_full_log
  remove_file "$LAST_EXIT_CODE"
}

###############################################################################
# Funktion zum Löschen aller (verbliebenen) Schnappschüsse von Snap-Paketen
###############################################################################
function remove_snapshots () {
  if [ $SNAP_INSTALLED -ne 0 ];
  then
    # Wenn nur die Schnappschüsse eines bestimmten Snap-Pakets entfernt werden
    # sollen, dann dazu neue dedizierte Liste der Schnappschüsse erstellen
    if [ "$1" != "" ];
    then
      remove_file "$SNAPSHOT_SNAPS_LIST"
      if [ $(snap saved 2>/dev/null | grep -i -c -E "\s$1\s") -eq 0 ];
      then
        LANG=en_US.UTF-8 snap saved | grep -i -E "\s$1\s" | awk '{print $1, $2, "(A"$3")", "(V"$4")", "(R"$5")", "(S"$6")"}' >> "$SNAPSHOT_SNAPS_LIST"
      fi
    fi
    # Nur weitermachen, wenn es Schnappschüsse (des Snap-Pakets) gibt ...
    if [ -s "$SNAPSHOT_SNAPS_LIST" ];
    then
      e_and_l " Es wurden folgende ${light_cyan}Snap-Snapschüsse${colors_off} gefunden:"
      e_and_l " ${bold_white}Name                      Version                  Revision   Set    Größe${colors_off}"
      while read snapset snapname snapage snapversion snaprevision snapsize
      do
        # Name
        SNAP_PKG_NAME="$snapname"
        e_and_l -n " ${SNAP_PKG_NAME:0:25}"
        ((ANZ_SPACES=26-${#SNAP_PKG_NAME}))
        insert_spaces $ANZ_SPACES
        # Version
        SNAP_VERSION="${snapversion/(V/}"
        SNAP_VERSION="${SNAP_VERSION/)/}"
        e_and_l -n " ${SNAP_VERSION:0:25}"
        ((ANZ_SPACES=26-${#SNAP_VERSION}))
        insert_spaces $ANZ_SPACES
        # Revision
        SNAP_REVISION="${snaprevision/(R/}"
        SNAP_REVISION="${SNAP_REVISION/)/}"
        e_and_l -n "${SNAP_REVISION:0:11}"
        ((ANZ_SPACES=12-${#SNAP_REVISION}))
        insert_spaces $ANZ_SPACES
        # Snap-Set (fortlaufende Nummer der Gruppe von gelöschten Snaps)
        e_and_l -n "${snapset:0:7}"
        ((ANZ_SPACES=8-${#snapset}))
        insert_spaces $ANZ_SPACES
        # Größe
        SNAP_SIZE="${snapsize/(S/}"
        SNAP_SIZE="${SNAP_SIZE/)/}"
        e_and_l "$SNAP_SIZE"
      done < "$SNAPSHOT_SNAPS_LIST"
      ask_yes_or_no " Jetzt ${bold_white}ALLE${colors_off} vorstehenden Snap-Schnappschüsse löschen"
      if [ $? -eq 1 ];
      then
        while read snapset snapname snapage snapversion snaprevision snapsize
        do
          e_and_l -n " Lösche Schnappschuss Set ${light_yellow}$snapset${colors_off} ... "
          snap forget "$snapset" "$snapname" &>/dev/null
          if [ $? -eq 0 ];
          then
            e_and_l "$OK_TAG"
          else
            e_and_l "$ERROR_TAG"
          fi
        done < "$SNAPSHOT_SNAPS_LIST"
      fi
      e_and_l " $HINWEIS_TAG: Zum Löschen veralteter ${bold_white}Snap-Revisionen${colors_off} das Tool ${light_purple}snapco${colors_off} verwenden ;)"
    fi
    remove_file "$SNAPSHOT_SNAPS_LIST"
  fi
}

###############################################################################
# Funktion zur Aktualisierung des Repository
###############################################################################
function repo_update () {
  e_and_l -n "$1"
  apt update &>"$LOG_TEMP"
  if [ $? -eq 0 ];
  then
    e_and_l "$OK_TAG"
  else
    e_and_l "$ERROR_TAG"
    add_full_log
  fi
}

###############################################################################
# Funktion zum Zurücksetzen der Auswahl der Paket-Kategorien
###############################################################################
function reset_categories_selection () {
  for k in ${KAT_KEY_LIST[@]};
  do
    KATEGORIE_FLAG[$k]=0
  done
}

###############################################################################
# Funktion zum Zurücksetzen und zur Initialisierung aller Optionen
# Parameter: Menü-Index (oder 0 für alle Einträge)
###############################################################################
function reset_options_selection () {
  for o in ${OPTION_LIST[@]};
  do
    if [ $1 -eq 0 ] ||
       [ $1 -eq ${OPTION_MENU[$o]} ];
    then
      OPTION_FLAG[$o]=0;
    fi
  done
}

###############################################################################
# Funktion zur Wiederherstellung einer Datei durch ihre Sicherheits-Kopie
###############################################################################
function restore_backup_file () {
  RESTORE_FILE_PATH="$1"
  if [ -f "$RESTORE_FILE_PATH.bak" ];
  then
    mv -f "$RESTORE_FILE_PATH.bak" "$RESTORE_FILE_PATH" &>/dev/null
  else
    if [ -f "$RESTORE_FILE_PATH.save" ];
    then
      mv -f "$RESTORE_FILE_PATH.save" "$RESTORE_FILE_PATH" &>/dev/null
    fi
  fi
}

###############################################################################
# Funktion zur Anzeige der Kopfzeile
###############################################################################
function show_headlines () {
  if [ ${OPTION_FLAG[nocolor]} -ne 1 ];
  then
    printf %b '\e]10;#eeeeee\a' # Schriftfarbe (VT100) immer hell ;)
    printf %b '\e]11;#242628\a' # Hintergrundfarbe (VT100) immer dunkel ;)
  fi
  clear
  HEADLINE_TEXT="${bold_white}${bg_blue}"
  HEADLINE_TEXT+="$FULLSPACE"$'\n'
  HEADLINE_TEXT+="                $HEADLINE_TITLE                "$'\n'
  HEADLINE_TEXT+="${light_blue}${bg_blue}"
  HEADLINE_TEXT+="                             by Michael G. | v$VERSION                              "$'\n'
  HEADLINE_TEXT+="$FULLSPACE"
  HEADLINE_TEXT+="${colors_off}"
  e_and_l "$HEADLINE_TEXT"
  if [ ${OPTION_FLAG[nocolor]} -ne 1 ]; then echo -e ""; fi
}

###############################################################################
# Funktion zur Darstellung von Zahlen in einem für Menschen lesbaren Format
# Da Bash nur Integer-Werte verarbeiten kann und grundsätzlich abrundet,
# müssen wir uns mit einem Trick auch noch um die richtige Rundung kümmern ;)
###############################################################################
function show_human_bytes () {
  THE_NUMBER=$1
  SIZE_FACTOR="$(echo -n $2 | tr '[:lower:]' '[:upper:]')"
  ONE_KB=$((1024))
  HALF_KB=$((ONE_KB / 2))
  ONE_MB=$((ONE_KB * 1024))
  HALF_MB=$((ONE_MB / 2))
  ONE_GB=$((ONE_MB * 1024))
  HALF_GB=$((ONE_GB / 2))
  ONE_TB=$((ONE_GB * 1024))
  HALF_TB=$((ONE_TB / 2))
  if [ $THE_NUMBER -ge $ONE_TB ] &&
     [ "$SIZE_FACTOR" != "G" ] &&
     [ "$SIZE_FACTOR" != "M" ] &&
     [ "$SIZE_FACTOR" != "K" ] &&
     [ "$SIZE_FACTOR" != "B" ];
  then
    ((THE_NUMBER+=HALF_TB))
    ((THE_NUMBER=THE_NUMBER/1024/1024/1024/1024))
    THE_NUMBER="${THE_NUMBER} TB"
  else
    if [ $THE_NUMBER -ge $ONE_GB ] &&
       [ "$SIZE_FACTOR" != "M" ] &&
       [ "$SIZE_FACTOR" != "K" ] &&
       [ "$SIZE_FACTOR" != "B" ];
    then
      ((THE_NUMBER+=HALF_GB))
      ((THE_NUMBER=THE_NUMBER/1024/1024/1024))
      THE_NUMBER="${THE_NUMBER} GB"
    else
      if [ $THE_NUMBER -ge $ONE_MB ] &&
         [ "$SIZE_FACTOR" != "K" ] &&
         [ "$SIZE_FACTOR" != "B" ];
      then
        ((THE_NUMBER+=HALF_MB))
        ((THE_NUMBER=THE_NUMBER/1024/1024))
        THE_NUMBER="${THE_NUMBER} MB"
      else
        if [ $THE_NUMBER -ge $ONE_KB ] &&
           [ "$SIZE_FACTOR" != "B" ];
        then
          ((THE_NUMBER+=HALF_KB))
          ((THE_NUMBER=THE_NUMBER/1024))
          THE_NUMBER="${THE_NUMBER} KB"
        else
          THE_NUMBER="${THE_NUMBER} B"
        fi
      fi
    fi
  fi
  echo "$THE_NUMBER"
}

###############################################################################
# Funktion zur formattierten Anzeige der laufenden Nummer
###############################################################################
function show_nr () {
  echo -n " "
  if [ $1 -lt 99 ]; then echo -n " "; fi
  if [ $1 -lt 9 ];  then echo -n " "; fi
  echo -n "$(($1 + 1)):"
}

###############################################################################
# Funktion zur Anzeige von übersprungenen Aktionen mit Ausgrauen des Textes
###############################################################################
function skip_text () {
  THE_SKIP_TEXT="$1"
  THE_SKIP_TEXT=${THE_SKIP_TEXT/ ... /}
  THE_SKIP_TEXT="$(clear_text "$THE_SKIP_TEXT") ... "
  if [ "$2" != "" ];
  then
    THE_SKIP_TEXT+="übersprungen ($2)"
  else
    THE_SKIP_TEXT+="wird übersprungen"
  fi
  echo -e "${dark_grey}${THE_SKIP_TEXT}${colors_off}"
}

###############################################################################
# Funktion zum Download mehrer "einfacher" Dateien (ohne die Erweiterungen
# für HTML-Webseiten einschließlich deren Verknüpfungen und Medien) von
# einem Server-Verzeichnis in einen lokalen Ordner.
# HINWEIS: Begrenzt auf ein Server-Verzeichnis ohne dessen Unterordner!
###############################################################################
function wget_dir () {
  REMOTE_SOURCE_DIR="$1"
  LOCAL_TARGET_DIR="$2"
  WGET_RESULT=1
  if [ "$LOCAL_TARGET_DIR" != "" ];
  then
    if [ ! -d "$LOCAL_TARGET_DIR" ]; then mkdir -p "$LOCAL_TARGET_DIR" &>/dev/null; fi
    if [ -d "$LOCAL_TARGET_DIR" ];
    then
      wget --recursive --directory-prefix="$LOCAL_TARGET_DIR" --execute robots=off --no-parent --level=1 --no-directories --timestamping --quiet --reject="index.html*" "$REMOTE_SOURCE_DIR"
      WGET_RESULT=$?
      # ---------------------------------------------------------------------------
      # Wichtige Parameter
      # ACHTUNG: Auf dem Server muss per .htaccess "Options +Indexes" gesetzt sein ;)
      # ---------------------------------------------------------------------------
      # --recursive                # Lädt mehrere Dateien und Ordner rekursiv herunter
      # --directory-prefix         # Zielverzeichnis
      # --execute robots=off       # Ignoriert die Angaben in der robots.txt des Servers
      # --user-agent="Mozilla/5.0" # Setzt eine Browser-Kennung (falls diese erforderlich ist)
      # --no-parent                # Verzweigt nicht in übergeordnete Ordner (./..)
      # --level=1                  # Begrenzt die Anzahl der Unterordner-Level (1=nur der aktuelle Ordner, also nicht rekursiv)
      # --no-directories           # Erzeugt keine Ordnerstruktur entsprechend dem URL-Pfad
      # --timestamping             # Nur Dateien holen, die neuer als die lokalen Dateien sind
      # --random-wait              # Wartet zwichen den Downloads der einzelnen Dateien (Verschleiereung der Automatisierung)
      # --quiet                    # Erzeugt keine Ausgabe wie den Download-Fortschritt
      # --reject="index.html*"     # Löscht die von wget beim Download angelegten internen "index.html*"-Dateien
      # ---------------------------------------------------------------------------
    fi
  fi
  return $WGET_RESULT
}

###############################################################################
# Start des Haupt-Teils
###############################################################################
# Listen zur Auswahl der Kategorien und Optionen initialisieren
reset_categories_selection
reset_options_selection 0

# -----------------------------------------------------------------------------
# Starter für uns selbst auf dem Desktop anlegen
# -----------------------------------------------------------------------------
STARTER_FILE="$DESKTOP_DIR/$SCRIPT_NAME.desktop"
if [ ! -s "$STARTER_FILE" ];
then
  echo -e ""
  echo -e ""
  e_and_l " $HINWEIS_TAG: Es scheint kein ${light_cyan}Starter${colors_off} für Lissy v$VERSION angelegt zu sein."
  ask_yes_or_no " Jetzt Starter (Symbol) auf dem Desktop anlegen"
  if [ $? -eq 1 ];
  then
    e_and_l -n " Erstelle Starter ... "
    echo -e "[Desktop Entry]" > "$STARTER_FILE" 2>/dev/null
    if [ $? -eq 0 ];
    then
      echo -e "Type=Application" >> "$STARTER_FILE" 2>/dev/null
      echo -e "Name=Lissy\\\n(Terminal)" >> "$STARTER_FILE" 2>/dev/null
      echo -e "Comment=Lissy im Terminal starten" >> "$STARTER_FILE" 2>/dev/null
      echo -e "Exec=bash -c 'cd $SCRIPT_PATH && sudo ./lissy;\$SHELL'" >> "$STARTER_FILE" 2>/dev/null
      echo -e "Icon=lissy" >> "$STARTER_FILE" 2>/dev/null
      echo -e "Categories=Application;" >> "$STARTER_FILE" 2>/dev/null
      echo -e "Terminal=true" >> "$STARTER_FILE" 2>/dev/null
      echo -e "StartupNotify=true" >> "$STARTER_FILE" 2>/dev/null
      echo -e "NoDisplay=false" >> "$STARTER_FILE" 2>/dev/null
      chown "$USER_USERNAME:$USER_USERNAME" "$STARTER_FILE" &>/dev/null
      chmod 0755 "$STARTER_FILE" &>/dev/null
      e_and_l "$OK_TAG"
    else
      e_and_l "$ERROR_TAG"
    fi
  fi
fi
# -----------------------------------------------------------------------------
# Aktuelles Icon für den Starter downloaden
# -----------------------------------------------------------------------------
download_icon_file "lissy"
echo -e ""

# -----------------------------------------------------------------------------
# Laufzeit-Parameter ermitteln
# Reihenfolge: 1. Einlesen der Konfigurations-Datei
#              2. Analyse der Kommandozeilen-Argumente
#              3. Menü (Dialog)
# -----------------------------------------------------------------------------
NO_MENU=0

# ---------------------------------------------------
# 1. Individuell gespeicherte Konfigurations-Dateien
# ---------------------------------------------------
# Einstellungen
if [ -s "$USER_SCRIPT_CONFIG" ];
then
  . "$USER_SCRIPT_CONFIG"
fi
# Paket-Listen und Skip-Liste
if [ -s "$USER_PAKET_LIST" ];
then
  . "$USER_PAKET_LIST"
  # ACHTUNG: Die Skip-Liste in der Datei USER_PAKET_LIST ist eine Text-Zeile,
  # die vor der Verarbeitung in eine "echte" Liste umgewandelt werden muss:
  if [ "$SKIP_LIST" != "" ];
  then
    SKIP_LIST=(${SKIP_LIST})
  fi
else
  SKIP_LIST=()
fi

# ---------------------------------------------------------------------
# 2. Als Kommandozeilen-Argumente angegebene Paketauswahl und Optionen
# ---------------------------------------------------------------------
ARGUMENT_LIST=()
for arg in $@;
do
  arg=$(printf %b "${arg}" | tr A-Z a-z)
  ARGUMENT_LIST+=("$arg")
done
ARG_ANZ=${#ARGUMENT_LIST[@]}
# -------------------------------------------------------------
# 2.1 Ermitteln ob ein einzelnes Paket installiert werden soll
# -------------------------------------------------------------
ARG_POS=1
INST_ONLY_PKG=""
for arg in ${ARGUMENT_LIST[@]};
do
  # Erstes Argument hinter "instonly" als zu installierendes Paket ermitteln
  ((ARG_POS+=1))
  if [ "$arg" = "instonly" ];
  then
    INST_ONLY_PKG=$(echo "${!ARG_POS}" | sed -E 's/[^A-Za-z0-9\.\_\-]//g' | tr A-Z a-z | xargs)
  fi
done
# -------------------------------------------------------------
# 2.2 Ermitteln ob ein einzelnes Paket entfernt werden soll
# -------------------------------------------------------------
ARG_POS=1
OPTION_FLAG[remove]=0
REMOVE_PKG_NAME=""
for arg in ${ARGUMENT_LIST[@]};
do
  # Erstes Argument hinter "remove" als zu installierendes Paket ermitteln
  ((ARG_POS+=1))
  if [ "$arg" = "remove" ];
  then
    REMOVE_PKG_NAME=$(echo "${!ARG_POS}" | sed -E 's/[^A-Za-z0-9\.\_\-]//g' | tr A-Z a-z | xargs)
    if [ "$REMOVE_PKG_NAME" != "" ];
    then
      OPTION_FLAG[remove]=1
    fi
  fi
done
# -----------------------------------------------------------------------------------
# 2.3 Auswahl (+) der Kategorien (nur wenn kein individuelles Paket angegeben wurde)
# -----------------------------------------------------------------------------------
if [ "$INST_ONLY_PKG" = "" ];
then
  # Zunächst auf die Option "all" prüfen
  for arg in ${ARGUMENT_LIST[@]};
  do
    if [ "$arg" = "all" ] ||
       [ "$arg" = "+all" ];
    then
      for k in ${KAT_KEY_LIST[@]};
      do
        KATEGORIE_FLAG[$k]=1
      done
      # "all" beinhaltet jedoch nicht die individuellen Desktop-Tools
      KATEGORIE_FLAG[gx]=0
      KATEGORIE_FLAG[lx]=0
      KATEGORIE_FLAG[mt]=0
      KATEGORIE_FLAG[mx]=0
      KATEGORIE_FLAG[xx]=0
    fi
  done
  # Danach "restliche" bzw. individuelle Kategorie-Auswahl (+) einlesen
  # (Nach "all", damit die Desktop-Tools separat ausgewählt werden können)
  for arg in ${ARGUMENT_LIST[@]};
  do
    for k in ${KAT_KEY_LIST[@]};
    do
      if [ "$arg" = "+$k" ];
      then
        KATEGORIE_FLAG["$k"]=1
        break
      fi
    done
  done
fi
# ------------------------------------------------------------------
# 2.4 Abwahl (-) der Kategorien sowie ggf. zu überspringende Pakete
# ------------------------------------------------------------------
# Liste der Argumente (Parameter) erzeugen, welche die Auflistung
# der auszulassenden Pakete nach dem Argumente "skip" unterbrechen
SKIP_BREAK_ARGS=()
for k in ${KAT_KEY_LIST[@]}
do
  SKIP_BREAK_ARGS+=("+$k")
  SKIP_BREAK_ARGS+=("-$k")
done
SKIP_BREAK_ARGS+=("+all" "all")
for opt in ${OPTION_LIST[@]}
do
  SKIP_BREAK_ARGS+=("$opt")
done
SKIP_BREAK_ARGS+=("nomenu")
# -----------------------------
ARG_POS=1
for arg in ${ARGUMENT_LIST[@]};
do
  # Alle Argumente hinter "skip" bis zu einem anderen gültigen Argument (siehe
  # SKIP_BREAK_ARGS) als auszulassendes Paket in die Skip-Liste übernehmen
  if [ "$arg" = "skip" ];
  then
    BREAK_FOUND=0
    s=$((ARG_POS+1))
    while [ $s -le $ARG_ANZ ] && [ $BREAK_FOUND -eq 0 ]
    do
      ARG_TXT=$(printf %b "${!s}" | tr A-Z a-z)
      for exclude_arg in ${SKIP_BREAK_ARGS[@]};
      do
        if [ "$ARG_TXT" = "$exclude_arg" ];
        then
          BREAK_FOUND=1
          break
        fi
      done
      if [ $BREAK_FOUND -eq 0 ];
      then
        # Bereits in der Skip-Liste vorhandene Pakete nicht nochmals aufnehmen
        IS_ALREADY_SKIPPED=0
        for skipped_pkg in ${SKIP_LIST[@]};
        do
          if [ "$skipped_pkg" = "$ARG_TXT" ];
          then
            IS_ALREADY_SKIPPED=1
            break
          fi
        done
        if [ $IS_ALREADY_SKIPPED -eq 0 ];
        then
          SKIP_LIST=("${SKIP_LIST[@]}" "$ARG_TXT")
        fi
      fi
      ((s+=1))
    done
  else # ... sonst - sofern das Argument eine Kategorie ist - diese abwählen
    for k in ${KAT_KEY_LIST[@]};
    do
      if [ "$arg" = "-$k" ];
      then
        KATEGORIE_FLAG["$k"]=0
        break
      fi
    done
  fi
  ((ARG_POS+=1))
done

# -------------
# 2.5 Optionen
# -------------
for arg in ${ARGUMENT_LIST[@]};
do
  for opt in ${OPTION_LIST[@]};
  do
    if [ "$arg" = "$opt" ];
    then
      OPTION_FLAG["$opt"]=1
      break
    fi
  done
  # Sonderfälle
  if [ "$arg" = "nomenu" ]; then NO_MENU=1; fi # "nomenu" ist natürlich nicht im Menü enthalten
  if [ "$arg" = "kuplock" ] && [ $KERNEL_IS_LOCKED -gt 0 ]; then OPTION_FLAG[kuplock]=0; fi
  if [ "$arg" = "kunlock" ] && [ $KERNEL_IS_LOCKED -eq 0 ]; then OPTION_FLAG[kunlock]=0; fi
done

# Sonderfall Quiet-Modus, der aus Sicherheitsgründen aktuell immer deaktiviert ist!
OPTION_FLAG[quiet]=0

# --------------------------------------------------------------------------
# NACH der Kommandozeilen-Analyse und VOR dem Menü (damit folgende Funktion
# vom Benutzer mit "noupdate" übersprungen werden kann) die neueste Version
# von diesem Script runterladen, prüfen und ggf. zur Verwendung einrichten
# --------------------------------------------------------------------------
if [ ${OPTION_FLAG[noupdate]} -eq 0 ];
then
  LOCAL_DOWNLOAD_FILE="./$SCRIPT_NAME.new"
  wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$THIS_SCRIPT_URL" &>/dev/null
  if [ $? -eq 0 ] &&
     [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
     [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
  then
    chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
    chmod a+x "$LOCAL_DOWNLOAD_FILE" &>/dev/null
    NEW_VERSION=$(cat "$LOCAL_DOWNLOAD_FILE" | grep -i -E "^\s*version=" | sed -E "s/^\s*version=//i" | sed -E "s/\"//g" | xargs)
    if [ "$VERSION" != "$NEW_VERSION" ];
    then
      show_headlines
      e_and_l " Version ${light_yellow}$NEW_VERSION${colors_off} ist verfügbar. Es wird empfohlen, die neue Version zu verwenden."
      ask_yes_or_no " Alte Version sichern und neue Version verwenden" "$LOCAL_DOWNLOAD_FILE"
      if [ $? -eq 1 ];
      then
        mv "${0}" "${0}.bak" &>/dev/null
        if [ $? -eq 0 ];
        then
          e_and_l " Alte Version gesichert als ${bold_purple}${0}.bak${colors_off}"
          if [ -s "$USER_PAKET_LIST" ];
          then
            e_and_l " $ACHTUNG_TAG: Es sind individuell angepasste Paket-Listen/Kategorien gespeichert."
            e_and_l " Dadurch werden die in den Kategorien eventuell neu hinzu gekommenen sowie"
            e_and_l " weggefallenen Programmpakete bei diesen Kategorien nicht berücksichtigt."
            ask_yes_or_no " Individuelle Listen sichern und neue Listen verwenden"
            if [ $? -eq 1 ];
            then
              mv "$USER_PAKET_LIST" "$USER_PAKET_LIST.bak" &>/dev/null
              if [ $? -eq 0 ];
              then
                e_and_l " Alte Listen gesichert in ${bold_purple}$USER_PAKET_LIST.bak${colors_off}"
              fi
            fi
          fi
          mv "$LOCAL_DOWNLOAD_FILE" "${0}"
          if [ $? -eq 0 ];
          then
            e_and_l " ${bold_white}$SCRIPT_NAME${colors_off} wurde aktualisiert und beendet - bitte jetzt neu aufrufen ... $OK_TAG"
          else
            e_and_l " $ERROR_TAG: Die Aktualisierung konnte leider ${bold_red}nicht${colors_off} korrekt durchgeführt werden."
            e_and_l " Zum Überspringen der Aktualisierung bitte die Option ${light_cyan}noupdate${colors_off} verwenden."
          fi
          exit 0
        else
          e_and_l "$ERROR_TAG: Sicherung konnte nicht angelegt werden"
        fi
      else
        remove_file "$LOCAL_DOWNLOAD_FILE"
      fi
      e_and_l "$FULL_LINE"
    else
      remove_file "$LOCAL_DOWNLOAD_FILE"
    fi
  else
    remove_file "$LOCAL_DOWNLOAD_FILE"
  fi
fi

# -----------------------------------------------------------------------------
# 3. Auswahlmenü anzeigen
# -----------------------------------------------------------------------------
if [ $SHOW_HELP -eq 0 ] &&
   [ $NO_MENU -eq 0 ];
then
  # "dialog" installieren, wenn es das noch nicht ist
  if [ $(LANG=en dpkg-query -W -f='${Status}' "dialog" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
  then
    if [ $(apt list "dialog" 2>/dev/null | grep -i -c -E "dialog") -gt 0 ];
    then
      # e_and_l ""
      # e_and_l -n " Installiere \"dialog\", bitte warten ... "
      do_log -n " Installiere dialog ... "
      apt install "dialog" -y &>/dev/null
      if [ $? -eq 0 ];
      then
        do_log "ok"
      else
        do_log "Fehler"
        NO_MENU=1
      fi
    else
      NO_MENU=1
    fi
  fi
  # Menü nur anzeigen, wenn "dialog" verfügbar ist
  if [ $NO_MENU -eq 0 ];
  then
    MENU_TITLE="    ────── $HEADLINE_TITLE v $VERSION ──────"
    DIALOG_RC_FILE="$DOWNLOAD_DIR/dialogrc"
    # Konfigurations-Datei für "dialog" anlegen, wenn es noch keine gibt
    REMOVE_DIALOG_RC=0
    if [ ! -f "$DIALOG_RC_FILE" ];
    then
# ---------------------------------------------
cat > "$DIALOG_RC_FILE" <<EOF
aspect = 0
separate_widget = ""
tab_len = 0
visit_items = OFF
use_shadow = ON
use_colors = ON
screen_color = (WHITE,BLUE,OFF)
shadow_color = (BLACK,BLACK,OFF)
dialog_color = (BLACK,WHITE,ON)
title_color = (BLUE,WHITE,ON)
border_color = (WHITE,WHITE,OFF)
button_active_color = (WHITE,WHITE,OFF)
button_inactive_color = (WHITE,WHITE,OFF)
button_key_active_color = (WHITE,BLUE,ON)
button_key_inactive_color = (BLACK,WHITE,ON)
button_label_active_color = (WHITE,BLUE,ON)
button_label_inactive_color = (BLACK,WHITE,ON)
inputbox_color = (WHITE,BLUE,ON)
inputbox_border_color = (BLACK,WHITE,OFF)
searchbox_color = (BLACK,WHITE,OFF)
searchbox_title_color = (BLUE,WHITE,ON)
searchbox_border_color = (WHITE,WHITE,ON)
position_indicator_color = (BLUE,WHITE,ON)
menubox_color = (BLACK,WHITE,OFF)
menubox_border_color = (WHITE,WHITE,ON)
item_color = (BLACK,WHITE,ON)
item_selected_color = (WHITE,BLUE,ON)
tag_color = (BLACK,WHITE,ON)
tag_selected_color = (WHITE,BLUE,ON)
tag_key_color = (BLACK,WHITE,ON)
tag_key_selected_color = (WHITE,BLUE,ON)
check_color = (BLACK,WHITE,ON)
check_selected_color = (WHITE,BLUE,ON)
uarrow_color = (BLUE,WHITE,ON)
darrow_color = (BLUE,WHITE,ON)
itemhelp_color = (YELLOW,BLACK,OFF)
form_active_text_color = (WHITE,BLUE,ON)
form_text_color = (WHITE,CYAN,ON)
form_item_readonly_color = (CYAN,WHITE,ON)
EOF
# ---------------------------------------------
      if [ $? -eq 0 ];
      then
        chown "$USER_USERNAME:$USER_USERNAME" "$DIALOG_RC_FILE" &>/dev/null
        REMOVE_DIALOG_RC=1
      fi
    fi
    if [ -f "$DIALOG_RC_FILE" ];
    then
      export DIALOGRC="$DIALOG_RC_FILE"
    fi
    clear
    setterm -cursor off 2>/dev/null
    # -------------------------------------
    # Hinweis falls kein Ubuntu / Raspbian
    # -------------------------------------
    if [ $IS_DEBIAN -eq 0 ];
    then
      MENU_ERROR_TEXT="\Z5\ZbAchtung\Zn: Dieses Tool ist nicht für dieses Betriebssystem entwickelt worden.\nDie Benutzung erfolgt auf eigene Gefahr!"
      dialog --backtitle "$MENU_TITLE" --defaultno --no-mouse --no-lines --no-shadow --colors --msgbox "$MENU_ERROR_TEXT" 7 50 3>&1 1>&2 2>&3
    fi
    dialog --clear
    clear
    MAIN_MENU_HELP="[Enter]=Auswahl [ESC]=Ende"
    SUB_MENU_HELP="[Leertaste]=Auswahl [Enter]=Bestätigen"
    # --------------------------------------------
    # Überschriften der Seite und der Menü-Punkte
    # --------------------------------------------
    declare -A MENU_NAME
    MENU_NAME[0]="Individuelles Programmpaket installieren"
    MENU_NAME[1]="Auswahl der zu installierenden Kategorien"
    MENU_NAME[2]="Optionen zur Installation von Paketen"
    MENU_NAME[3]="Programmpaket wahlweise mit Daten löschen"
    MENU_NAME[4]="Erweiterungen und optionale Aktionen"
    MENU_NAME[5]="Einstellungen des Programms"
    # --------------------------------------------
    MENU_OK=1
    while [ $MENU_OK -ne 0 ];
    do
      MENU_AUSWAHL=-1
      if [ "$INST_ONLY_PKG" = "" ];
      then
        LAST_MENU_AUSWAHL=6
      else
        LAST_MENU_AUSWAHL=0
      fi
      while [ $MENU_AUSWAHL -lt 7 ];
      do
        # ---------------------------------------------------------------------
        # Hauptmenü
        # ACHTUNG: Bei Änderung der Reihenfolge auch die Zuordnung von
        #          OPTION_MENU zu MENU_AUSWAHL anpassen!
        # ---------------------------------------------------------------------
        IND_PKG_I_STAR=""
        if [ "$INST_ONLY_PKG" != "" ]; then IND_PKG_I_STAR=" +"; fi
        IND_PKG_R_STAR=""
        if [ "$REMOVE_PKG_NAME" != "" ]; then IND_PKG_R_STAR=" +"; fi
         MAIN_MENU_LIST=(0 "${MENU_NAME[0]}$IND_PKG_I_STAR" "$MAIN_MENU_HELP")
        MAIN_MENU_LIST+=(1 "${MENU_NAME[1]}" "$MAIN_MENU_HELP")
        MAIN_MENU_LIST+=(2 "${MENU_NAME[2]}" "$MAIN_MENU_HELP")
        MAIN_MENU_LIST+=(3 "${MENU_NAME[3]}$IND_PKG_R_STAR" "$MAIN_MENU_HELP")
        MAIN_MENU_LIST+=(4 "${MENU_NAME[4]}" "$MAIN_MENU_HELP")
        MAIN_MENU_LIST+=(5 "${MENU_NAME[5]}" "$MAIN_MENU_HELP")
        MAIN_MENU_LIST+=(6 "──────────────────" "Bitte oben gewünschte Aktion(en) auswählen und dann die Ausführung starten")
        MAIN_MENU_LIST+=(7 "Ausführung starten" "$MAIN_MENU_HELP")
        MENU_AUSWAHL=$(dialog --backtitle "$MENU_TITLE" --item-help --default-item "$LAST_MENU_AUSWAHL" --no-tags --no-ok --no-cancel --no-mouse --no-lines --no-shadow --colors --menu "\Z4\Zb Hauptmenü\Zn" 0 0 0 "${MAIN_MENU_LIST[@]}" 3>&1 1>&2 2>&3)
        if [ $? -ne 0 ]; then MENU_AUSWAHL=-1; fi
        MENU_AUSWAHL=$(echo "$MENU_AUSWAHL" | sed -E 's/[^0-9\-]//g' | xargs)
        LAST_MENU_AUSWAHL="$MENU_AUSWAHL"
        dialog --clear
        clear
        # ---------------------------------------------------------------------
        # Eingabe eines individuellen Pakets
        # ---------------------------------------------------------------------
        if [ $MENU_AUSWAHL -eq 0 ];
        then
          setterm -cursor on 2>/dev/null
          NEW_INST_ONLY=$(dialog --backtitle "$MENU_TITLE" --no-mouse --no-lines --no-shadow --colors --inputbox "Name des zu installierenden Pakets:" 8 50 "$INST_ONLY_PKG" 3>&1 1>&2 2>&3)
          if [ $? -eq 0 ];
          then
            INST_ONLY_PKG=$(echo "$NEW_INST_ONLY" | tr A-Z a-z | sed -E 's/[^a-z0-9\.\_\-]//g' | xargs)
            if [ "$INST_ONLY_PKG" != "" ];
            then
              OPTION_FLAG[instonly]=1
            else
              OPTION_FLAG[instonly]=0
            fi
          fi
          setterm -cursor off 2>/dev/null
          dialog --clear
          clear
        fi
        # ---------------------------------------------------------------------
        # Auswahl der Paket-Kategorien
        # ---------------------------------------------------------------------
        if [ $MENU_AUSWAHL -eq 1 ];
        then
          if [ "$INST_ONLY_PKG" = "" ];
          then
            ANZ_KATEGORIES=0
            KAT_MENU_LIST=()
            for k in ${KAT_ORD_LIST[@]};
            do
              KAT_MENU_LIST+=("$k" "${KATEGORIE_TEXT[$k]}")
              if [ ${KATEGORIE_FLAG[$k]} -eq 1 ];
              then
                KAT_MENU_LIST+=("on")
              else
                KAT_MENU_LIST+=("off")
              fi
              KAT_MENU_LIST+=("Kommandozeilen-Parameter: $k $SUB_MENU_HELP")
              ((ANZ_KATEGORIES+=1))
            done
            # -------------------------------------------------
            # Auswahlliste der Kategorien anzeigen
            # -------------------------------------------------
            SELECT_AUSWAHL=$(dialog --backtitle "$MENU_TITLE" --item-help --no-tags --no-cancel --no-mouse --no-lines --no-shadow --output-separator " " --colors --checklist "\Z4\Zb ${MENU_NAME[$MENU_AUSWAHL]}\Zn" 0 0 ${ANZ_KATEGORIES} "${KAT_MENU_LIST[@]}" 3>&1 1>&2 2>&3)
            # -------------------------------------------------
            # Alte Kategorie-Auswahl löschen und neue einlesen
            # -------------------------------------------------
            if [ $? -eq 0 ];
            then
              reset_categories_selection
              for k in ${SELECT_AUSWAHL[@]};
              do
                KATEGORIE_FLAG[$k]=1
              done
            fi
          else
            MENU_ERROR_TEXT="Bei Auswahl eines individuellen Pakets können keine weiteren Pakete mehr ausgewählt werden."
            dialog --backtitle "$MENU_TITLE" --defaultno --no-mouse --no-lines --no-shadow --colors --msgbox "$MENU_ERROR_TEXT" 8 50 3>&1 1>&2 2>&3
          fi
          dialog --clear
          clear
        fi
        # ---------------------------------------------------------------------
        # Eingabe eines Paket-Namens zur Deinstallation und Bereinigung
        # ---------------------------------------------------------------------
        if [ $MENU_AUSWAHL -eq 3 ];
        then
          setterm -cursor on 2>/dev/null
          NEW_REMOVE_PKG=$(dialog --backtitle "$MENU_TITLE" --no-mouse --no-lines --no-shadow --colors --inputbox "Name des zu löschenden Pakets:" 8 50 "$REMOVE_PKG_NAME" 3>&1 1>&2 2>&3)
          if [ $? -eq 0 ];
          then
            REMOVE_PKG_NAME=$(echo "$NEW_REMOVE_PKG" | tr A-Z a-z | sed -E 's/[^a-z0-9\.\_\-]//g' | xargs)
            if [ "$REMOVE_PKG_NAME" != "" ];
            then
              OPTION_FLAG[remove]=1
            else
              OPTION_FLAG[remove]=0
            fi
          fi
          setterm -cursor off 2>/dev/null
          dialog --clear
          clear
        fi
        # ---------------------------------------------------------------------
        # Optionen
        # ---------------------------------------------------------------------
        if [ $MENU_AUSWAHL -eq 2 ] ||
           [ $MENU_AUSWAHL -eq 4 ] ||
           [ $MENU_AUSWAHL -eq 5 ];
        then
          # -------------------------------------------------------------------
          # Liste der Optionen erzeugen und nach (Vor-)Einstellung aktivieren
          # -------------------------------------------------------------------
          ANZ_OPTIONS=0
          OPT_MENU_LIST=()
          for i in ${OPTION_LIST[@]};
          do
            if [ $MENU_AUSWAHL -eq ${OPTION_MENU[$i]} ];
            then
              THE_OPT_TEXT="${OPTION_TEXT[$i]}"
              OPT_MENU_LIST+=("$i" "$THE_OPT_TEXT")
              if [ ${OPTION_FLAG[$i]} -eq 1 ];
              then
                OPT_MENU_LIST+=("on")
              else
                OPT_MENU_LIST+=("off")
              fi
              OPT_MENU_LIST+=("Kommandozeilen-Parameter: $i $SUB_MENU_HELP")
              ((ANZ_OPTIONS+=1))
            fi
          done
          # -----------------------------------
          # Auswahlliste der Optionen anzeigen
          # -----------------------------------
          SELECT_MENU_TILE="${MENU_NAME[$MENU_AUSWAHL]}"
          SELECT_AUSWAHL=$(dialog --backtitle "$MENU_TITLE" --item-help --no-tags --no-cancel --no-mouse --no-lines --no-shadow --output-separator " " --colors --checklist "\Z4\Zb $SELECT_MENU_TILE\Zn" 0 0 ${ANZ_OPTIONS} "${OPT_MENU_LIST[@]}" 3>&1 1>&2 2>&3)
          # -------------------------------------------------
          # Alte Options-Auswahl löschen und neue einlesen
          # -------------------------------------------------
          if [ $? -eq 0 ];
          then
            reset_options_selection $MENU_AUSWAHL
            for thekey in ${SELECT_AUSWAHL[@]};
            do
              OPTION_FLAG[$thekey]=1
            done
          fi
          dialog --clear
          clear
        fi
        # ---------------------------------------------------------------------
        # Escape im Hauptmenü
        # ---------------------------------------------------------------------
        if [ $MENU_AUSWAHL -lt 0 ];
        then
          dialog --backtitle "$MENU_TITLE" --defaultno --no-mouse --no-lines --no-shadow --yesno "Programm beenden?" 0 0 3>&1 1>&2 2>&3
          if [ $? -eq 0 ];
          then
            exit_from_menu
            clean_on_exit
            echo -e ""
            echo -e " Auf Wiedersehen ..."
            exit 0
          fi
        fi
        # ---------------------------------------------------------------------
      done

      # -----------------------------------------------------------------------
      # Auswahl auf Konflikte prüfen
      # -----------------------------------------------------------------------
      ANZ_KATEGORIES=0
      for k in ${KAT_KEY_LIST[@]};
      do
        if [ ${KATEGORIE_FLAG[$k]} -eq 1 ];
        then
          ((ANZ_KATEGORIES+=1))
        fi
      done
      MENU_INFO_TEXT=""
      MENU_ERROR_TEXT=""
      # Konflikt dload und dsave
      if [ ${OPTION_FLAG[dload]} -eq 1 ] &&
         [ ${OPTION_FLAG[dsave]} -eq 1 ];
      then
        MENU_ERROR_TEXT="\Z1\ZbFEHLER\Zn\nDie Aktionen \Z1dload\Z0 und \Z1dsave\Z0 können nicht gemeinsam durchgeführt werden."
      fi
      # Konflikt noinfo und infoonly
      if [ ${OPTION_FLAG[infoonly]} -eq 1 ];
      then
        if [ ${OPTION_FLAG[noinfo]} -eq 1 ];
        then
          MENU_ERROR_TEXT="\Z1\ZbFEHLER\Zn\nDie Optionen \Z1noinfo\Z0 und \Z1infoonly\Z0 können nicht gemeinsam angewendet werden."
        else
          MENU_INFO_TEXT="\Z5\ZbAchtung\Zn: Bei Verwendung der Option \Z4infoonly\Z0 werden keine weiteren Aktionen durchgeführt!"
        fi
      fi
      # Konflikt listonly ohne Kategorien
      if [ ${OPTION_FLAG[listonly]} -eq 1 ];
      then
        if [ $ANZ_KATEGORIES -eq 0 ];
        then
          MENU_ERROR_TEXT="\Z1\ZbFEHLER\Zn\nDie Option \Z4listonly\Z0 wurde ausgewählt, aber keine Pakete (Kategorie) zur Auflistung."
        else
          if [ ${OPTION_FLAG[status]} -eq 1 ];
          then
            MENU_INFO_TEXT="\Z5\ZbAchtung\Zn: Durch die Option \Z4listonly\Z0 wird der Paketstatus (Option \Z4status\Z0) nicht angezeigt."
          else
            MENU_INFO_TEXT="\Z5\ZbAchtung\Zn: Bei Verwendung der Option \Z4listonly\Z0 werden keine weiteren Aktionen durchgeführt!"
          fi
        fi
      fi
      # Konflikt Installation von Paketen fremder Desktops
      if [ ${OPTION_FLAG[status]} -eq 0 ];
      then
        if [[ ${KATEGORIE_FLAG[gx]} -eq 1 && "$DESKTOP_ENVIRONMENT" != "GNOME" ]] ||
           [[ ${KATEGORIE_FLAG[lx]} -eq 1 && "$DESKTOP_ENVIRONMENT" != "LXDE"  ]] ||
           [[ ${KATEGORIE_FLAG[mt]} -eq 1 && $(echo "$OPERATION_SYSTEM" | grep -i -c -E " mint ") -eq 0  ]] ||
           [[ ${KATEGORIE_FLAG[mx]} -eq 1 && "$DESKTOP_ENVIRONMENT" != "MATE"  ]] ||
           [[ ${KATEGORIE_FLAG[xx]} -eq 1 && "$DESKTOP_ENVIRONMENT" != "XFCE"  ]];
        then
          MENU_INFO_TEXT="\Z1\ZbWarnung\Zn: Es wurden Tool-Pakete ausgewählt, die nicht für diesen Desktop vorgesehen sind."
        fi
      fi
      # Konflikt "nichts zu tun"
      if ! ready_for_action;
      then
        MENU_ERROR_TEXT="\Z4\ZbNicht so schnell\Zn\nEs ist noch keine Aktion ausgewählt, die ich sinnvoll bearbeiten könnte ..."
      fi
      # Wenn bei der Auswahl ein Konflikt aufgetreten ist, Meldung dazu anzeigen
      if [ "$MENU_ERROR_TEXT" != "" ];
      then
        dialog --backtitle "$MENU_TITLE" --defaultno --no-mouse --no-lines --no-shadow --colors --msgbox "$MENU_ERROR_TEXT" 8 50 3>&1 1>&2 2>&3
      else # ... sonst abschließende Sicherheitsabfrage anzeigen
        CONTINUE_QUESTION=""
        if [ "$MENU_INFO_TEXT" != "" ];
        then
          CONTINUE_QUESTION+="$MENU_INFO_TEXT\n"
          CONTINUE_TROTZDEM=" trotzdem"
        else
          CONTINUE_QUESTION+="Ich bin bereit. "
          CONTINUE_TROTZDEM=""
        fi
        CONTINUE_QUESTION+="Soll ich die Ausführung jetzt$CONTINUE_TROTZDEM mit den eingestellten Parametern starten?"
        dialog --backtitle "$MENU_TITLE" --no-mouse --no-lines --no-shadow --colors --yesno "$CONTINUE_QUESTION" 8 50 3>&1 1>&2 2>&3
        MENU_OK=$?
      fi
    done
    exit_from_menu
  fi
fi

if [ "$INST_ONLY_PKG" != "" ];
then
  reset_categories_selection
fi

# -----------------------------------------------------------------------------
# Kommandozeilen-Aufruf mit Parametern erstellen
# -----------------------------------------------------------------------------
COMMAND_LINE_STRING=""
if [ "$INST_ONLY_PKG" != "" ];
then
  # Individuelles Paket
  COMMAND_LINE_STRING+=" instonly $INST_ONLY_PKG"
else
  # Kategorien
  for i in ${KAT_KEY_LIST[@]};
  do
    if [ ${KATEGORIE_FLAG[$i]} -eq 1 ];
    then
      COMMAND_LINE_STRING+=" +$i"
    fi
  done
fi
# Optionen
for i in ${OPTION_LIST[@]};
do
  if [ ${OPTION_FLAG[$i]} -eq 1 ];
  then
    COMMAND_LINE_STRING+=" $i"
  fi
done
# Skip-Liste
if [ ${#SKIP_LIST[@]} -ne 0 ];
then
  i=0
  for skip_this_pkg in ${SKIP_LIST[@]};
  do
    if [ $i -eq 0 ] &&
       [ "$skip_this_pkg" != "" ];
    then
      COMMAND_LINE_STRING+=" skip"
    fi
    COMMAND_LINE_STRING+=" $skip_this_pkg"
    ((i+=1))
  done
fi
# Paket entfernen
if [ "$REMOVE_PKG_NAME" != "" ];
then
  COMMAND_LINE_STRING+=" remove $REMOVE_PKG_NAME"
fi
COMMAND_LINE_STRING=$(echo $COMMAND_LINE_STRING | tr A-Z a-z)

# -----------------------------------------------------------------------------
# Einstellungen speichern
# -----------------------------------------------------------------------------
if [ ${OPTION_FLAG[saveconf]} -eq 1 ];
then

  SCRIPT_CONFIG_HEADLINE="Konfigurations-Datei für $SCRIPT_NAME"'\n'

  # Konfiguration (Ausgewählte Kategorien und Optionen)
  echo -e "# $SCRIPT_CONFIG_HEADLINE" > "$USER_SCRIPT_CONFIG" 2>/dev/null
  echo -e "# Kategorien" >> "$USER_SCRIPT_CONFIG" 2>/dev/null
  for k in ${KAT_KEY_LIST[@]};
  do
    echo -e "KATEGORIE_FLAG[$k]=${KATEGORIE_FLAG[$k]}" >> "$USER_SCRIPT_CONFIG" 2>/dev/null
  done
  echo -e "" >> "$USER_SCRIPT_CONFIG" 2>/dev/null
  echo -e "# Optionen" >> "$USER_SCRIPT_CONFIG" 2>/dev/null
  for o in ${OPTION_LIST[@]};
  do
    echo -e "OPTION_FLAG[$o]=${OPTION_FLAG[$o]}" >> "$USER_SCRIPT_CONFIG" 2>/dev/null
  done
  chown "$USER_USERNAME:$USER_USERNAME" "$USER_SCRIPT_CONFIG" &>/dev/null

  # Paket-Listen und Skip-Liste
  echo -e "# $SCRIPT_CONFIG_HEADLINE" > "$USER_PAKET_LIST" 2>/dev/null
  echo -e "# Paket-Listen" >> "$USER_PAKET_LIST" 2>/dev/null
  for k in ${KAT_KEY_LIST[@]};
  do
    echo -e "KATEGORIE_PKGS[$k]=\"${KATEGORIE_PKGS[$k]}\"" >> "$USER_PAKET_LIST" 2>/dev/null
  done
  echo -e "" >> "$USER_PAKET_LIST" 2>/dev/null
  echo -e "# Skip-Liste" >> "$USER_PAKET_LIST" 2>/dev/null
  echo -e "SKIP_LIST=\"${SKIP_LIST[@]}\"" >> "$USER_PAKET_LIST" 2>/dev/null
  chown "$USER_USERNAME:$USER_USERNAME" "$USER_PAKET_LIST" &>/dev/null

fi

# -------------------------------------------------------
# Farb-Definitionen löschen, wenn keine Farben erwünscht
# -------------------------------------------------------
if [ ${OPTION_FLAG[nocolor]} -eq 1 ];
then
  COL_VAR_LIST=(black red green yellow blue purple cyan white
                dark_grey light_red light_green light_yellow light_blue light_purple light_cyan light_grey
                bold_black bold_red bold_green bold_yellow bold_blue bold_purple bold_cyan bold_white
                uline_black uline_red uline_green uline_yellow uline_blue uline_purple uline_cyan uline_white
                bg_black bg_red bg_green bg_yellow bg_blue bg_purple bg_cyan bg_white
                colors_off colors_invers line_color)
  for i in ${COL_VAR_LIST[@]};
  do
    declare $i="" # Besser als eval "${i}=''"
  done
fi

# Ab GNOME 3 keine Icons mehr auf dem Desktop erstellen
if [ $GNOME_PLATFORM -gt 2 ]; then OPTION_FLAG[addicons]=0; fi

###############################################################################
# Log-Datei eröffnen und Kopfzeile anzeigen
###############################################################################
if [ ${OPTION_FLAG[logfull]} -eq 1 ]; then OPTION_FLAG[log]=1; fi
if [ ${OPTION_FLAG[log]} -eq 1 ]; then echo -n "" > "$LOG_FILE"; fi
show_headlines

if [ ${OPTION_FLAG[log]} -eq 1 ];
then
  do_log "$FULL_LINE"
  do_log " $SCRIPT_NAME Log $(date +%d.%m.%Y) $(date +%H:%M:%S)"
  do_log "$FULL_LINE"
  PARAMETER="$@"
  PARAMETER=$(printf %b "${PARAMETER}" | tr A-Z a-z)
  do_log " Aufruf : ${PARAMETER[@]}"
  do_log " Auswahl: $COMMAND_LINE_STRING"
  do_log "$FULL_LINE"
fi

###############################################################################
# Wenn keine ausführbare Auswahl erfolgt ist (kein Paket und keine Option)
# oder die Hilfe explizit angefordert wurde, dann Programm-Syntax anzeigen
###############################################################################
if ! ready_for_action ||
   [ $SHOW_HELP -eq 1 ];
then
  e_and_l " Aufruf: $SCRIPT_NAME [Kategorien] [Optionen]"
  e_and_l ""
  e_and_l "$FULL_LINE"
  e_and_l ""
  e_and_l " Dieses Script ermöglicht die automatisierte Installation von Programmpaketen"
  e_and_l " aus verschiedenen Quellen einschließlich der Konfiguration der Programme und"
  e_and_l " Erstellung von Programmsymbolen (Icons) auf dem Desktop."
  e_and_l " Die zur Verfügung stehenden Programmpakete sind dazu in Kategorien geordnet,"
  e_and_l " welche individuell aus- oder abgewählt und beliebig angepasst werden können."
  e_and_l " Darüber hinaus stehen diverse Optionen zur Verfügung, mit denen sich Auswahl"
  e_and_l " von Programmpaketen und Ablauf des Scriptes individuell anpassen lassen."
  e_and_l " Optional können weitere System-Komponenten wie Treiber installiert werden,"
  e_and_l " sowie diverse Optimierungen des Systems durchgeführt werden."
  e_and_l " $HALF_LINE"
  e_and_l "  ${bold_white}Kategorien${colors_off}"
  e_and_l " $HALF_LINE"
  e_and_l "  Auswahl durch vorangestelltes + (plus)"
  e_and_l "  Abwahl durch vorangestelltes - (minus)"
  e_and_l ""
  for k in ${KAT_KEY_LIST[@]};
  do
    e_and_l -n "     $k   "
    if [ ${#k} -lt 2 ]; then e_and_l -n " "; fi
    e_and_l "${KATEGORIE_TEXT[$k]}"
  done
  e_and_l ""
  e_and_l "    all   Auswahl aller vorstehenden Kategorien, jedoch ohne"
  e_and_l "          die Desktop-spezifischen Tool-Pakete"
  e_and_l ""
  e_and_l "  Hinweis: Die Zuordnung der Programmpakete und Kategorien entspricht"
  e_and_l "           nicht immer der Zuordnung im Hauptmenü der Betriebssysteme."
  e_and_l "           Eine Abwahl (-) überschreibt eine entsprechende Auswahl (+)"
  e_and_l ""
  e_and_l " $HALF_LINE"
  e_and_l "  ${bold_white}Optionen${colors_off}"
  e_and_l " $HALF_LINE"
  e_and_l ""
  # --- OPTIONS START ---
  e_and_l "  addicons  Erstellt Symbole (Icons) für alle Programmpakete der"
  e_and_l "            ausgewählten Kategorien auf dem Desktop des Benutzers"
  e_and_l "            (wird bei GNOME-Desktops ab der Version 3 ignoriert)"
  e_and_l ""
  e_and_l "  cleansys  Bereinigt nicht benötigte Daten des Benutzers und"
  e_and_l "            repariert diverse Einstellungen des Systems"
  e_and_l ""
  e_and_l "  cleantmp  Alle temporären Dateien von Lissy werden automatisch wieder"
  e_and_l "            gelöscht. Heruntergeladene Dateien wie Setups und Skripte"
  e_and_l "            sowie Listen bleiben hingegen zur Nachvollziehbarkeit auch"
  e_and_l "            nach Ende des Programms im Download-Verzeichnis erhalten."
  e_and_l "            Bei Verwendung dieser Option werden auch diese Dateien"
  e_and_l "            alle vollständig aus dem Download-Verzeichnis entfernt."
  e_and_l ""
  e_and_l "     dload  Stellt gespeicherte Desktop- und Anwendungs-Einstellungen"
  e_and_l "            aus einer Sicherung wieder her (dconf)"
  e_and_l ""
  e_and_l "     dsave  Erstellt eine Sicherung der Einstellungen des Benutzers"
  e_and_l "            von Desktop und verschiedenen Anwendungen (dconf)"
  e_and_l ""
  e_and_l "    extras  Ergänzt das System jeweils wahlweise um einige Extras:"
  e_and_l "            zusätzliche Treiber, fehlende Sprach-Unterstützung, ein"
  e_and_l "            großes Schriftarten-Paket, weitere Mauszeiger und mehr"
  e_and_l ""
  e_and_l "  exupdate  Aktualisiert wahlweise Programme, die aus externen Quellen"
  e_and_l "            installiert wurden, oder nicht im Repository der Standard-"
  e_and_l "            Paket-Verwaltung (apt) eingetragen sind und somit auch von"
  e_and_l "            dieser nicht automatisch aktualisiert werden"
  e_and_l ""
  e_and_l "     force  Überspringt die Ja/Nein-Abfrage vor der Installation"
  e_and_l "            jedes einzelnen Programmpakets, sofern diese nicht in"
  e_and_l "            Konflikt mit einem bereits installierten Paket steht."
  e_and_l "            Hinweis: Diese Option ist nicht identisch mit der von"
  e_and_l "            apt-get --force (siehe dazu auch Option \"quiet\")!"
  e_and_l ""
  e_and_l "   foreign  Erlaubt auch die Installation von Programmpaketen für"
  e_and_l "            sekundäre (Fremd-)Software-Architekturen"
  e_and_l ""
  e_and_l "      help  Zeigt diese Hilfe-Seite an"
  e_and_l ""
  e_and_l "  infoonly  Zeigt nur die Liste der Systeminformationen an und führt"
  e_and_l "            keine weiteren Aktionen durch"
  e_and_l ""
  e_and_l "  instonly  Installiert oder listet nur das direkt danach angegebene"
  e_and_l "            Programmpaket - setzt die Kategorie-Auswahl außer Kraft"
  e_and_l ""
  e_and_l "   kuplock  Blockiert alle Aktualisierungen des Linux-Kernels bis"
  e_and_l "            die Sperre durch kunlock wieder aufgehoben wird. Alle"
  e_and_l "            anderen Programmpakete werden weiterhin aktualisiert"
  e_and_l ""
  e_and_l "   kunlock  Hebt die Sperre der Kernel-Aktualisierungen wieder auf"
  e_and_l ""
  e_and_l "  listonly  Zeigt alle in den ausgewählten Kategorien enthaltenen"
  e_and_l "            Programmpakete unabhängig von deren Status an, ohne"
  e_and_l "            Programmpakete zu installieren oder zu konfigurieren"
  e_and_l ""
  e_and_l "       log  Protokolliert alle Aktionen und deren Ergebnisse ohne"
  e_and_l "            weitere detaillierte Ausgaben in einer Log-Datei"
  e_and_l ""
  e_and_l "   logfull  Protokolliert alle Aktionen sowie detailliert sämtliche"
  e_and_l "            Ausgaben der Installationsroutinen in einer Log-Datei"
  e_and_l ""
  e_and_l "   nocolor  Die Ausgabe erfolgt nur in Systemschrift ohne Farben"
  e_and_l ""
  e_and_l "    noinfo  Die Systeminformationen zu Anfang werden nicht angezeigt"
  e_and_l ""
  e_and_l "    nomenu  Überspringt das Menü zur Kategorie- und Options-Auswahl"
  e_and_l "            und berücksichtigt so nur die Kommandozeilen-Parameter"
  e_and_l ""
  e_and_l "  nopkgsrv  Überspringt die Prüfung der Erreichbarkeit von Servern"
  e_and_l "            wenn die Option cleansys ausgewählt wurde"
  e_and_l ""
  e_and_l "    norepo  Fügt dem Repository keine Einträge für externe Quellen"
  e_and_l "            hinzu und überspringt die Aktualisierung des Repository"
  e_and_l "            beim Start dieses Scriptes"
  e_and_l ""
  e_and_l "    nosnap  Unterbindet Auswahl und Installation von Snap-Paketen"
  e_and_l ""
  e_and_l "    notrim  Überspringt das Trimming der Festplatten wenn die Option"
  e_and_l "            optimize ausgewählt wurde"
  e_and_l ""
  e_and_l "  noupdate  Prüft nicht auf eine neuere Version dieses Scripts"
  e_and_l ""
  e_and_l "  optimize  Aktiviert und optimiert einige System-Einstellungen für"
  e_and_l "            Firewall, Swapping, Festplattenzugriffe und vieles mehr"
  e_and_l ""
  e_and_l "  personal  Führt individuelle persönliche Einstellungen durch, welche"
  e_and_l "            dazu vom Server geladen werden. Zur Nutzung dieser Option"
  e_and_l "            ist ein geschütztes Verzeichnis bei migano.de erforderlich"
  e_and_l ""
#   e_and_l "     quiet  Unterdrückt alle Ausgaben der Installationsroutinen und"
#   e_and_l "            bestätigt ggf. soweit dies möglich ist auch automatisch"
#   e_and_l "            deren Abfragen mit den jeweiligen Standard-Einstellungen."
#   e_and_l "            Diese Option sollte daher nur verwendet werden, wenn man"
#   e_and_l "            genau weiß, dass die ausgewählten Programmpakete auch so"
#   e_and_l "            installiert werden sollen! Bei auftretenden Sicherheits-"
#   e_and_l "            Problemen wie bspw. falschen Prüfsummen erfolgt trotzdem"
#   e_and_l "            ein entsprechender Hinweis mit Abfrage zur Fortführung."
#   e_and_l "            Individuelle Konfigurationen vor oder nach Installation"
#   e_and_l "            von Paketen werden natürlich aufgrund der erforderlichen"
#   e_and_l "            Eingaben auch immer vollständig sichtbar durchgeführt."
#   e_and_l "            Hinweis: Diese Option ist nicht identisch mit der von"
#   e_and_l "            apt-get --quiet (siehe dazu auch Option \"force\")!"
#   e_and_l ""
  e_and_l "    remove  Entfernt ein Programmpaket und löscht optional all dessen"
  e_and_l "            hinterbliebene Daten wie Konfiguration, Starteinträge etc."
  e_and_l ""
  e_and_l "  saveconf  Speichert alle durch den Benutzer getätigten Einstellungen"
  e_and_l "            und verwendet diese beim nächsten Aufruf als Vorauswahl"
  e_and_l ""
  e_and_l "      skip  Überspringt die Installation bestimmter Programmpakete,"
  e_and_l "            mehrere Paketnamen sind durch Leerzeichen zu trennen"
  e_and_l "            (Paketnamen kann man mit der Option listonly ermitteln)"
  e_and_l ""
  e_and_l "    status  Zeigt den Status der ausgewählten Programmpakete an."
  e_and_l "            Sofern nicht die Option norepo angegeben ist, werden dabei"
  e_and_l "            ggf. auch Paketquellen für externe Programmpakete ergänzt,"
  e_and_l "            jedoch ohne irgendwelche Programmpakete zu installieren"
  e_and_l ""
  e_and_l "  udrivers  Installiert alle zur Verfügung stehenden zusätzlichen"
  e_and_l "            Geräte-Treiber für Ubuntu. Achtung: Es wird empfohlen"
  e_and_l "            vorher eine vollständige System-Sicherung anzulegen!"
  e_and_l ""
  # --- OPTIONS END ---
  e_and_l ""
  e_and_l " $HALF_LINE"
  e_and_l "  ${bold_white}Beispiele${colors_off}"
  e_and_l " $HALF_LINE"
  e_and_l "  Beispiele für die Verwendung finden sich unter:"
  e_and_l "  https://migano.de/lissy"
  e_and_l ""
  exit 1;
fi

###############################################################################
# Prüfen, ob in der Liste der Alternativ-Programme Zirkelbezüge vorhanden sind
###############################################################################
for pkg in ${ALL_PKG_LIST[@]}
do
  TEST_SIM_PACK="$pkg"
  LAST_SIM_PACK=""
  ALT_LIST=(  )
  while [ "$TEST_SIM_PACK" != "$LAST_SIM_PACK" ];
  do
    ALT_LIST=("${ALT_LIST[@]}" "$TEST_SIM_PACK")
    LAST_SIM_PACK="$TEST_SIM_PACK"
    if [ "${SIMILAR_PACK[$TEST_SIM_PACK]}" != "" ];
    then
      TEST_SIM_PACK="${SIMILAR_PACK[$TEST_SIM_PACK]}"
      for alt_pkg in ${ALT_LIST[@]};
      do
        if [ "$TEST_SIM_PACK" = "$alt_pkg" ];
        then
          e_and_l " $ERROR_TAG: Für das Programmpaket ${light_yellow}$pkg${colors_off} ist zwischen den Alternativen"
          e_and_l " ${light_purple}$LAST_SIM_PACK${colors_off} und ${light_purple}$TEST_SIM_PACK${colors_off} ein ungültiger Zirkelbezug eingetragen!"
          e_and_l ""
          exit 1
        fi
      done
    fi
  done
done

###############################################################################
# Dateien zur Speicherung von dconf-Daten
###############################################################################
DCONF_BASE_NAME="dconf_$(hostname)_${OS_V_CODENAME}"

# Sicherungsdatei zum Speichern UND Laden von benutzerdefinierten Einstellungen
DCONF_USER_FILE="$DOWNLOAD_DIR/$DCONF_BASE_NAME.conf"
# Zusätzliches Backup der aktuellen dconf-Einstellungen
DCONF_USER_BACKUP="$DOWNLOAD_DIR/$DCONF_BASE_NAME.save"
# Wenn dconf-Daten geändert werden können und noch kein Backup der gesamten
# dconf-Datenbank existiert, davon auch noch ein separates Backup erstellen
DCONF_NEEDED=0
if [ ${OPTION_FLAG[dload]} -eq 1 ] ||
   [ ${OPTION_FLAG[dsave]} -eq 1 ];
   # || [ ${OPTION_FLAG[personal]} -eq 1 ];
then
  DCONF_NEEDED=1
  create_backup_file "$USER_CONFIG_DIR/dconf/user"
fi

###############################################################################
# Systeminformationen anzeigen
###############################################################################
if [ ${OPTION_FLAG[noinfo]} -eq 0 ];
then

  SYS_INFO_TXT=""
  if [ "$MACHINE_MODEL" != "" ];
  then
    SYS_INFO_TXT+=" Hardware: ${bold_yellow}$MACHINE_MODEL${colors_off}"$'\n'
  fi

  SYS_INFO_TXT+=" Prozessor:${bold_yellow}"
  if [ "$CPU_MODEL" != "" ] &&
     [ "$CPU_MODEL" != "$MACHINE_MODEL" ];
  then
    SYS_INFO_TXT+=" $CPU_MODEL"
  fi
  if [ "$CPU_CODE" != "" ]; then SYS_INFO_TXT+=" $CPU_CODE"; fi
  if [ $CPU_CORES -gt 0 ]; then SYS_INFO_TXT+=" ${bold_cyan}($CPU_CORES Kerne)"; fi
  SYS_INFO_TXT+="${colors_off}"$'\n'

  if [ "$CPU_SERIAL" != "" ];
  then
    SYS_INFO_TXT+=" Seriennummer: ${bold_yellow}$CPU_SERIAL${colors_off}"$'\n'
  fi

  if [ "$MEMORY_AVAIL" != "" ] &&
     [ "$MEMORY_TOTAL" != "" ];
  then
    MEMORY_HUMAN_AVAIL=$(show_human_bytes ${MEMORY_AVAIL} "M")
    MEMORY_HUMAN_TOTAL=$(show_human_bytes ${MEMORY_TOTAL} "M")
    SYS_INFO_TXT+=" Memory: ${bold_yellow}$MEMORY_HUMAN_AVAIL${colors_off} verfügbar / ${bold_yellow}$MEMORY_HUMAN_TOTAL${colors_off} total"$'\n'
  fi

  if [ "$GPU_MODEL" != "" ];
  then
    SYS_INFO_TXT+=" Grafik: ${bold_yellow}$GPU_MODEL${colors_off}"$'\n'
  fi

  if [ "$OPERATION_SYSTEM" != "" ];
  then
    SYS_INFO_TXT+=" Betriebssystem: ${bold_yellow}$OPERATION_SYSTEM${colors_off}"
    if [ "$OS_BIT_WIDTH" != "" ];
    then
      SYS_INFO_TXT+=" ${bold_cyan}($OS_BIT_WIDTH bit)${colors_off}"
    fi
    SYS_INFO_TXT+=$'\n'
  fi

  if [ "$DEBIAN_VERSION" != "" ];
  then
    SYS_INFO_TXT+=" Debian-Version: ${bold_yellow}$DEBIAN_VERSION ($DEBIAN_CODE)${colors_off}"$'\n'
  fi

  SYS_INFO_TXT+=" Kernel-Version: ${bold_yellow}$(uname -r)${colors_off}"$'\n'

  if [ "$ARCHITECTURE_MAIN" != "" ] ||
     [ "$ARCHITECTURE_OTHER" != "" ];
  then
    SYS_INFO_TXT+=" Software-Architektur: ${bold_yellow}$ARCHITECTURE_MAIN${colors_off}"
    SYS_INFO_TXT+=" ${bold_cyan}($(uname -m))${colors_off}"
    if [ "${ARCHITECTURE_OTHER}" != "" ];
    then
      SYS_INFO_TXT+=" ${bold_yellow}[+${ARCHITECTURE_OTHER[@]}]${colors_off}"
    fi
    SYS_INFO_TXT+=$'\n'
  fi

  if [ "$CUR_SYS_LANG" != "" ];
  then
    SYS_INFO_TXT+=" Sprachumgebung: ${bold_yellow}$CUR_SYS_LANG${colors_off}"
    if [ "$CUR_LANG_NAME" != "" ]; then SYS_INFO_TXT+=" ${bold_cyan}($CUR_LANG_NAME)${colors_off}"; fi
    SYS_INFO_TXT+=$'\n'
  fi

  boot_device="$(findmnt -n / 2>/dev/null | awk '{ print $2 }' | sed -E "s/\/dev\///" | sed -E "s/[0-9]//")" # util-linux
  SYS_INFO_TXT+=" Systempartition: ${bold_yellow}$boot_device${colors_off}"$'\n'

  if [ "$DISPLAY_MANAGER" != "" ];
  then
    SYS_INFO_TXT+=" Display-Manager: ${bold_yellow}$DISPLAY_MANAGER${colors_off}"$'\n'
  fi

  if [ "$DESKTOP_ENVIRONMENT" != "" ];
  then
    SYS_INFO_TXT+=" Desktop-Environment: ${bold_yellow}$DESKTOP_ENVIRONMENT $GNOME_VERSION${colors_off}"$'\n'
  fi

  if [ "$WINDOW_MANAGER" != "" ];
  then
    SYS_INFO_TXT+=" Window-Manager: ${bold_yellow}$WINDOW_MANAGER${colors_off}"$'\n'
  fi

  if [ "$WINDOW_THEME" != "" ];
  then
    SYS_INFO_TXT+=" Window-Thema: ${bold_yellow}$WINDOW_THEME${colors_off}"$'\n'
  fi

  if [ "$SYMBOL_THEME" != "" ];
  then
    SYS_INFO_TXT+=" Symbol-Thema: ${bold_yellow}$SYMBOL_THEME${colors_off}"$'\n'
  fi

  if [ "$SHELL_TEXT" != "" ];
  then
    SYS_INFO_TXT+=" Shell: ${bold_yellow}$SHELL_TEXT${colors_off}"$'\n'
  fi

  SYS_INFO_TXT+=" Hostname: ${bold_yellow}$(hostname)${colors_off}"$'\n'

  XTERM_NR="$(who | grep -E "\(\:" | head -n 1 | cut -d'(' -f 2 | cut -d')' -f 1)"
  if [ "$XTERM_NR" != "" ]; then XTERM_NR="["$XTERM_NR"]"; fi
  SYS_INFO_TXT+=" Benutzer: ${bold_yellow}$USER_USERNAME${colors_off} at ${bold_cyan}$(tty) $XTERM_NR${colors_off}"

  do_log "$FULL_LINE"
  e_and_l "$SYS_INFO_TXT"

fi

if [ ${OPTION_FLAG[infoonly]} -eq 1 ];
then
  e_and_l ""
  e_and_l -n "${bg_blue}$FULLSPACE${colors_off}"
  e_and_l ""
  exit 0
fi

if [ ${OPTION_FLAG[noinfo]} -eq 0 ]; then e_and_l "$FULL_LINE"; fi

###############################################################################
# Überprüfung auf passendes Betriebssystem
###############################################################################
if [ $NO_MENU -eq 1 ] &&
   [ $IS_DEBIAN -eq 0 ];
then
  e_and_l " $ACHTUNG_TAG: Dieses Tool ist nicht für dieses Betriebssystem entwickelt worden!"
  e_and_l " Auf Debian-basierten Systemen werden die meisten Punkte zwar funktionieren,"
  e_and_l " auf anderen Systemen werden die Funktionen jedoch eher eingeschränkt sein!"
  ask_yes_or_no " Trotzdem weitermachen"
  if [ $? -ne 1 ];
  then
    exit 0
  fi
  e_and_l "$FULL_LINE"
fi

###############################################################################
# Überprüfung und Installation von zur korrekten Ausführung
# dieses Scriptes zwingend benötigten System-Komponenten
###############################################################################
if [ ${OPTION_FLAG[listonly]} -eq 0 ];
then
  e_and_l " ${bold_blue}Überprüfung benötigter Systemkomponenten${colors_off}"
  e_and_l "$HALF_LINE"
  # ===========================================================================
  # Zum Downloaden und Entpacken von Dateien benötigte Komponenten
  # ===========================================================================
  ALL_COMPONENTS_AVAIL=1
  COMPONENTS_REQUIRED=('coreutils' 'diffutils' 'lsof' 'p7zip-full' 'sed' 'tar' 'util-linux' 'wget')
  if [ $DCONF_NEEDED -eq 1 ];
  then
    COMPONENTS_REQUIRED+=('dconf-cli')
  fi
  for required_pkg in ${COMPONENTS_REQUIRED[@]};
  do
    ((ANZ_SPACES=12-${#required_pkg}))
    if [ $(LANG=en dpkg-query -W -f='${Status}' "$required_pkg" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
    then
      e_and_l -n " Modul ${bold_yellow}$required_pkg${colors_off}"
      insert_spaces $ANZ_SPACES
      e_and_l -n " wird installiert  ... "
      apt install "$required_pkg" -y &>"$LOG_TEMP"
      if [ $? -eq 0 ];
      then
        e_and_l "$OK_TAG"
      else
        e_and_l "$ERROR_TAG"
        ALL_COMPONENTS_AVAIL=0
      fi
      add_full_log
    else
      e_and_l -n " Modul ${light_cyan}$required_pkg${colors_off}"
      insert_spaces $ANZ_SPACES
      e_and_l -n " ... "
      e_and_l "$OK_TAG"
    fi
  done
  # ===========================================================================
  # Cross-Build Pakete zur Ausführung von armhf-Programmen auf arm64
  # ===========================================================================
  if [ $(echo "$ARCHITECTURE_MAIN" | grep -i -c -E "arm64") -gt 0 ] &&
     [ $(echo "$ARCHITECTURE_OTHER" | grep -i -c -E "armhf") -gt 0 ];
  then
    ACTION_MESSAGE=" ${light_cyan}Cross-Build-Pakete${colors_off}"
    e_and_l " ${bold_blue}Erweiterungen für die Architektur armhf auf arm64${colors_off}"
    if [ $(LANG=en dpkg-query -W -f='${Status}' "crossbuild-essential-armhf" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
    then
      ask_yes_or_no "$ACTION_MESSAGE für armhf auf arm64 installieren"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m} werden installiert, bitte warten ... "
        apt install "crossbuild-essential-armhf" -y &>"$LOG_TEMP"
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG"
        else
          e_and_l "$ERROR_TAG"
        fi
        add_full_log
      fi
    else
      e_and_l "$ACTION_MESSAGE ... $OK_TAG"
    fi
  fi
  # ===========================================================================
  # Wenn eine benötigte Komponente fehlt, Programm beenden
  # ===========================================================================
  if [ $ALL_COMPONENTS_AVAIL -eq 0 ];
  then
    e_and_l " $ERROR_TAG: Leider sind benötigte Systemkomponenten ${bold_red}nicht${colors_off} verfügbar :("
    e_and_l " Das Script wird daher jetzt beendet!"
    exit 1
  fi
  e_and_l "$FULL_LINE"
fi

###############################################################################
# Wenn der Aufruf als root erfolgt ist, Warnhinweis dazu ausgeben
# und sofern vorhanden andere Benutzer optional zum Sudoer machen
###############################################################################
if [ $USER_USERNAME = "root" ];
then
  e_and_l ""
  e_and_l " $ACHTUNG_TAG: Du bist als ${bold_yellow}root${colors_off} angemeldet. Einige zu installierende Komponenten"
  e_and_l " und automatisch durchgeführte Einstellungen sind jedoch benutzerspezifisch,"
  e_and_l " so dass diese für andere Benutzer nicht verfügbar wären bzw. von diesen bei"
  e_and_l " Bedarf erst noch selbst installiert und manuell konfiguriert werden müssten."
  # ---------------------------------------------------------------------------
  # Wenn es noch andere Benutzer gibt, darunter aber noch keine Sudoer sind,
  # anbieten Benutzer zum Sudoer zu machen
  # ---------------------------------------------------------------------------
  get_user_list
  if [ $ANZAHL_USER -gt 0 ] &&
     [ $SUDOER_EXIST -eq 0 ];
  then
    e_and_l " Es sind allerdings noch keine Benutzer als ${light_cyan}Superuser${colors_off} (Sudoer) eingerichtet."
    ask_yes_or_no " Willst Du andere Benutzer als Sudoer einrichten"
    if [ $? -eq 1 ];
    then
      NEW_SUDOER=0
      for userdir in ${HOME_DIR_LIST[@]};
      do
        TEST_USER_NAME=${userdir/\/home\//}
        id "$TEST_USER_NAME" &>/dev/null
        if [ $? -eq 0 ];
        then
          if [ $(id $TEST_USER_NAME 2>/dev/null | grep -i -c -E "\(sudo\)") -eq 0 ];
          then
            ask_yes_or_no " Benutzer ${bold_yellow}$TEST_USER_NAME${colors_off} zum Superuser machen?"
            if [ $? -eq 1 ];
            then
              e_and_l -n " Erhebe Benutzer ${bold_white}$TEST_USER_NAME${colors_off} zum Superuser ... "
              usermod -a -G sudo "$TEST_USER_NAME" &>/dev/null
              if [ $? -eq 0 ];
              then
                ((NEW_SUDOER+=1))
                e_and_l "$OK_TAG"
              else
                e_and_l "$ERROR_TAG"
              fi
            fi
          fi
        fi
      done
      if [ $NEW_SUDOER -gt 0 ];
      then
        e_and_l " Das Script wird jetzt beendet, so dass Du es mit einem Superuser in"
        e_and_l " dessen Namen und Arbeitsumgebung neu ausführen kannst. Viel Erfolg!"
        e_and_l " $HINWEIS_TAG: Der Superuser-Status wird erst nach einem Neustart wirksam."
      else
        e_and_l " Es wurde ${bold_red}kein${colors_off} Benutzer zum Superuser erhoben. Das Script wird daher"
        e_and_l " jetzt aus Sicherheitsgründen beendet."
      fi
      exit 0
    fi
  fi
  e_and_l ""
  e_and_l "$FULL_LINE"
fi

###############################################################################
# Wenn der Aufruf als Standard-Benutzer pi auf Raspbian erfolgt ist,
# Abfrage ob weiterer Superuser angelegt werden soll
###############################################################################
if [ $RASPBIAN -ne 0 ] &&
   [ $USER_USERNAME = "pi" ];
then
  e_and_l ""
  e_and_l " $ACHTUNG_TAG: Du bist als Raspberry Pi OS Standardbenutzer ${bold_yellow}pi${colors_off} angemeldet."
  e_and_l " Aus Sicherheitsgründen sollte man als ein anderer Benutzer arbeiten!"
  get_user_list
  if [ $SUDOER_EXIST -eq 0 ];
  then
    ask_yes_or_no " Soll ein neuer Benutzer/Superuser angelegt werden"
    if [ $? -eq 1 ];
    then
      NEW_USERNAME=""
      while [ "$NEW_USERNAME" = "" ];
      do
        e_and_l -n " Bitte neuen Benutzernamen eingeben: "
        read NEW_USERNAME
        if [ "$NEW_USERNAME" != "" ];
        then
          NEW_USERNAME=$(echo $NEW_USERNAME | tr -d -c '[:alnum:]_' | tr '[:upper:]' '[:lower:]')
          id "$NEW_USERNAME" &>/dev/null
          if [ $? -ne 0 ];
          then
            ask_yes_or_no " Neuer Benutzername: ${bold_yellow}$NEW_USERNAME${colors_off} - OK"
            if [ $? -eq 1 ];
            then
              e_and_l " Erstelle Superuser $NEW_USERNAME ... "
              adduser "$NEW_USERNAME"
              if [ $? -eq 0 ];
              then
                SUDOER_FILE="/etc/sudoers.d/010_$NEW_USERNAME-nopasswd"
                echo "$NEW_USERNAME ALL=(ALL) PASSWD: ALL" >  "$SUDOER_FILE"
                if [ $? -eq 0 ];
                then
                  chown root:root "$SUDOER_FILE" &>/dev/null
                  chmod 0440 "$SUDOER_FILE" &>/dev/null
                  usermod -a -G adm,dialout,cdrom,sudo,audio,video,plugdev,games,users,input,netdev,gpio,i2c,spi,pi,lpadmin "$NEW_USERNAME"
                  if [ $? -eq 0 ];
                  then
                    e_and_l -n " Fertig. Superuser ${bold_green}$NEW_USERNAME${colors_off} wurde mit ID "
                    e_and_l -n $(id -u ${NEW_USERNAME})
                    e_and_l " angelegt."
                    # Für den Benutzer pi die Passwort-Eingabe für sudo-Aktivitäten reaktivieren
                    e_and_l -n " Reaktiviere jetzt das Passwort für sudo des Benutzers pi ... "
                    PI_NOPASS_FILE="/etc/sudoers.d/010_pi-nopasswd"
                    create_backup_file "$PI_NOPASS_FILE"
                    echo -e "pi ALL=(ALL) PASSWD: ALL" > "$PI_NOPASS_FILE" 2>"$LOG_TEMP"
                    if [ $? -eq 0 ];
                    then
                      e_and_l "$OK_TAG"
                    else
                      restore_backup_file "$PI_NOPASS_FILE"
                      e_and_l "$ERROR_TAG"
                      add_full_log
                    fi
                    e_and_l " Bitte als neuer Benutzer anmelden und $SCRIPT_NAME erneut aufrufen."
                    e_and_l " $HINWEIS_TAG: Der Superuser-Status wird erst nach einem Neustart wirksam."
                    ask_yes_or_no " System neu starten [${bold_yellow}J${colors_off}] oder Script beenden [${bold_yellow}N${colors_off}]"
                    if [ $? -eq 1 ];
                    then
                      reboot
                    else
                      e_and_l " Das Script wird nun beendet."
                      exit 0
                    fi
                  fi
                fi
              fi
              e_and_l " $ERROR_TAG: Der neue Benutzer konnte nicht angelegt werden!"
              exit 1
            else
              NEW_USERNAME=""
            fi
          else
            e_and_l " $ERROR_TAG: Diesen Benutzernamen gibt es leider schon!"
            NEW_USERNAME=""
          fi
        fi
      done
    fi
  fi
  e_and_l ""
  e_and_l "$FULL_LINE"
fi

###############################################################################
# Sicherheitssabfrage für quiet, sofern relevante Aktionen durchgeführt werden
###############################################################################
if [ ${OPTION_FLAG[quiet]} -eq 1 ] &&
   [ ${OPTION_FLAG[listonly]} -eq 0 ] &&
   [ ${OPTION_FLAG[status]} -eq 0 ];
then
  e_and_l ""
  e_and_l " $ACHTUNG_TAG: Die Option ${bold_yellow}quiet${colors_off} ist aktiviert!"
  e_and_l " Dadurch werden alle Ausgaben der Installationsroutinen unterdrückt und"
  e_and_l " Programmpakete OHNE Rückfrage nach deren Standard-Vorgabe installiert!"
  e_and_l " Wenn das gewünscht ist, die folgende Frage mit [${bold_yellow}J${colors_off}]a beantworten, sonst"
  e_and_l " wird bei Eingabe von [${bold_yellow}N${colors_off}]ein ohne Quiet-Modus weitergemacht (empfohlen)."
  ask_yes_or_no " Wirklich im Quiet-Modus weitermachen"
  if [ $? -eq 0 ]; then OPTION_FLAG[quiet]=0; fi
  e_and_l ""
  e_and_l "$FULL_LINE"
fi


###############################################################################
# Hinweis auf die Verwendung gespeicherter Einstellungen
###############################################################################
if [ $NO_MENU -eq 1 ];
then
  if [ -s "$USER_SCRIPT_CONFIG" ] ||
     [ -s "$USER_PAKET_LIST" ];
  then
    e_and_l " $HINWEIS_TAG: Es werden zuvor gespeicherte individuelle Einstellungen verwendet."
    e_and_l "$FULL_LINE"
  fi
fi

###############################################################################
# Hinweis auf mehrere Software-Architekturen
###############################################################################
if [ $TOTAL_PACKS -gt 0 ] &&
   [ ${OPTION_FLAG[listonly]} -eq 0 ] &&
   [ ${OPTION_FLAG[foreign]} -eq 0 ] &&
   [ "$ARCHITECTURE_OTHER" != "" ];
then
  e_and_l " $HINWEIS_TAG: Auf diesem System sind mehrere Software-Architekturen eingerichtet."
  e_and_l " Um die Stabilität des Systems nicht zu gefährden, werden externe Programme"
  e_and_l " nur für die Haupt-Architektur ${bold_yellow}$ARCHITECTURE_MAIN${colors_off} installiert, sofern mit Angabe der Option"
  e_and_l " \"foreign\" nicht auch Pakete für die Sekundär-Architekturen erlaubt werden."
  e_and_l "$FULL_LINE"
fi

###############################################################################
# Prüfen ob die Paketverwaltung zur Verwendung frei ist und Repo aktualisieren
###############################################################################
if [ $TOTAL_PACKS -gt 0 ] ||
   [ ${OPTION_FLAG[exupdate]} -eq 1 ] ||
   [ ${OPTION_FLAG[remove]} -eq 1 ] ||
   [ ${OPTION_FLAG[udrivers]} -eq 1 ];
then
  if [ $(lsof /var/lib/dpkg/lock 2>/dev/null | wc -l) -gt 0 ];
  then
    e_and_l " $ERROR_TAG: APT ist gerade durch einen anderen Prozess geblockt (Update?)."
    e_and_l " Das Skript wird daher jetzt beendet - bitte später nochmals versuchen."
    exit 1
  fi
  if [ ${OPTION_FLAG[norepo]} -eq 0 ] &&
     [ ${OPTION_FLAG[listonly]} -eq 0 ];
  then
    repo_update " ${bold_blue}Aktualisierung des Repository${colors_off}, bitte warten ... "
  fi
fi

###############################################################################
# Die Snap-Verwaltung installieren, wenn noch nicht installiert aber verfügbar
###############################################################################
if [ $TOTAL_PACKS -gt 0 ] &&
   [ ${OPTION_FLAG[nosnap]} -eq 0 ] &&
   [ $SNAP_INSTALLED -eq 0 ] &&
   [ $(apt list "snapd" 2>/dev/null | grep -i -c "snapd") -gt 0 ];
then
  e_and_l ""
  e_and_l " $ACHTUNG_TAG: Die Snap-Paketverwaltung ist nicht installiert."
  ask_yes_or_no " Die Snap-Paketverwaltung jetzt installieren"
  if [ $? -eq 1 ];
  then
    e_and_l -n " Installiere die ${light_yellow}Snap-Paketverwaltung${colors_off}, bitte warten ... "
    apt install "snapd" -y &>"$LOG_TEMP"
    if [ $? -eq 0 ];
    then
      SNAP_INSTALLED=1
      e_and_l "$OK_TAG"
    else
      e_and_l "$ERROR_TAG"
    fi
    add_full_log
  fi
  e_and_l ""
  e_and_l "$FULL_LINE"
fi

###############################################################################
# Update von Programmen, die keinen eigenen Eintrag im Repository besitzen
###############################################################################
if [ ${OPTION_FLAG[exupdate]} -eq 1 ] &&
   [ ${OPTION_FLAG[listonly]} -eq 0 ];
then
  # ---------------------------------------------------------------------------
  # Relevante Einstellungen des Benutzers zum Script-Ablauf sichern und für
  # die Dauer der Update-Routine auf dazu erforderliche Werte setzen
  # ---------------------------------------------------------------------------
  PRESERVED_FORCE_FLAG=${OPTION_FLAG[force]}
  OPTION_FLAG[force]=0
  PRESERVED_QUIET_FLAG=${OPTION_FLAG[quiet]}
  OPTION_FLAG[quiet]=0
  PRESERVED_STATUS_FLAG=${OPTION_FLAG[status]}
  OPTION_FLAG[status]=0
  # ---------------------------------------------------------------------------

  e_and_l " ${bold_blue}Updates von externen Programmen${colors_off}"
  for pkg_name in ${EXUPDATE_PKG_LIST[@]};
  do
    e_and_l "$HALF_LINE"
    # Freundlichen Namen und verfügbare Version des Pakets ermitteln ----------
    IDX_NAME="$pkg_name"
    IDX_NAME+="_"
    IDX_NAME+="$ARCHITECTURE_MAIN"
    THE_PKG_INST_NAME="${WEB_PKG_NAME[$pkg_name]}"
    NEW_PKG_INST_VERS="${WEB_PKG_VERS[$pkg_name]}"
    NEW_PKG_INST_FILE="${WEB_PKG_FILE[$IDX_NAME]}"
    if [ "$THE_PKG_INST_NAME" = "" ];
    then
      THE_PKG_INST_NAME="${DEB_PKG_NAME[$pkg_name]}"
      NEW_PKG_INST_VERS="${DEB_PKG_VERS[$pkg_name]}"
      NEW_PKG_INST_FILE="${DEB_PKG_FILE[$IDX_NAME]}"
    fi
    # Status und Versionsnummer des installierten Pakets ermitteln ------------
    get_install_status "$pkg_name"
    INST_STATUS=$?
    # e_and_l -n " ${light_green}$THE_PKG_INST_NAME ($pkg_name)${colors_off}"
    e_and_l -n " ${light_green}$pkg_name${colors_off}${light_purple}"
    if [ "$PKG_VERSION" != "" ] &&
       [ "$PKG_VERSION" != "0" ];
    then
      e_and_l -n " $PKG_VERSION"
    else
      if [ $INST_STATUS -gt 0 ]; then e_and_l -n " (Version unbekannt)"; fi
    fi
    e_and_l -n "${colors_off} ist"
    if [ $INST_STATUS -gt 0 ];
    then
      if [ $INST_STATUS -eq 2 ]; then e_and_l -n " als ${light_purple}SNAP${colors_off}"; fi
      e_and_l " installiert."
      # Prüfen ob eine höhere Versionsnummer verfügbar ist
      UPDATE_AVAILABLE=0
      CUR_PKG_VER_1=$(echo $PKG_VERSION | cut -d"." -f 1)
      CUR_PKG_VER_2=$(echo $PKG_VERSION | cut -d"." -f 2)
      CUR_PKG_VER_3=$(echo $PKG_VERSION | cut -d"." -f 3)
      NEW_PKG_VER_1=$(echo $NEW_PKG_INST_VERS | cut -d"." -f 1)
      NEW_PKG_VER_2=$(echo $NEW_PKG_INST_VERS | cut -d"." -f 2)
      NEW_PKG_VER_3=$(echo $NEW_PKG_INST_VERS | cut -d"." -f 3)
      if [ "$CUR_PKG_VER_1" != "" ] &&
         [ "$NEW_PKG_VER_1" != "" ];
      then
        if [ $CUR_PKG_VER_1 -lt $NEW_PKG_VER_1 ];
        then
          UPDATE_AVAILABLE=1
        fi
      fi
      if [ $UPDATE_AVAILABLE -eq 0 ];
      then
        if [ "$CUR_PKG_VER_2" != "" ] &&
           [ "$NEW_PKG_VER_2" != "" ];
        then
          if [ $CUR_PKG_VER_2 -lt $NEW_PKG_VER_2 ];
          then
            UPDATE_AVAILABLE=1
          fi
        fi
      fi
      if [ $UPDATE_AVAILABLE -eq 0 ];
      then
        if [ "$CUR_PKG_VER_3" != "" ] &&
           [ "$NEW_PKG_VER_3" != "" ];
        then
          if [ $CUR_PKG_VER_3 -lt $NEW_PKG_VER_3 ];
          then
            UPDATE_AVAILABLE=1
          fi
        fi
      fi
      if [ $UPDATE_AVAILABLE -eq 1 ];
      then
        e_and_l " Die Version ${light_yellow}$NEW_PKG_INST_VERS${colors_off} steht zur Verfügung. Zum Update muss die alte Version"
        e_and_l " erst vollständig entfernt und danach die neue Version installiert werden."
        e_and_l " Eventuell bestehende Konfigurationsdaten werden zuvor natürlich gesichert."
        # Falls vorhanden Voraussetzungen anzeigen und evaluieren
        FILL_WORD="jetzt"
        SHOW_PKG_MSG=""
        TMP_PACK_MSG="${WEB_PKG_MESG[$pkg_name]}"
        if [ "$TMP_PACK_MSG" = "" ]; then TMP_PACK_MSG="${DEB_PKG_MESG[$pkg_name]}"; fi
        if [ "$TMP_PACK_MSG" != "" ];
        then
          SHOW_PKG_MSG="${bold_red}Achtung:${colors_off} ${light_yellow}$TMP_PACK_MSG${colors_off}"
        fi
        EVAL_TEST="${WEB_PKG_EVAL["$pkg_name"]}"
        if [ "$EVAL_TEST" = "" ]; then EVAL_TEST="${DEB_PKG_EVAL["$pkg_name"]}"; fi
        if [ "$EVAL_TEST" != "" ];
        then
          eval "$EVAL_TEST" &>/dev/null
          if [ $? -ne 0 ];
          then
            e_and_l " $SHOW_PKG_MSG"
            e_and_l " Diese Voraussetzung scheint ${bold_red}nicht${colors_off} erfüllt zu sein!"
            FILL_WORD="trotzdem"
          fi
        else
          e_and_l " $SHOW_PKG_MSG"
          e_and_l " Bitte prüfe vor der Installation, ob diese Voraussetzung erfüllt ist."
        fi
        ask_yes_or_no " ${light_cyan}$pkg_name${colors_off} $FILL_WORD auf Version ${light_yellow}$NEW_PKG_INST_VERS${colors_off} updaten"
        if [ $? -eq 1 ];
        then
          ask_yes_or_no " Programm ${bold_yellow}$pkg_name $PKG_VERSION${colors_off} entfernen"
          if [ $? -eq 1 ];
          then
            e_and_l " $USER_CHOICE_YES"
            # -------------------------------------------------------------------
            # 1. Konfigurationsdaten sichern
            # -------------------------------------------------------------------
            CONFIG_NAMES=( "$USER_HOME_DIR/$pkg_name"
                           "$USER_HOME_DIR/.$pkg_name"
                           "$USER_HOME_DIR/$THE_PKG_INST_NAME"
                           "$USER_CONFIG_DIR/$pkg_name"
                           "$USER_CONFIG_DIR/.$pkg_name"
                           "$USER_CONFIG_DIR/$THE_PKG_INST_NAME"
                           "$USER_HOME_DIR/Dokumente/$pkg_name"
                           "$USER_HOME_DIR/Dokumente/.$pkg_name"
                           "$USER_HOME_DIR/Dokumente/$THE_PKG_INST_NAME"
                           "$USER_HOME_DIR/.local/share/$pkg_name"
                           "$USER_HOME_DIR/.local/share/.$pkg_name"
                           "$USER_HOME_DIR/.local/share/$THE_PKG_INST_NAME" )
            for config_name in ${CONFIG_NAMES[@]};
            do
              BACKUP_NAME="${config_name}_bak"
              # Ordner ----------------------------------------------------------
              if [ -d "$config_name" ] &&
                 [ ! -d "$BACKUP_NAME" ];
              then
                cp -r -u --no-dereference "$config_name" "$BACKUP_NAME" &>/dev/null
                if [ $? -eq 0 ];
                then
                  chown -R "$USER_USERNAME:$USER_USERNAME" "$BACKUP_NAME" &>/dev/null
                  e_and_l " ${bold_purple}Konfiguration${colors_off} gesichert in ${bold_purple}$BACKUP_NAME${colors_off}"
                fi
              fi
              # Einzelne Dateien ------------------------------------------------
              if [ -f "$config_name" ] &&
                 [ ! -s "$BACKUP_NAME" ];
              then
                cp -u --no-dereference "$config_name" "$BACKUP_NAME" &>/dev/null
                if [ $? -eq 0 ];
                then
                  chown "$USER_USERNAME:$USER_USERNAME" "$BACKUP_NAME" &>/dev/null
                  e_and_l " ${bold_purple}Konfiguration${colors_off} gesichert in ${bold_purple}$BACKUP_NAME${colors_off}"
                fi
              fi
            done
            # -------------------------------------------------------------------
            # 2. Benutzerbezogenen Autostart-Eintrag sichern
            # -------------------------------------------------------------------
            AUTOSTART_FILE="$USER_CONFIG_DIR/autostart/${pkg_name}.desktop"
            if [ -f "$AUTOSTART_FILE" ];
            then
              BACKUP_FILE="${AUTOSTART_FILE}_bak"
              cp -u --no-dereference "$AUTOSTART_FILE" "$BACKUP_FILE" &>/dev/null
              if [ $? -eq 0 ];
              then
                chown "$USER_USERNAME:$USER_USERNAME" "$BACKUP_FILE" &>/dev/null
                e_and_l " ${bold_purple}Autostart${colors_off} gesichert in ${bold_purple}$BACKUP_FILE${colors_off}"
              fi
            fi
            # -------------------------------------------------------------------
            # 3. Programm löschen
            # Programme werden vollständig inklusive ihrer Konfigurationsdaten
            # gelöscht, um bei der Gelegenheit ev. bestehende Altlasten mit zu
            # bereinigen. Die Benutzer-bezogenen Konfigurations-Daten bleiben
            # hingegen erhalten (und wurden zudem zuvor ja auch noch gesichert).
            # -------------------------------------------------------------------
            remove_pkg "$pkg_name" 1

            # -----------------------------------------------------------------
            # Nur weitermachen, wenn das Löschen erfolgreich war --------------
            # -----------------------------------------------------------------
            if [ $REMOVE_RESULT -eq 0 ];
            then
              # ---------------------------------------------------------------
              # 4. Starter / Desktop-Icons löschen ----------------------------
              # ---------------------------------------------------------------
              remove_ico "$pkg_name"

              # ---------------------------------------------------------------
              # 5. Programm neu installieren ----------------------------------
              # ---------------------------------------------------------------
              LAST_ERW_PACK=""
              LAST_PPA_PACK=""
              # Für die Neu-Installation die Optionen "force" und "quiet" berücksichtigen
              OPTION_FLAG[force]=$PRESERVED_FORCE_FLAG
              OPTION_FLAG[quiet]=$PRESERVED_QUIET_FLAG
              install_pkg $pkg_name 0 0 1
              OPTION_FLAG[force]=0
              OPTION_FLAG[quiet]=0
            fi
          fi
        fi
      else
        e_and_l " Es steht keine neuere Version zur Verfügung ... $OK_TAG"
      fi
    else
      e_and_l " ${bold_red}nicht${colors_off} installiert."
    fi
  done
  e_and_l "$FULL_LINE"

  # ---------------------------------------------------------------------------
  # Einstellungen des Benutzers zu weiterem Script-Ablauf wieder herstellen
  # ---------------------------------------------------------------------------
  OPTION_FLAG[force]=$PRESERVED_FORCE_FLAG
  OPTION_FLAG[quiet]=$PRESERVED_QUIET_FLAG
  OPTION_FLAG[status]=$PRESERVED_STATUS_FLAG
  # ---------------------------------------------------------------------------
fi

###############################################################################
# Hauptschleife zur Installation nur ausführen, wenn Pakete ausgewählt wurden
###############################################################################
if [ $TOTAL_PACKS -gt 0 ];
then

  # ---------------------------------------------------------------------------
  # Start-Hinweis ausgeben
  # ---------------------------------------------------------------------------
  if [ ${OPTION_FLAG[status]} -eq 0 ] &&
     [ ${OPTION_FLAG[listonly]} -eq 0 ];
  then
    ACTION_TXT="Starte Installation"
  else
    if [ ${OPTION_FLAG[listonly]} -eq 1 ];
    then
      ACTION_TXT="Liste der Paketnamen"
    else
      ACTION_TXT="Anzeige des Status"
    fi
  fi
  START_MSG=" ${bold_blue}$ACTION_TXT von ${bold_white}$TOTAL_PACKS${colors_off}${bold_blue} ausgewählten Programmpaketen${colors_off}"
  START_MSG+=$'\n'
  if [ ${OPTION_FLAG[listonly]} -eq 1 ];
  then
    START_MSG+=" ${bold_blue}Hinweise:${colors_off}  ${light_yellow}[Alternative Programmpakete]${colors_off}  ${light_purple}(Externe Paketquelle)${colors_off}"$'\n'
  fi
  START_MSG+="$FULL_LINE"
  e_and_l "$START_MSG"

  # ---------------------------------------------------------------------------
  # Kategorien durchlaufen
  # ---------------------------------------------------------------------------

  # Bei Auswahl eines individuellen Pakets nur dieses verarbeiten
  # Dazu eine zusätzliche Kategorie nur mit diesem Paket anlegen
  if [ "$INST_ONLY_PKG" != "" ];
  then
    KAT_ORD_LIST="individual"
    KATEGORIE_FLAG[individual]=1
    KATEGORIE_PKGS[individual]="$INST_ONLY_PKG"
    KATEGORIE_TEXT[individual]="Individuelle Installation"
  fi

  ALL_ICON_COUNTER=0
  NEW_ICON_COUNTER=0
  for k in ${KAT_ORD_LIST[@]}
  do

    if [ ${KATEGORIE_FLAG[$k]} -eq 1 ];
    then

      # --------------------------------------------------
      # Liste der Pakete einer Kategorie erstellen und
      # dabei automatisch zu ergänzende Pakete hinzufügen
      # --------------------------------------------------
      TMP_LIST="${KATEGORIE_PKGS[$k]}"
      for p in ${TMP_LIST};
      do
        ADDITIONAL_PACKS="${AUTO_ADD_PKGS[$p]}"
        if [ "$ADDITIONAL_PACKS" != "" ];
        then
          if [ "${AUTO_ADD_PPOS[$p]}" != "true" ];
          then
            # Zusätzliche Pakete NACH Basispaket einfügen
            TMP_LIST=$(echo " $TMP_LIST " | sed -E "s/ $p / $p $ADDITIONAL_PACKS /")
          else
            # Zusätzliche Pakete VOR Basispaket einfügen
            TMP_LIST=$(echo " $TMP_LIST " | sed -E "s/ $p / $ADDITIONAL_PACKS $p /")
          fi
        fi
      done
      # -------------------------------------------
      # Tabelle aus der Liste der Pakete erstellen
      # -------------------------------------------
      CAT_PKG_LIST=(${TMP_LIST})
      CURRENT_CATEGORY="$k"
      KAT_SHORT_NAME="${KATEGORIE_TEXT[$CURRENT_CATEGORY]}" # Name der aktuellen Kategorie
      e_and_l " ${bold_blue}$KAT_SHORT_NAME${colors_off}"

      # Trennlinie unter dem Kategorienamen
      if [ ${OPTION_FLAG[listonly]} -eq 1 ];
      then
        e_and_l -n " ${dark_grey}"
        for ((i=0; i<${#KAT_SHORT_NAME}; i++)); do e_and_l -n "─"; done;
        e_and_l "${colors_off}"
      fi

      # ------------------------------------------------
      # Alle Pakete innerhalb der Kategorie durchlaufen
      # ------------------------------------------------
      for pkg in ${CAT_PKG_LIST[@]};
      do

        # -------------------------------------
        # Installation des Programmpakets ...
        # -------------------------------------
        if [ ${OPTION_FLAG[listonly]} -eq 0 ];
        then

          LAST_ERW_PACK=""
          LAST_PPA_PACK=""
          install_pkg $pkg 0 0 0

        # -------------------------------------------------------------
        # ... oder nur Anzeige des Paketnamens mit Zusatzinformationen
        # -------------------------------------------------------------
        else

          check_skip_raspi $pkg
          SKIP_RAPSI=$?
          if [ $SKIP_RAPSI -eq 1 ]; then e_and_l -n "${bold_black}"; fi

          LIST_TXT=" $pkg"

          if [ $SKIP_RAPSI -eq 1 ];
          then

            LIST_TXT+=" ($NA_TXT)${colors_off}"

          else

            # ------------------------------------
            # Hinweis auf alternative Paketquelle
            # ------------------------------------
            PACKAGE_TYPE=""
            get_package_type $pkg
            if [ "$PACKAGE_TYPE" != "STD" ];
            then
              if [ "$PACKAGE_TYPE" = "NONE" ];
              then
                LIST_TXT+=" ${light_red}(Quellangaben unvollständig)${colors_off}"
            else
                LIST_TXT+=" ${light_purple}($PACKAGE_TYPE)${colors_off}"
              fi
            fi

            # ---------------------------------------
            # Hinweis auf alternative Programmpakete
            # ---------------------------------------
            TEST_SIM_PACK="$pkg"
            LAST_SIM_PACK=""
            while [ "$TEST_SIM_PACK" != "$LAST_SIM_PACK" ];
            do
              LAST_SIM_PACK="$TEST_SIM_PACK"
              if [ "${SIMILAR_PACK[$TEST_SIM_PACK]}" != "" ];
              then
                TEST_SIM_PACK="${SIMILAR_PACK[$TEST_SIM_PACK]}"
                LIST_TXT+=" ${light_yellow}[$TEST_SIM_PACK]${colors_off}"
              fi
            done

          fi

          e_and_l "$LIST_TXT"

        fi

      done
      e_and_l "$FULL_LINE"

    fi

  done
  ((ALL_ICON_COUNTER+=NEW_ICON_COUNTER))

fi

###############################################################################
# Zusätzliche Desktop-Icons erstellen (nicht bei Anzeige nur der Paket-Listen)
###############################################################################
if [ ${OPTION_FLAG[listonly]} -eq 0 ] &&
   [ ${OPTION_FLAG[addicons]} -eq 1 ];
then

  # ---------------------------------------------------------------------------
  # Systemverwaltung Extra Icons
  # ---------------------------------------------------------------------------
  if [ ${KATEGORIE_FLAG[v]} -eq 1 ];
  then
    NEW_ICON_COUNTER=0
    e_and_l " ${bold_blue}Systemverwaltung Extra Icons${colors_off}"
    e_and_l " Erstelle zusätzliche Programmsymbole zur Systemverwaltung ... "
    KAT_SHORT_NAME="${KATEGORIE_TEXT[v]}"
    for desktop_icon in ${ADD_SYS_ICONS[@]};
    do
      create_extra_icon "$desktop_icon"
    done
    # ---------------------------------------------------------------------------
    # Systemverwaltung - nur bei LightDM Display Manager
    # ---------------------------------------------------------------------------
    if [ "$DISPLAY_MANAGER" = "lightdm" ];
    then
      create_extra_icon "lightdm-settings"
    fi
    e_and_l " Es wurden ${bold_green}$NEW_ICON_COUNTER${colors_off} neue Programmsymbole erstellt"
    e_and_l "$FULL_LINE"
    ((ALL_ICON_COUNTER+=NEW_ICON_COUNTER))
  fi

  # ---------------------------------------------------------------------------
  # GNOME Tools Icons
  # ---------------------------------------------------------------------------
  if [ ${KATEGORIE_FLAG[gx]} -eq 1 ];
  then
    NEW_ICON_COUNTER=0
    e_and_l " ${bold_blue}GNOME Tools${colors_off}"
    e_and_l " Erstelle zusätzliche Programmsymbole des GNOME-Desktop ... "
    KAT_SHORT_NAME="${KATEGORIE_TEXT[gx]}"
    SEARCH_RESULT_STANDARD=$(ls "/usr/share/applications" | grep -i -E "gnome.*\.desktop")
    SEARCH_RESULT_SNAP=""
    if [ -d "/var/lib/snapd/desktop/applications" ];
    then
      SEARCH_RESULT_SNAP=$(ls "/var/lib/snapd/desktop/applications" | grep -i -E "gnome.*\.desktop")
    fi
    SEARCH_ICON_RESULT="${SEARCH_RESULT_STANDARD[@]} ${SEARCH_RESULT_SNAP[@]}"
    EXCLUDE_ICON_LIST="${PKG_ICON_LIST[gnome-games]}"
    copy_icon_list
  fi

  # ---------------------------------------------------------------------------
  # MATE Tools Icons
  # ---------------------------------------------------------------------------
  if [ ${KATEGORIE_FLAG[mx]} -eq 1 ];
  then
    NEW_ICON_COUNTER=0
    e_and_l " ${bold_blue}MATE Tools${colors_off}"
    e_and_l " Erstelle zusätzliche Programmsymbole des MATE-Desktop ... "
    KAT_SHORT_NAME="${KATEGORIE_TEXT[mx]}"
    SEARCH_RESULT_STANDARD=$(ls "/usr/share/applications" | grep -i -E "mate\-.*\.desktop")
    SEARCH_RESULT_SNAP=""
    if [ -d "/var/lib/snapd/desktop/applications" ];
    then
      SEARCH_RESULT_SNAP=$(ls "/var/lib/snapd/desktop/applications" | grep -i -E "(\-)*mate\-.*\.desktop")
    fi
    SEARCH_ICON_RESULT="${SEARCH_RESULT_STANDARD[@]} ${SEARCH_RESULT_SNAP[@]}"
    create_extra_icon "matecc" # Control-Center / Steuerzentrale separat ("-" fehlt im Namen)
    EXCLUDE_ICON_LIST=""
    copy_icon_list
  fi

  # ---------------------------------------------------------------------------
  # LXDE Tools Icons
  # ---------------------------------------------------------------------------
  if [ ${KATEGORIE_FLAG[lx]} -eq 1 ];
  then
    NEW_ICON_COUNTER=0
    e_and_l " ${bold_blue}LXDE Tools${colors_off}"
    e_and_l " Erstelle zusätzliche Programmsymbole des LXDE-Desktop ... "
    KAT_SHORT_NAME="${KATEGORIE_TEXT[lx]}"
    SEARCH_RESULT_STANDARD=$(ls "/usr/share/applications" | grep -i -E "^lx.*\.desktop")
    SEARCH_RESULT_SNAP=""
    if [ -d "/var/lib/snapd/desktop/applications" ];
    then
      SEARCH_RESULT_SNAP=$(ls "/var/lib/snapd/desktop/applications" | grep -i -E "^lx.*\.desktop")
    fi
    SEARCH_ICON_RESULT="${SEARCH_RESULT_STANDARD[@]} ${SEARCH_RESULT_SNAP[@]}"
    EXCLUDE_ICON_LIST=""
    copy_icon_list
  fi

  # ---------------------------------------------------------------------------
  # XFCE Tools Icons
  # ---------------------------------------------------------------------------
  if [ ${KATEGORIE_FLAG[xx]} -eq 1 ];
  then
    NEW_ICON_COUNTER=0
    e_and_l " ${bold_blue}XFCE Tools${colors_off}"
    e_and_l " Erstelle zusätzliche Programmsymbole des XFCE-Desktop ... "
    KAT_SHORT_NAME="${KATEGORIE_TEXT[xx]}"
    SEARCH_RESULT_STANDARD=$(ls "/usr/share/applications" | grep -i -E "^xfce.*\.desktop")
    SEARCH_RESULT_SNAP=""
    if [ -d "/var/lib/snapd/desktop/applications" ];
    then
      SEARCH_RESULT_SNAP=$(ls "/var/lib/snapd/desktop/applications" | grep -i -E "^xfce.*\.desktop")
    fi
    SEARCH_ICON_RESULT="${SEARCH_RESULT_STANDARD[@]} ${SEARCH_RESULT_SNAP[@]}"
    EXCLUDE_ICON_LIST=""
    copy_icon_list
  fi

  # ---------------------------------------------------------------------------
  # Raspbian Tools Icons
  # ---------------------------------------------------------------------------
  if [ $RASPBIAN -ne 0 ];
  then
    NEW_ICON_COUNTER=0
    e_and_l " ${bold_blue}Raspbian Tools Icons${colors_off}"
    e_and_l " Erstelle zusätzliche Programmsymbole des Raspbian-Desktop ... "
    KAT_SHORT_NAME="Raspbian Tools"
    for desktop_icon in ${RASPBIAN_EXT_ICONS[@]};
    do
      create_extra_icon "$desktop_icon"
    done
    e_and_l " Es wurden ${bold_green}$NEW_ICON_COUNTER${colors_off} neue Programmsymbole erstellt"
    e_and_l "$FULL_LINE"
    ((ALL_ICON_COUNTER+=NEW_ICON_COUNTER))
  fi

  # ---------------------------------------------------------------------------
  # Falsch zugeordnete Icons entfernen
  # ---------------------------------------------------------------------------
  DESKTOP_ICON_DIR="$DESKTOP_DIR/Neue Icons"
  for desktop_icon in ${WRONG_ICONS[@]};
  do
    THE_WRONG_FILE="$DESKTOP_ICON_DIR/$desktop_icon"
    if [ -s "$THE_WRONG_FILE" ];
    then
      rm -f "$THE_WRONG_FILE" &>/dev/null
      ((ALL_ICON_COUNTER-=1))
    fi
  done

fi

###############################################################################
# Zusammenfassung anzeigen
###############################################################################
if [ $TOTAL_PACKS -gt 0 ] &&
   [ ${OPTION_FLAG[listonly]} -eq 0 ];
then

  SUMMARY_TEXT=" ${bold_blue}Zusammenfassung${colors_off}"
  SUMMARY_TEXT+=$'\n'
  SUMMARY_TEXT+="$HALF_LINE"
  SUMMARY_TEXT+=$'\n'

  # -------
  # Zähler
  # -------
  if [ ${OPTION_FLAG[status]} -eq 0 ];
  then
    INST_MSG="Neu"
    INST_SPACE="    "
  else
    INST_MSG="Nicht"
    INST_SPACE="  "
  fi
  SUMMARY_TEXT+=" Bereits installierte Pakete: ${bold_green}$PAKETS_EXIST${colors_off}"
  if [ $PAKETS_SIMILAR_EXIST -ne 0 ];
  then
    SUMMARY_TEXT+=" (davon Alternativ-Pakete: ${bold_green}$PAKETS_SIMILAR_EXIST${colors_off})"
  fi
  SUMMARY_TEXT+=$'\n'

  SUMMARY_TEXT+=" $INST_MSG installierte Pakete:$INST_SPACE ${bold_yellow}$PAKETS_AVAIL${colors_off}"
  if [ $PAKETS_SIMILAR_AVAIL -ne 0 ];
  then
    SUMMARY_TEXT+=" (davon Alternativ-Pakete: ${bold_yellow}$PAKETS_SIMILAR_AVAIL${colors_off})"
  fi
  SUMMARY_TEXT+=$'\n'

  SUMMARY_TEXT+=" Übersprungene Pakete:        ${bold_cyan}$PAKETS_SKIP${colors_off}"$'\n'

  SUMMARY_TEXT+=" Nicht verfügbare Pakete:     ${bold_red}$PAKETS_NOAVAIL${colors_off}"
  if [ $PAKETS_SIMILAR_NOAVA -ne 0 ];
  then
    SUMMARY_TEXT+=" (davon Alternativ-Pakete: ${bold_red}$PAKETS_SIMILAR_NOAVA${colors_off})"
  fi

  if [ $ALL_ICON_COUNTER -gt 0 ];
  then
    SUMMARY_TEXT+=$'\n'" Auf dem Desktop insgesamt neu erstellte Programmsymbole: ${bold_green}$ALL_ICON_COUNTER${colors_off}"
  fi

  e_and_l "$SUMMARY_TEXT"
  e_and_l "$FULL_LINE"

fi

###############################################################################
# Installation weiterer System-Komponenten (Treiber und Extras)
###############################################################################
if [ ${OPTION_FLAG[listonly]} -eq 0 ];
then

  CHANGES_MADE=0

  if [ ${OPTION_FLAG[extras]} -eq 1 ] ||
     [ ${OPTION_FLAG[udrivers]} -eq 1 ];
  then
    e_and_l " ${bold_blue}Installation weiterer System-Komponenten${colors_off}"
    e_and_l "$HALF_LINE"

    # ===========================================================================
    # Zusätzliche Gerätetreiber installieren
    # ===========================================================================
    ACTION_MESSAGE=" Nach zusätzlichen ${light_cyan}Geräte-Treibern${colors_off} suchen"
    if [ ${OPTION_FLAG[udrivers]} -eq 1 ];
    then
      if [ $(apt list "ubuntu-drivers-common" 2>/dev/null | grep -i -c "ubuntu-drivers-common") -gt 0 ];
      then
        e_and_l -n " Suche weitere ${light_cyan}Geräte-Treiber${colors_off}, bitte warten ... "
        INSTALL_RESULT=0
        if [ $(LANG=en dpkg-query -W -f='${Status}' "ubuntu-drivers-common" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
        then
          apt install ubuntu-drivers-common -y &>"$LOG_TEMP"
          INSTALL_RESULT=$?
        fi
        if [ $INSTALL_RESULT -eq 0 ];
        then
          THE_TEMP_FILE="$DOWNLOAD_DIR/missing-driver-list"
          MISSING_DRIVER_LIST=$(ubuntu-drivers list | grep -v "nvidia" 2>/dev/null)
          NVIDIA_DRIVER_LIST=$(ubuntu-drivers list | grep -i -E "nvidia" 2>/dev/null)
          if [ "$MISSING_DRIVER_LIST" != "" ];
          then
            e_and_l "${bold_green}ok, Treiber gefunden${colors_off}"
            echo -e "$MISSING_DRIVER_LIST" > "$THE_TEMP_FILE" 2>/dev/null
            ask_yes_or_no " Zusätzliche ${light_cyan}Geräte-Treiber${colors_off} installieren" "$THE_TEMP_FILE"
            if [ $? -eq 1 ];
            then
              e_and_l " Installiere zusätzliche ${light_yellow}Geräte-Treiber${colors_off} ... "
              ubuntu-drivers install | tee "$LOG_TEMP"
              CHANGES_MADE=1
              add_full_log
              e_and_l ""
            fi
            remove_file "$THE_TEMP_FILE"
          else
            e_and_l "$NF_TAG"
          fi
          if [ "$NVIDIA_DRIVER_LIST" != "" ];
          then
            e_and_l " $HINWEIS_TAG: Es stehen zusätzliche ${light_yellow}NVIDIA-Treiber${colors_off} zur Verfügung. Um die Stabilität"
            e_and_l " des Systems nicht zu gefährden, wurden diese ${bold_white}nicht${colors_off} automatisch installiert."
          fi
        else
          e_and_l "$ERROR_TAG $LINENO"
        fi
      else
        e_and_l "$(skip_text "$ACTION_MESSAGE  " "$NU_TXT")"
      fi
    else
      e_and_l "$(skip_text "$ACTION_MESSAGE  " "nicht ausgewählt")"
    fi

    if [ ${OPTION_FLAG[extras]} -eq 1 ];
    then

      # ===========================================================================
      # Zusätzliche Sprachpakete (fehlende Sprachunterstützung) installieren
      # ===========================================================================
      ACTION_MESSAGE=" Zusätzliche ${light_cyan}Sprachpakete${colors_off} installieren"
      if [ $(LANG=en dpkg-query -W -f='${Status}' "language-selector-common" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
      then
        if [ $(apt list "language-selector-common" 2>/dev/null | grep -i -c "language-selector-common") -gt 0 ];
        then
          e_and_l -n " Installiere ${light_yellow}Sprachauswahl${colors_off} für Ubuntu       ... "
          apt install language-selector-common -y &>"$LOG_TEMP"
          if [ $? -eq 0 ];
          then
            e_and_l "$OK_TAG"
          else
            e_and_l "$ERROR_TAG $LINENO"
          fi
          add_full_log
        fi
      fi
      if check-language-support --help  &>/dev/null;
      then
        CHECK_LANGUAGES="$CUR_SYS_LANG en"
        for lang_code in ${CHECK_LANGUAGES[@]};
        do
          ACTION_MESSAGE=" Zusätzliche ${light_cyan}Sprachpakete ($lang_code)${colors_off} installieren"
          THE_TEMP_FILE="$DOWNLOAD_DIR/missing-language-support"
          MISSING_LANGUAGE_SUPPORT=$(check-language-support -l ${lang_code} 2>/dev/null)
          if [ "$MISSING_LANGUAGE_SUPPORT" != "" ];
          then
            echo -e "$MISSING_LANGUAGE_SUPPORT" > "$THE_TEMP_FILE" 2>/dev/null
            ask_yes_or_no "$ACTION_MESSAGE" "$THE_TEMP_FILE"
            if [ $? -eq 1 ];
            then
              e_and_l -n " Installiere zusätzliche ${light_yellow}Sprachpakete ($lang_code)${colors_off}, bitte warten ... "
              apt install $(check-language-support -l ${lang_code}) -y &>"$LOG_TEMP"
              if [ $? -eq 0 ];
              then
                e_and_l "$OK_TAG"
                CHANGES_MADE=1
              else
                e_and_l "$ERROR_TAG $LINENO"
              fi
              add_full_log
            fi
            remove_file "$THE_TEMP_FILE"
          else
            e_and_l "$ACTION_MESSAGE ... $KF_TAG"
          fi
        done
      else
        e_and_l "$(skip_text "$ACTION_MESSAGE     " "$NA_TXT")"
      fi

      # ===========================================================================
      # Schriftarten MegaFontPack oder ersatzweise MS Windows Fonts installieren
      # ===========================================================================
      SYSTEM_FONT_DIR="/usr/share/fonts/truetype"
      MEGA_FONT_DIR="$SYSTEM_FONT_DIR/MegaFontPack"
      if [ ! -d "$MEGA_FONT_DIR" ];
      then
        ask_yes_or_no " Schriftarten ${light_cyan}MegaFontPack${colors_off} installieren"
        if [ $? -eq 1 ];
        then
          e_and_l -n " Installiere ${light_yellow}MegaFontPack${colors_off}, bitte warten     "
          DOWNLOAD_FILE_URL="$RESSOURCE_SERVER_DIR/MegaFontPack.7z"
          DOWNLOAD_FILE_NAME="${DOWNLOAD_FILE_URL##*/}"
          LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$DOWNLOAD_FILE_NAME"
          wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$DOWNLOAD_FILE_URL" &>"$LOG_TEMP"
          if [ $? -eq 0 ] &&
             [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
             [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
          then
            chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
            7z x "$LOCAL_DOWNLOAD_FILE" -o"$SYSTEM_FONT_DIR/" -y &>"$LOG_TEMP"
            if [ $? -eq 0 ];
            then
              chown -R "root:root" "$MEGA_FONT_DIR" &>/dev/null
              chmod -R 0644 "$MEGA_FONT_DIR/*" &>/dev/null
              fc-cache &>/dev/null
              dpkg-reconfigure fontconfig &>/dev/null
              remove_file "$LOCAL_DOWNLOAD_FILE"
              e_and_l "... $OK_TAG"
              CHANGES_MADE=1
            else
              e_and_l "... $ERROR_TAG $LINENO"
              add_full_log
            fi
          else
            e_and_l "... ${bold_red}nicht${colors_off} installiert"
            remove_file "$LOCAL_DOWNLOAD_FILE"
            add_full_log
          fi
        else
          ACTION_MESSAGE=" Schriftarten ${light_cyan}MS Windows Fonts${colors_off} installieren"
          if [ $(LANG=en dpkg-query -W -f='${Status}' "ttf-mscorefonts-installer" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
          then
            if [ $(apt list "ttf-mscorefonts-installer" 2>/dev/null | grep -i -c -E "ttf-mscorefonts-installer") -gt 0 ];
            then
              ask_yes_or_no "$ACTION_MESSAGE"
              if [ $? -eq 1 ];
              then
                e_and_l " Installiere ${light_yellow}MS Windows Fonts${colors_off} ... "
                { apt install "ttf-mscorefonts-installer" -y 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
                INSTALL_RESULT=$(cat "$LAST_EXIT_CODE")
                if [ $INSTALL_RESULT -eq 0 ];
                then
                  CHANGES_MADE=1
                fi
                add_full_log
                remove_file "$LAST_EXIT_CODE"
                clear # Die Installation von ttf-mscorefonts hinterlässt leider keinen sauberen Terminal-Status!
              fi
            else
              e_and_l "$(skip_text "$ACTION_MESSAGE" "$NA_TXT")"
            fi
          else
            e_and_l "$ACTION_MESSAGE ... $NC_TAG"
          fi
        fi
      else
        e_and_l " Schriftartensatz ${light_cyan}MegaFontPack${colors_off} installieren ... $NC_TAG"
      fi

      # ========================================================================
      # Mauszeiger (CursorPack) installieren
      # ========================================================================
      ACTION_MESSAGE=" Extra-Mauszeiger ${light_cyan}CursorPack${colors_off} installieren"
      USER_ICON_DIR="$USER_HOME_DIR/.icons"
      if [ "$DESKTOP_ENVIRONMENT" = "MATE" ];
      then
        if [ ! -f "$USER_ICON_DIR/.CursorPack_ok" ];
        then
          ask_yes_or_no "$ACTION_MESSAGE"
          if [ $? -eq 1 ];
          then
            e_and_l -n " Installiere ${light_yellow}CursorPack${colors_off}, bitte warten       "
            DOWNLOAD_FILE_URL="$RESSOURCE_SERVER_DIR/CursorPack.7z"
            DOWNLOAD_FILE_NAME="${DOWNLOAD_FILE_URL##*/}"
            LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$DOWNLOAD_FILE_NAME"
            wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$DOWNLOAD_FILE_URL" &>"$LOG_TEMP"
            if [ $? -eq 0 ] &&
              [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
              [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
            then
              chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
              if [ ! -d "$USER_ICON_DIR" ];
              then
                mkdir -p "$USER_ICON_DIR" &>/dev/null
              fi
              if [ -d "$USER_ICON_DIR" ];
              then
                7z x "$LOCAL_DOWNLOAD_FILE" -o"$USER_ICON_DIR/" -y &>"$LOG_TEMP"
                if [ $? -eq 0 ];
                then
                  chown -R "$USER_USERNAME:$USER_USERNAME" "$USER_ICON_DIR" &>/dev/null
                  # chmod 0755 "$USER_ICON_DIR" &>/dev/null
                  remove_file "$LOCAL_DOWNLOAD_FILE"
                  e_and_l "... $OK_TAG"
                  CHANGES_MADE=1
                else
                  e_and_l "... $ERROR_TAG $LINENO"
                  add_full_log
                fi
              else
                e_and_l "... $ERROR_TAG $LINENO"
                add_full_log
              fi
            else
              e_and_l "... ${bold_red}nicht${colors_off} installiert"
              remove_file "$LOCAL_DOWNLOAD_FILE"
              add_full_log
            fi
          fi
        else
          e_and_l "$ACTION_MESSAGE   ... $NC_TAG"
        fi
      else # kein MATE
        e_and_l "$(skip_text "$ACTION_MESSAGE  " "$NM_TXT")"
      fi

      # ===========================================================================
      # Themen Ambiant und Radiant installieren
      # ===========================================================================
      ACTION_MESSAGE=" Themen ${light_cyan}Ambiant und Radiant${colors_off} installieren"
      if [ "$DESKTOP_ENVIRONMENT" = "MATE" ];
      then
        THEME_TARGET_HOME="/usr/share"
        declare -A THEME_DIR
        THEME_DIR[0]="icons/Ambiant-MATE"
        THEME_DIR[1]="icons/Radiant-MATE"
        THEME_DIR[2]="themes/Ambiant-MATE"
        THEME_DIR[3]="themes/Ambiant-MATE-Dark"
        THEME_DIR[4]="themes/Radiant-MATE"
        ANZ_THEMES=${#THEME_DIR[@]}
        DIRS_FOUND=0
        tnr=0
        while [ $tnr -lt $ANZ_THEMES ];
        do
          if [ -d "$THEME_TARGET_HOME/${THEME_DIR[$tnr]}" ];
          then
            ((DIRS_FOUND+=1))
          fi
          ((tnr+=1))
        done
        if [ $DIRS_FOUND -lt $ANZ_THEMES ];
        then
          ask_yes_or_no "$ACTION_MESSAGE"
          if [ $? -eq 1 ];
          then
            e_and_l " Installiere Themen ${light_yellow}Ambiant und Radiant${colors_off}:"
            e_and_l -n " - Extrahiere Master-Archiv, bitte warten   ... "
            DOWNLOAD_FILE_URL="$RESSOURCE_SERVER_DIR/Ambiant-MATE-master.zip"
            DOWNLOAD_FILE_NAME="${DOWNLOAD_FILE_URL##*/}"
            LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$DOWNLOAD_FILE_NAME"
            wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$DOWNLOAD_FILE_URL" &>"$LOG_TEMP"
            if [ $? -eq 0 ] &&
              [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
              [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
            then
              chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
              unzip -o -qq "$LOCAL_DOWNLOAD_FILE" 'Ambiant-MATE-master/usr/share/icons/*' -d "$DOWNLOAD_DIR/MATE" &>"$LOG_TEMP"
              ICON_RESULT=$?
              unzip -o -qq "$LOCAL_DOWNLOAD_FILE" 'Ambiant-MATE-master/usr/share/themes/*' -d "$DOWNLOAD_DIR/MATE" &>"$LOG_TEMP"
              THEME_RESULT=$?
              if [ $ICON_RESULT -eq 0 ] &&
                [ $THEME_RESULT -eq 0 ];
              then
                e_and_l "$OK_TAG"
                chown -R "$USER_USERNAME:$USER_USERNAME" "$DOWNLOAD_DIR/MATE" &>/dev/null
                NEW_THEMES=0
                tnr=0
                while [ $tnr -lt $ANZ_THEMES ];
                do
                  THEME_TARGET_DIR="$THEME_TARGET_HOME/${THEME_DIR[$tnr]}"
                  THEME_NAME=${THEME_TARGET_DIR##*/}
                  THEME_TYPE=""
                  if [ $(echo "$THEME_TARGET_DIR" | grep -c -E "icons") -gt 0 ];
                  then
                    THEME_TYPE="Icons "
                  fi
                  if [ $(echo "$THEME_TARGET_DIR" | grep -c -E "themes") -gt 0 ];
                  then
                    THEME_TYPE="Thema "
                  fi
                  e_and_l -n " - Kopiere $THEME_TYPE${light_yellow}$THEME_NAME${colors_off} "
                  ((ANZ_SPACES=27-${#THEME_NAME}))
                  insert_spaces $ANZ_SPACES
                  cp -r -u "$DOWNLOAD_DIR/MATE/Ambiant-MATE-master$THEME_TARGET_DIR" "$THEME_TARGET_DIR" &>$LOG_TEMP
                  if [ $? -eq 0 ];
                  then
                    chown -R "root:root" "$THEME_TARGET_DIR" &>/dev/null
                    e_and_l "... $OK_TAG"
                    ((NEW_THEMES+=1))
                  else
                    e_and_l "... $ERROR_TAG $LINENO"
                  fi
                  ((tnr+=1))
                done
                if [ $NEW_THEMES -gt 0 ];
                then
                  e_and_l " $HINWEIS_TAG: Die Themen sind nun zur Einrichtung des Erscheinungsbilds verfügbar."
                fi
              else
                e_and_l "$ERROR_TAG $LINENO"
                add_full_log
              fi
            else
              e_and_l "$ERROR_TAG $LINENO"
              add_full_log
            fi
            remove_file "$LOCAL_DOWNLOAD_FILE"
            rm -f -r "$DOWNLOAD_DIR/MATE" &>/dev/null
          fi
        else
          e_and_l "$ACTION_MESSAGE    ... $NC_TAG"
        fi
      else # kein MATE
        e_and_l "$(skip_text "$ACTION_MESSAGE   " "$NM_TXT")"
      fi

      # ===========================================================================
      # Desktop-Themen Ubuntu-MATE installieren
      # ===========================================================================
      ACTION_MESSAGE=" Desktop-Themen ${light_cyan}Ubuntu MATE${colors_off} installieren"
      if [ $(apt list "ubuntu-mate-themes" 2>/dev/null | grep -i -c "ubuntu-mate-themes") -gt 0 ];
      then
        if [ $(LANG=en dpkg-query -W -f='${Status}' "ubuntu-mate-themes" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
        then
          ask_yes_or_no "$ACTION_MESSAGE"
          if [ $? -eq 1 ];
          then
            e_and_l -n " Installiere Desktop-Themen ${light_yellow}Ubuntu-MATE${colors_off}     ... "
            apt install "ubuntu-mate-themes" -y &>"$LOG_TEMP"
            if [ $? -eq 0 ];
            then
              e_and_l "$OK_TAG"
              CHANGES_MADE=1
            else
              e_and_l "$ERROR_TAG"
            fi
            add_full_log
          fi
        else
          e_and_l "$ACTION_MESSAGE    ... $NC_TAG"
        fi
      else
        e_and_l "$(skip_text "$ACTION_MESSAGE   " "$NA_TXT")"
      fi

      # ===========================================================================
      # Desktop-Themen Yaru installieren
      # ===========================================================================
      ACTION_MESSAGE=" Desktop-Themen ${light_cyan}Yaru${colors_off} installieren"
      YARU_THEME_PARTS="gtk icon sound"
      YARU_AVAILS=""
      YARU_MISSING=""
      for yp in ${YARU_THEME_PARTS[@]};
      do
        if [ $(apt list "yaru-theme-$yp" 2>/dev/null | grep -i -c "yaru-theme-$yp") -gt 0 ];
        then
          YARU_AVAILS+="$yp"
          if [ $(LANG=en dpkg-query -W -f='${Status}' "yaru-theme-$yp" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
          then
            YARU_MISSING+="yaru-theme-$yp "
          fi
        fi
      done
      if [ "$YARU_AVAILS" != "" ];
      then
        if [ "$YARU_MISSING" != "" ];
        then
          ask_yes_or_no "$ACTION_MESSAGE"
          if [ $? -eq 1 ];
          then
            e_and_l -n " Installiere ${light_yellow}Yaru-Themen${colors_off}, bitte warten      ... "
            YARU_ERRORS=0
            for ym in ${YARU_MISSING[@]};
            do
              apt install "$ym" -y &>"$LOG_TEMP"
              if [ $? -ne 0 ]; then ((YARU_ERRORS+=1)); fi
            done
            if [ $YARU_ERRORS -eq 0 ]
            then
              e_and_l "$OK_TAG"
              CHANGES_MADE=1
            else
              e_and_l "$ERROR_TAG"
            fi
            add_full_log
          fi
        else
          e_and_l "$ACTION_MESSAGE           ... $NC_TAG"
        fi
      else
        e_and_l "$(skip_text "$ACTION_MESSAGE          " "$NA_TXT")"
      fi

      # ===========================================================================
      # Bildschirmschoner XScreenSaver installieren
      # ===========================================================================
      ACTION_MESSAGE=" Bildschirmschoner ${light_cyan}XScreenSaver${colors_off} einrichten"
      XSCRSAVER_EPKG_LIST=('xscreensaver' 'xscreensaver-data' 'xscreensaver-data-extra' 'xscreensaver-gl' 'xscreensaver-gl-extra' 'rss-glx')
      XSCRSAVER_AVAILABLE=0
      XSCRSAVER_INSTALLED=0
      for xs_pkg in ${XSCRSAVER_EPKG_LIST[@]};
      do
        if [ $(apt list "$xs_pkg" 2>/dev/null | grep -i -c "$xs_pkg") -gt 0 ];
        then
          ((XSCRSAVER_AVAILABLE+=1))
        fi
        get_install_status "$xs_pkg"
        if [ $? -ne 0 ];
        then
          ((XSCRSAVER_INSTALLED+=1))
        fi
      done
      if [ $XSCRSAVER_AVAILABLE -gt 1 ];
      then
        # Fehlende XScreenSaver-Komponenten installieren
        if [ $XSCRSAVER_INSTALLED -ne $XSCRSAVER_AVAILABLE ];
        then
          ask_yes_or_no "$ACTION_MESSAGE"
          if [ $? -eq 1 ];
          then
            if [ $XSCRSAVER_INSTALLED -ne $XSCRSAVER_AVAILABLE ];
            then
              e_and_l -n " Installiere ${light_yellow}XScreen-Module${colors_off}, bitte warten   ... "
              echo -e "" > "$LOG_TEMP"
              XSCRSAVER_NEWINST=0
              for xs_pkg in ${XSCRSAVER_EPKG_LIST[@]};
              do
                # Wenn das Modul noch nicht installiert ist ...
                if [ $(LANG=en dpkg-query -W -f='${Status}' "$xs_pkg" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
                then
                  # ... und verfügbar ist, dann neu installieren ...
                  if [ $(apt list "$xs_pkg" 2>/dev/null | grep -i -c "$xs_pkg") -gt 0 ];
                  then
                    apt install "$xs_pkg" -y &>>"$LOG_TEMP"
                    if [ $? -eq 0 ];
                    then
                      ((XSCRSAVER_NEWINST+=1))
                    fi
                  fi
                fi
              done
              if [ $XSCRSAVER_NEWINST -gt 0 ];
              then
                e_and_l "$OK_TAG"
                CURRENT_CATEGORY="v" # Icon für Einstellungen des XScreenSaver der Systemverwaltung zuordnen
                KAT_SHORT_NAME="${KATEGORIE_TEXT[v]}"
                copy_starter_to_desktop "xscreensaver-properties"
                copy_starter_to_desktop "xscreensaver-settings"
                CHANGES_MADE=1
              else
                e_and_l "$ERROR_TAG"
              fi
              add_full_log
              remove_file "$LOG_TEMP"
            fi
          fi
        else
          e_and_l "$ACTION_MESSAGE  ... $NC_TAG"
        fi
        # Wenn XScreenSaver verfügbar, dann Autostarteintrag für XScreenSaver erstellen/aktivieren
        if [ $XSCRSAVER_INSTALLED -eq $XSCRSAVER_AVAILABLE ] ||
           [ $XSCRSAVER_NEWINST -gt 0 ];
        then
          X_SCREENSAVER_AUTOSTART_FILE="/home/$USER_USERNAME/.config/autostart/xscreensaver.desktop"
          if [ ! -s "$X_SCREENSAVER_AUTOSTART_FILE" ];
          then
            e_and_l -n " Erstelle Autostarteintrag für ${light_yellow}XScreenSaver${colors_off} ... "
            XSCR_EXEC_TEXT="xscreensaver"
            if [ $(xscreensaver --help 2>&1 | grep -c -E "no-splash") -gt 0 ]; then XSCR_EXEC_TEXT+=" --no-splash"; fi
            create_autostart_file "$X_SCREENSAVER_AUTOSTART_FILE" "XScreenSaver" "Bildschirmschoner und Bildschirmsperre" "$XSCR_EXEC_TEXT" "xscreensaver"
            if [ $? -eq 0 ];
            then
              e_and_l "$OK_TAG"
              CHANGES_MADE=1
            else
              e_and_l "$ERROR_TAG"
            fi
          fi
        fi
        # Wenn XScreenSaver verfügbar, dann MATE-Bildschirmschoner deaktivieren
        if [ $XSCRSAVER_INSTALLED -eq $XSCRSAVER_AVAILABLE ] ||
           [ $XSCRSAVER_NEWINST -gt 0 ];
        then
          if [ -e "/usr/bin/mate-screensaver" ] ||
             [ -e "/usr/bin/mate-screensaver.deactivated" ];
          then
            MATE_ACTIVE_SS_FILES=0
            declare -A MATE_SCRSAVER_FILES
            MATE_SCRSAVER_FILES[0]="/etc/xdg/autostart/mate-screensaver.desktop"
            MATE_SCRSAVER_FILES[1]="/usr/bin/mate-screensaver"
            MATE_SCRSAVER_FILES[2]="/usr/share/applications/mate-screensaver-preferences.desktop"
            MATE_SCRSAVER_FILES[3]="$USER_CONFIG_DIR/autostart/mate-screensaver.desktop"
            for scr_saver_file in ${MATE_SCRSAVER_FILES[@]};
            do
              if [ -e "$scr_saver_file" ]; then ((MATE_ACTIVE_SS_FILES+=1)); fi
            done
            if [ $MATE_ACTIVE_SS_FILES -gt 0 ];
            then
              e_and_l " $HINWEIS_TAG: Mit dem MATE- und X-ScreenSaver sind zwei Bildschirmschoner aktiv."
              ask_yes_or_no " MATE-Screensaver vollständig deaktivieren (empfohlen)"
              if [ $? -eq 1 ];
              then
                e_and_l -n " Deaktiviere den ${light_yellow}MATE-Bildschirmschoner${colors_off}     ... "
                MSCR_RESULT=0
                for scr_saver_file in ${MATE_SCRSAVER_FILES[@]};
                do
                  if [ -e "$scr_saver_file" ];
                  then
                    mv -f "$scr_saver_file" "$scr_saver_file.deactivated" &>/dev/null
                    if [ $? -ne 0 ]; then ((MSCR_RESULT+=1)); fi
                  fi
                done
                if [ $MSCR_RESULT -eq 0 ];
                then
                  e_and_l "$OK_TAG"
                  e_and_l " $HINWEIS_TAG: Die Änderungen werden erst nach Neustart des Systems wirksam."
                  CHANGES_MADE=1
                else
                  e_and_l "$ERROR_TAG"
                fi
              fi
            fi
          fi
        fi
      else # Kein XScreenSaver verfügbar
        e_and_l "$(skip_text "$ACTION_MESSAGE " "$NA_TXT")"
      fi

      # ===========================================================================
      # Diverse Desktop-Tools einrichten (ggf. mit Autostart)
      # ===========================================================================
      AUTOSTART_ACTIVATE_LIST=('copyq' 'redshift-gtk' 'tilda')
      AUTOSTART_ACTIVATE_NAME=('CopyQ' 'Redshift' 'Tilda')
      AUTOSTART_ACTIVATE_DESC=('Zwischenablage-Manager ' 'Farbtemperaturanpassung' 'Ausklapp-Terminal (F12)')
      AUTOSTART_ACTIVATE_ICON=('copyq' 'redshift' 'tilda')
      AUTOSTART_ACTIVATE_ONLY=('all' 'all' 'ubuntu')
      anz_entries=${#AUTOSTART_ACTIVATE_LIST[@]}
      a=0
      while [ $a -lt $anz_entries ];
      do
        PACKET_NAME_TO_SHOW="${AUTOSTART_ACTIVATE_LIST[$a]/-gtk/}"
        ACTION_MESSAGE=" Modul ${light_cyan}${AUTOSTART_ACTIVATE_DESC[$a]}${colors_off} [$PACKET_NAME_TO_SHOW]"
        ANZ_SPACES=34
        ((ANZ_SPACES-=${#AUTOSTART_ACTIVATE_DESC[$a]}))
        ((ANZ_SPACES-=${#PACKET_NAME_TO_SHOW}))
        i=1; while [ $i -lt $ANZ_SPACES ]; do ACTION_MESSAGE+=" "; ((i+=1)); done
        if [ "${AUTOSTART_ACTIVATE_ONLY[$a]}" = "all" ] ||
           [ $(echo "$OPERATION_SYSTEM" | grep -i -c -E "${AUTOSTART_ACTIVATE_ONLY[$a]}") -gt 0 ];
        then
          INSTALL_STATUS=0
          NEW_INSTALLED=0
          ANSWER_INST_NO=0
          if [ $(LANG=en dpkg-query -W -f='${Status}' "${AUTOSTART_ACTIVATE_LIST[$a]}" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
          then
            if [ $(apt list "${AUTOSTART_ACTIVATE_LIST[$a]}" 2>/dev/null | grep -i -c -E "${AUTOSTART_ACTIVATE_LIST[$a]}") -gt 0 ];
            then
              ask_yes_or_no " Modul ${light_cyan}${AUTOSTART_ACTIVATE_DESC[$a]%%*\/ }${colors_off} installieren"
              if [ $? -eq 1 ];
              then
                e_and_l -n " Installiere ${light_yellow}$PACKET_NAME_TO_SHOW${colors_off}, bitte warten"
                ANZ_SPACES=17
                ((ANZ_SPACES-=${#PACKET_NAME_TO_SHOW}))
                i=1; while [ $i -lt $ANZ_SPACES ]; do e_and_l -n " "; ((i+=1)); done
                e_and_l -n " ... "
                apt install "${AUTOSTART_ACTIVATE_LIST[$a]}" -y &>"$LOG_TEMP"
                if [ $? -eq 0 ]
                then
                  NEW_INSTALLED=1
                else
                  INSTALL_STATUS=1
                fi
              else
                INSTALL_STATUS=2
                ANSWER_INST_NO=1
              fi
            else
              INSTALL_STATUS=3
              e_and_l "$(skip_text "$ACTION_MESSAGE" "$NA_TXT")"
            fi
          else
            e_and_l -n "$ACTION_MESSAGE ... "
          fi
          if [ $INSTALL_STATUS -eq 0 ];
          then
            # Auf MATE- und Cinnamon-Desktop zusätzlich Autostart einrichten
            if [ "$DESKTOP_ENVIRONMENT" = "MATE" ] ||
               [ "$DESKTOP_ENVIRONMENT" = "Cinnamon" ];
            then
              ENTRY_FILE_NAME="$USER_CONFIG_DIR/autostart/${AUTOSTART_ACTIVATE_LIST[$a]}"
              ENTRY_FILE_NAME+=".desktop"
              # Wenn es schon eine Datei gibt, diese anpassen ...
              if [ -s "$ENTRY_FILE_NAME" ];
              then
                if [ $(grep -i -c -E "X-GNOME-Autostart-enabled\s*\=\s*true" "$ENTRY_FILE_NAME" 2>/dev/null) -gt 0 ] &&
                   [ $(grep -i -c -E "X-MATE-Autostart-enabled\s*\=\s*true" "$ENTRY_FILE_NAME" 2>/dev/null) -gt 0 ] &&
                   [ $(grep -i -c -E "NoDisplay\s*=\s*false" "$ENTRY_FILE_NAME" 2>/dev/null) -gt 0 ] &&
                   [ $(grep -i -c -E "Hidden\s*=\s*false" "$ENTRY_FILE_NAME" 2>/dev/null) -gt 0 ];
                then
                  e_and_l "$OA_TAG"
                else
                  # "Falsche" Einträge korrigieren --------------------------------
                  create_backup_file "$ENTRY_FILE_NAME"
                  sed -i -E "s/Autostart-enabled\s*=\s*false/Autostart-enabled=true/g" "$ENTRY_FILE_NAME"
                  sed -i -E "s/^\s*NoDisplay\s*=\s*true/NoDisplay=false/g" "$ENTRY_FILE_NAME"
                  sed -i -E "s/^\s*Hidden\s*=\s*true/Hidden=false/g" "$ENTRY_FILE_NAME"
                  # Fehlende Einträge hinzufügen ----------------------------------
                  if [ $(grep -i -c -E "X-GNOME-Autostart-enabled\s*\=\s*true" "$ENTRY_FILE_NAME" 2>/dev/null) -eq 0 ];
                  then
                    echo -e $'\n'"X-GNOME-Autostart-enabled=true" >> "$ENTRY_FILE_NAME" 2>/dev/null
                  fi
                  if [ $(grep -i -c -E "X-MATE-Autostart-enabled\s*\=\s*true" "$ENTRY_FILE_NAME" 2>/dev/null) -eq 0 ];
                  then
                    echo -e $'\n'"X-MATE-Autostart-enabled=true" >> "$ENTRY_FILE_NAME" 2>/dev/null
                  fi
                  if [ $(grep -i -c -E "NoDisplay\s*\=\s*false" "$ENTRY_FILE_NAME" 2>/dev/null) -eq 0 ];
                  then
                    echo -e $'\n'"NoDisplay=false" >> "$ENTRY_FILE_NAME" 2>/dev/null
                  fi
                  if [ $(grep -i -c -E "Hidden\s*\=\s*false" "$ENTRY_FILE_NAME" 2>/dev/null) -eq 0 ];
                  then
                    echo -e $'\n'"Hidden=false" >> "$ENTRY_FILE_NAME" 2>/dev/null
                  fi
                  # Leerzeilen entfernen (nur für die Optik ;) --------------------
                  sed -i -E "/^[[:space:]]*$/d" "$ENTRY_FILE_NAME"
                  # Ausnahmsweise OK ohne vorherige "Erfolgs-Prüfung" ;) ----------
                  e_and_l "$OA_TAG"
                  CHANGES_MADE=1
                fi
              else # ... sonst eine neue Datei anlegen ----------------------------
                create_autostart_file "$ENTRY_FILE_NAME" "${AUTOSTART_ACTIVATE_NAME[$a]}" "${AUTOSTART_ACTIVATE_DESC[$a]}" "/usr/bin/${AUTOSTART_ACTIVATE_LIST[$a]}" "${AUTOSTART_ACTIVATE_ICON[$a]}"
                if [ $? -eq 0 ];
                then
                  e_and_l "$OA_TAG"
                  CHANGES_MADE=1
                else
                  e_and_l "$ERROR_TAG"
                fi
              fi
            else
              if [ $NEW_INSTALLED -eq 1 ];
              then
                e_and_l "$OK_TAG"
              else
                e_and_l "$NC_TAG"
              fi
            fi
          else
            add_full_log
          fi
        else
          e_and_l "$(skip_text "$ACTION_MESSAGE" "$NU_TXT")"
        fi
        ((a+=1))
      done

      # ===========================================================================
      # Erstellung diverser Menü-Einträge für Wine
      # ---------------------------------------------------------------------------
      # ACHTUNG:
      # In "wine_post_inst" wird WINE_STARTER_LIST statt PKG_ICON_LIST[wine] zur
      # Auswahl der Starter verwendet. Bei Änderungen in beiden Scripten anpassen!
      # ===========================================================================
      ACTION_MESSAGE=" Fehlende ${light_cyan}Menü-Einträge für Wine${colors_off} erstellen"
      if [ $(LANG=en dpkg-query -W -f='${Status}' "wine" 2>/dev/null | grep -i -c -E "ok installed") -ne 0 ];
      then
        WINE_STARTER_MISSING=0
        tmp_list=${PKG_ICON_LIST[wine]};
        for starter_file in ${tmp_list[@]};
        do
          if [ ! -s "/usr/share/applications/$starter_file.desktop" ];
          then
            ((WINE_STARTER_MISSING+=1))
            break
          fi
        done
        if [ $WINE_STARTER_MISSING -gt 0 ];
        then
          declare -A WINE_STARTER_NAME
          declare -A WINE_STARTER_EXEC
          WINE_STARTER_NAME[wine-browsedrive]='Laufwerk C:'
          WINE_STARTER_EXEC[wine-browsedrive]='xdg-open .wine/dosdevices/c:'
          WINE_STARTER_NAME[wine-control]='Kontrollpanel'
          WINE_STARTER_EXEC[wine-control]='wine control'
          WINE_STARTER_NAME[wine-explorer]='Windows Explorer'
          WINE_STARTER_EXEC[wine-explorer]='wine explorer'
          WINE_STARTER_NAME[wine-iexplore]='Internet Explorer'
          WINE_STARTER_EXEC[wine-iexplore]='wine iexplore'
          WINE_STARTER_NAME[wine-regedit]='Registry Editor'
          WINE_STARTER_EXEC[wine-regedit]='wine regedit'
          WINE_STARTER_NAME[wine-taskmgr]='Taskmanager'
          WINE_STARTER_EXEC[wine-taskmgr]='wine taskmgr'
          WINE_STARTER_NAME[wine-uninstaller]='Software UnInstaller'
          WINE_STARTER_EXEC[wine-uninstaller]='wine uninstaller'
          WINE_STARTER_NAME[wine-winecfg]='Konfiguration'
          WINE_STARTER_EXEC[wine-winecfg]='winecfg'
          WINE_STARTER_NAME[wine-wineconsole]='Windows Konsole'
          WINE_STARTER_EXEC[wine-wineconsole]='wine wineconsole'
          WINE_STARTER_NAME[wine-winemine]='MineSweeper'
          WINE_STARTER_EXEC[wine-winemine]='wine winemine'
          e_and_l -n "$ACTION_MESSAGE  ... "
          WINE_STARTER_ERRORS=0
          for starter_file in ${tmp_list[@]};
          do
            WINE_STARTER_FILE="/usr/share/applications/$starter_file.desktop"
            if [ ! -s "$WINE_STARTER_FILE" ];
            then
              echo -e "[Desktop Entry]" > "$WINE_STARTER_FILE" 2>/dev/null
              if [ $? -eq 0 ];
              then
                echo -e "Type=Application" >> "$WINE_STARTER_FILE" 2>/dev/null
                echo -e "Name=Wine ${WINE_STARTER_NAME[$starter_file]}" >> "$WINE_STARTER_FILE" 2>/dev/null
                echo -e "Exec=${WINE_STARTER_EXEC[$starter_file]}" >> "$WINE_STARTER_FILE" 2>/dev/null
                echo -e "Icon=$starter_file" >> "$WINE_STARTER_FILE" 2>/dev/null
                echo -e "Terminal=false" >> "$WINE_STARTER_FILE" 2>/dev/null
                echo -e "StartupNotify=false" >> "$WINE_STARTER_FILE" 2>/dev/null
                echo -e "Categories=Wine;" >> "$WINE_STARTER_FILE" 2>/dev/null
                chown "root:root" "$WINE_STARTER_FILE" &>/dev/null
                chmod 0644 "$WINE_STARTER_FILE" &>/dev/null
                download_icon_file "$starter_file"
                if [ ${OPTION_FLAG[addicons]} -ne 0 ];
                then
                  KAT_SHORT_NAME="${KATEGORIE_TEXT[w]}"
                  copy_starter_to_desktop "$starter_file"
                fi
              else
                ((WINE_STARTER_ERRORS+=1))
              fi
            fi
          done
          if [ $WINE_STARTER_ERRORS -eq 0 ];
          then
            e_and_l "$OK_TAG"
          else
            e_and_l "$ERROR_TAG"
          fi
        else
          e_and_l "$ACTION_MESSAGE  ... $NC_TAG"
        fi
      else
        e_and_l "$(skip_text "$ACTION_MESSAGE " "$NA_TXT")"
      fi

      # ===========================================================================
      # Signaturen der Blu-ray-Datenbank erneuern
      # ===========================================================================
      ACTION_MESSAGE=" Signaturen der ${light_cyan}Blu-ray-Datenbank${colors_off} erneuern "
      if [ $(LANG=en dpkg-query -W -f='${Status}' "libbluray2" 2>/dev/null | grep -i -c -E "ok installed") -ne 0 ];
      then
        USER_AACS_DIR="$USER_CONFIG_DIR/aacs"
        # SNAP_AACS_DIR="$USER_HOME_DIR/snap/vlc/current/.config/aacs" # Derzeit nicht verwendet
        # Nur weitermachen, wenn es keine Schlüsseldatei gibt,
        # oder diese älter als eine Woche ist ...
        if [ -d "$USER_AACS_DIR" ] &&
           [ $(find "$USER_AACS_DIR" -type f -iname "keydb.cfg" -print0 2>/dev/null | grep -i -c -E "keydb.cfg") -gt 0 ] &&
           [ $(find "$USER_AACS_DIR" -type f -iname "keydb.cfg" -mtime +7 -print0 2>/dev/null | grep -i -c -E "keydb.cfg") -eq 0 ];
        then
          e_and_l "$ACTION_MESSAGE ... $NC_TAG"
        else
          ask_yes_or_no " AACS-Signaturen für ${light_cyan}Blu-rays${colors_off} erneuern"
          if [ $? -eq 1 ];
          then
            e_and_l -n " Download ${light_yellow}Blu-ray Signaturen${colors_off}, bitte warten  "
            DOWNLOAD_FILE_URL="http://fvonline-db.bplaced.net/fv_download.php?lang=deu"
            DOWNLOAD_FILE_NAME="keydb_deu.zip"
            LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$DOWNLOAD_FILE_NAME"
            wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$DOWNLOAD_FILE_URL" &>"$LOG_TEMP"
            if [ $? -eq 0 ] &&
               [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
               [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
            then
              chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
              if [ ! -d "$USER_AACS_DIR" ];
              then
                mkdir -p "$USER_AACS_DIR" &>/dev/null
              fi
              if [ -d "$USER_AACS_DIR" ];
              then
                find "$USER_AACS_DIR" -type f -iname "keydb.cfg" -mtime +7 -delete &>/dev/null
                7z x "$LOCAL_DOWNLOAD_FILE" -o"$USER_AACS_DIR/" -y &>"$LOG_TEMP"
                if [ $? -eq 0 ];
                then
                  chown -R "$USER_USERNAME:$USER_USERNAME" "$USER_AACS_DIR" &>/dev/null
                  # chmod 0755 "$USER_AACS_DIR" &>/dev/null
                  remove_file "$LOCAL_DOWNLOAD_FILE"
                  e_and_l "... $OK_TAG"
                  CHANGES_MADE=1
                else
                  e_and_l "... $ERROR_TAG $LINENO"
                  add_full_log
                fi
              else
                e_and_l "... $ERROR_TAG $LINENO"
                add_full_log
              fi
            else
              e_and_l "... $ERROR_TAG $LINENO"
              remove_file "$LOCAL_DOWNLOAD_FILE"
              add_full_log
            fi
          fi
        fi
      else
        e_and_l "$(skip_text "$ACTION_MESSAGE" "kein Blu-ray")"
      fi

    fi # Ende Extras

    # ===========================================================================
    # Hinweis auf Änderungen
    # ===========================================================================
    if [ $CHANGES_MADE -gt 0 ];
    then
      e_and_l "$HALF_LINE"
      e_and_l " $HINWEIS_TAG: Einzelne Änderungen werden ev. erst bei der nächsten Anmeldung aktiv"
    fi
    e_and_l "$FULL_LINE"

  fi

fi

###############################################################################
# Blockieren oder freigeben der Kernel-Updates
###############################################################################
if [ ${OPTION_FLAG[kuplock]} -eq 1 ] ||
   [ ${OPTION_FLAG[kunlock]} -eq 1 ];
then
  e_and_l " ${bold_blue}Kernel-Update-Locking${colors_off}"
  if [ ${OPTION_FLAG[kuplock]} -eq 1 ];
  then
    e_and_l -n " Blockiere Aktualisierungen (Updates) für den Linux-Kernel ... "
  else
    e_and_l -n " Hebe Aktualisierungs-Blockade für den Linux-Kernel auf ... "
  fi
  LOCKING_ERRORS=0
  echo -e "" > "$LOG_TEMP"
  for kp in ${KERNEL_PACKS[@]};
  do
    if [ $(dpkg -l 2>/dev/null | grep -c -i -E "$kp") -gt 0 ];
    then
      if [ ${OPTION_FLAG[kuplock]} -eq 1 ];
      then
        apt-mark hold "$kp*" 2>&1 1>>"$LOG_TEMP"
        if [ $? -ne 0 ]; then ((LOCKING_ERRORS+=1)); fi
      else
        apt-mark unhold "$kp*" 2>&1 1>>"$LOG_TEMP"
        if [ $? -ne 0 ]; then ((LOCKING_ERRORS+=1)); fi
      fi
    fi
  done
  if [ $LOCKING_ERRORS -eq 0 ];
  then
    e_and_l "$OK_TAG"
  else
    e_and_l "$ERROR_TAG"
  fi
  add_full_log
  e_and_l "$FULL_LINE"
fi

###############################################################################
# Einrichtung und Optimierung von System-Einstellungen
###############################################################################
if [ ${OPTION_FLAG[listonly]} -eq 0 ] &&
   [ ${OPTION_FLAG[optimize]} -eq 1 ];
then

  CHANGES_MADE=0

  e_and_l " ${bold_blue}Einrichtung und Optimierung von System-Einstellungen${colors_off}"

  e_and_l "$HALF_LINE"
  e_and_l " ${bold_blue}Betriebssystem${colors_off}"
  e_and_l "$HALF_LINE"

  # ===========================================================================
  # Umstellung der Systemzeit auf RTC wie bei Microsoft Windows (statt UTC)
  # ===========================================================================
  IS_MULTI_BOOT=0
  if [ -d "/boot/efi/EFI/Microsoft/Boot" ];
  then
    IS_MULTI_BOOT=1
  else
    grub_config="/boot/grub/grub.cfg"
    if [ -f "$grub_config" ];
    then
      if [ $(grep -c -i -E "windows" "$grub_config" 2>/dev/null) -gt 0 ];
      then
        IS_MULTI_BOOT=1
      fi
    fi
  fi
  if [ $IS_MULTI_BOOT -ne 0 ];
  then
    ACTION_MESSAGE=" Umstellung der ${light_cyan}Systemzeit auf RTC${colors_off} (MS Win)"
    if timedatectl &>/dev/null;
    then
      if [ $(timedatectl show 2>/dev/null | grep -c -i -E "^\s*LocalRTC\s*=\s*yes") -eq 0 ];
      then
        e_and_l " ${bold_white}Multi-Boot-System${colors_off} mit MS Windows gefunden. MS Windows verwendet statt UTC das"
        e_and_l " RTC-Format für Datum und Uhrzeit, was zu unterschiedlichen Zeitangaben führt."
        ask_yes_or_no " Die ${light_cyan}Systemzeit auf RTC${colors_off} wie bei MS Windows umstellen"
        if [ $? -eq 1 ];
        then
          e_and_l -n "${ACTION_MESSAGE//96m/93m} ... "
          timedatectl set-local-rtc 1 --adjust-system-clock 2>/dev/null
          if [ $? -eq 0 ];
          then
            e_and_l "$OK_TAG"
          else
            e_and_l "$ERROR_TAG"
          fi
        fi
      else
        e_and_l "$ACTION_MESSAGE ... $NC_TAG"
      fi
    else
      e_and_l "$(skip_text "$ACTION_MESSAGE" "$NA_TXT")"
    fi
  fi

  # ===========================================================================
  # Aktivierung der Betriebssystem-Erkennung
  # ===========================================================================
  ACTION_MESSAGE=" Aktivierung der ${light_cyan}Betriebssystem-Erkennung${colors_off}  "
  GRUB_FILE="/etc/default/grub"
  if [ -s "$GRUB_FILE" ];
  then
    if [ $(cat "$GRUB_FILE" | grep -i -c -E "^\s*GRUB_DISABLE_OS_PROBER\s*=\s*\"*true\"*\s*") -gt 0 ];
    then
      ask_yes_or_no " Die Erkennung anderer ${light_cyan}Betriebssysteme${colors_off} aktivieren"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m} ... "
        sed -i 's/^\s*GRUB_DISABLE_OS_PROBER\s*=\s*"*true"*/GRUB_DISABLE_OS_PROBER="false"/' "$GRUB_FILE" 2>/dev/null
        if [ $? -eq 0 ];
        then
          update-grub &>/dev/null
          if [ $? -eq 0 ];
          then
            e_and_l "$OK_TAG"
          else
            e_and_l "$ERROR_TAG"
          fi
        else
          e_and_l "$ERROR_TAG"
        fi
      fi
    else
      e_and_l "$ACTION_MESSAGE ... $NC_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$NA_TXT")"
  fi

  # ===========================================================================
  # Einschalten der internen Firewall (ufw) und auschalten der UFW-Protokolle
  # ===========================================================================
  ASKED_UFW_INST_NO=0
  ACTION_MESSAGE=" Einschalten der internen ${light_cyan}Firewall (ufw)${colors_off}"
  if [ $(LANG=en dpkg-query -W -f='${Status}' "ufw" 2>/dev/null | grep -i -c -E "ok installed") -gt 0 ];
  then
    UFW_IS_INSTALLED=1
  else
    if [ $(apt list "ufw" 2>/dev/null | grep -i -c -E "ufw") -gt 0 ];
    then
      ask_yes_or_no " Soll die ${light_cyan}Firewall (ufw)${colors_off} installiert werden"
      if [ $? -eq 1 ];
      then
        e_and_l -n " Installiere ${light_yellow}Firewall (ufw)${colors_off}, bitte warten   ... "
        apt install "ufw" -y &>"$LOG_TEMP"
        if [ $? -eq 0 ];
        then
          UFW_IS_INSTALLED=1
          # Wenn das geklappt hat, auch die grafische Oberfläche dazu laden -----
          if [ $(LANG=en dpkg-query -W -f='${Status}' "gufw" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ] &&
             [ $(apt list "gufw" 2>/dev/null | grep -i -c -E "gufw") -gt 0 ];
          then
            apt install "gufw" -y &>"$LOG_TEMP"
          fi
          # ---------------------------------------------------------------------
          e_and_l "$OK_TAG"
        else
          UFW_IS_INSTALLED=0
          e_and_l "$ERROR_TAG"
          add_full_log
        fi
      else
        ASKED_UFW_INST_NO=1
        UFW_IS_INSTALLED=0
      fi
    else
      UFW_IS_INSTALLED=0
    fi
  fi
  if [ $UFW_IS_INSTALLED -eq 1 ];
  then
    # Firewall einschalten ----------------------------------------------------
    if [ $(LANG=en ufw status 2>/dev/null | grep -i -c -E "status\s*:\s*a") -eq 0 ];
    then
      ask_yes_or_no "$ACTION_MESSAGE"
      if [ $? -eq 1 ];
      then
        e_and_l -n " Schalte die interne ${light_yellow}Firewall (ufw)${colors_off} ein     ... "
        ufw enable &>/dev/null
        if [ $? -eq 0 ];
        then
          ufw reload &>/dev/null
          e_and_l "$OK_TAG"
          CHANGES_MADE=1
        else
          e_and_l "$ERROR_TAG"
          add_full_log
        fi
      fi
    else
      e_and_l "$ACTION_MESSAGE    ... $NC_TAG"
    fi
    # Protokollierung ausschalten ---------------------------------------------
    ACTION_MESSAGE=" Ausschalten der ${light_cyan}Firewall-Protokoll-Logs${colors_off}"
    if [ $(LANG=en ufw status 2>/dev/null | grep -i -c -E "status\s*:\s*a") -gt 0 ];
    then
      if [ $(LANG=en ufw status verbose 2>/dev/null | grep -i -c -E "Proto.*\:\s*off$") -eq 0 ] &&
         [ $(LANG=en ufw status verbose 2>/dev/null | grep -i -c -E "Logging\s*\:\s*off$") -eq 0 ];
      then
        ask_yes_or_no "$ACTION_MESSAGE"
        if [ $? -eq 1 ];
        then
          e_and_l -n " Schalte das ${light_yellow}Protokoll-Log der Firewall${colors_off} aus ... "
          ufw logging off &>/dev/null
          if [ $? -eq 0 ];
          then
            ufw reload &>/dev/null
            e_and_l "$OK_TAG"
            CHANGES_MADE=1
          else
            e_and_l "$ERROR_TAG"
            add_full_log
          fi
        fi
      else
        e_and_l "$ACTION_MESSAGE    ... $NC_TAG"
      fi
    # else
    #   e_and_l "$(skip_text "$ACTION_MESSAGE   " "$NA_TXT")" # Firewall nicht aktiv
    fi
    # -------------------------------------------------------------------------
  else
     # Wenn die Installation verneint wurde, nicht nochmal
     # anzeigen dass die Firewall nicht installiert ist ;)
    if [ $ASKED_UFW_INST_NO -eq 0 ];
    then
      e_and_l "$(skip_text "$ACTION_MESSAGE   " "$NA_TXT")"
    fi
  fi

  # ===========================================================================
  # Aktivierung des SSH-Server bei Systemstart
  # (einschließlich Installation von openssh-server und sshguard)
  # ===========================================================================
  if [ $(apt list "openssh-server" 2>/dev/null | grep -i -c -E "openssh-server") -gt 0 ];
  then
    ASKED_SSH_INST_NO=0
    if [ $(LANG=en dpkg-query -W -f='${Status}' "openssh-server" 2>/dev/null | grep -i -c -E "ok installed") -gt 0 ];
    then
      OPENSSH_INSTALL_STATUS=0
    else
      ask_yes_or_no " Installation des ${light_cyan}OpenSSH-Servers${colors_off}"
      if [ $? -eq 1 ];
      then
        e_and_l -n " Installiere ${light_yellow}openssh-server${colors_off}, bitte warten   ... "
        apt install "openssh-server" -y &>"$LOG_TEMP"
        OPENSSH_INSTALL_STATUS=$?
        if [ $OPENSSH_INSTALL_STATUS -eq 0 ];
        then
          e_and_l "$OK_TAG"
          # zusätzlich sshguard installieren ----------------------------------
          if [ $(LANG=en dpkg-query -W -f='${Status}' "sshguard" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ] &&
             [ $(apt list "sshguard" 2>/dev/null | grep -i -c -E "sshguard") -gt 0 ];
          then
            e_and_l -n " Installiere ${light_yellow}sshguard${colors_off}, bitte warten         ... "
            apt install "sshguard" -y &>"$LOG_TEMP"
            if [ $? -eq 0 ];
            then
              e_and_l "$OK_TAG"
            else
              e_and_l "$ERROR_TAG"
              add_full_log
            fi
          fi
        else
          e_and_l "$ERROR_TAG"
          add_full_log
        fi
      else
        ASKED_SSH_INST_NO=1
        OPENSSH_INSTALL_STATUS=1
      fi
    fi
    # Nur weitermachen, wenn openssh-server installiert ist -------------------
    if [ $ASKED_SSH_INST_NO -eq 0 ];
    then
      ACTION_MESSAGE=" Aktivierung des ${light_cyan}SSH-Server${colors_off} bei Systemstart"
      TEMP_MSG="$ACTION_MESSAGE ... "
      if [ $OPENSSH_INSTALL_STATUS -eq 0 ];
      then
        if [ $(LANG=en systemctl is-enabled ssh 2>/dev/null | grep -i -c -E "enabled") -eq 0 ];
        then
          ask_yes_or_no "$ACTION_MESSAGE"
          if [ $? -eq 1 ];
          then
            e_and_l -n " Aktiviere den ${light_yellow}SSH-Server${colors_off} bei Systemstart   ... "
            systemctl enable ssh &>"$LOG_TEMP"
            if [ $? -eq 0 ];
            then
              e_and_l "$OK_TAG"
              CHANGES_MADE=1
            else
              e_and_l "$ERROR_TAG $LINENO"
              add_full_log
            fi
            systemctl start ssh &>/dev/null
          fi
        else
          TEMP_MSG+="$NC_TAG"
          e_and_l "$TEMP_MSG"
        fi
      else # openssh-server nicht installiert
        e_and_l "$(skip_text "$TEMP_MSG" "$NA_TXT")"
      fi
    fi
  else # openssh-server nicht verfügbar
    e_and_l "$(skip_text " Installation u. Einrichtung des SSH-Server" "$NA_TXT")"
  fi

  # ===========================================================================
  # Reduzierung des Swappings
  # Werte von 0 (wenig) bis 100 (viel)
  # ACHTUNG: 0 = kein Swapping => nur verwenden, wenn soviel Hauptspeicher
  # vorhanden ist, dass Swapping durch das System ausgeschlossen werden kann!
  # ===========================================================================
  # Schwellwert (verbleibender freier Hauptspeicher in MB), ab welchem das
  # Betriebssystem anfängt Hauptspeicher auf Festplatten auszulagern (swappen)
  START_SWAP_FREE=512
  # Kleinster einzugebender neuer Wert (in %)
  MIN_SWAPPING=1
  # Größter einzugebender neuer Wert (in %)
  MAX_SWAPPING=60 # Standardvorgabe Linux
  # Datei mit permanenter Einstellung
  SYSCTL_CONF="/etc/sysctl.conf"
  # Optimalen Wert berechnen --------------------------------------------------
  BEST_SWAP_SIZE=$((START_SWAP_FREE * 1024 * 1024))
  BEST_SWAP_SIZE=$((BEST_SWAP_SIZE * 100 / MEMORY_TOTAL))
  # Aktuellen Wert auslesen ---------------------------------------------------
  SWAP_VALUE=$(sysctl vm.swappiness)
  SWAP_VALUE=$(echo -n "${SWAP_VALUE##*\=}" | xargs)
  SEARCH_SWAP_STRING="^vm.swappiness\s*=\s*$BEST_SWAP_SIZE"
  ACTION_MESSAGE=" Einstellung des ${light_cyan}Swapping${colors_off} von Hauptspeicher ... "
  if [ $SWAP_VALUE -eq $BEST_SWAP_SIZE ] &&
     [ -s "$SYSCTL_CONF" ] &&
     [ $(grep -i -c -E "$SEARCH_SWAP_STRING" "$SYSCTL_CONF" 2>/dev/null) -gt 0 ];
  then
    e_and_l -n "$ACTION_MESSAGE"
    e_and_l "$OK_TAG ${dark_grey}(Wert: $SWAP_VALUE%)${colors_off}"
  else
    e_and_l " Der ${light_cyan}Swapping-Wert${colors_off} liegt bei ${light_cyan}$SWAP_VALUE${colors_off}, für dieses System wird ${light_yellow}$BEST_SWAP_SIZE${colors_off} empfohlen."
    ask_yes_or_no " Einstellung des ${light_cyan}Swapping-Wertes${colors_off} jetzt ändern"
    if [ $? -eq 1 ];
    then
      NEW_SWAPPING=0
      while [ $NEW_SWAPPING -lt $MIN_SWAPPING ] ||
            [ $NEW_SWAPPING -gt $MAX_SWAPPING ];
      do
        e_and_l -n " Bitte neuen Wert eingeben von ${bold_yellow}$MIN_SWAPPING${colors_off} bis ${bold_yellow}$MAX_SWAPPING${colors_off}"
        read -p ": " NEW_SWAPPING
        NEW_SWAPPING=$(echo $NEW_SWAPPING | sed 's/[^0-9]*//g')
        if [ "$NEW_SWAPPING" = "" ]; then NEW_SWAPPING=0; fi
      done
      e_and_l -n "$ACTION_MESSAGE"
      # Sofort ------------------------------------------------------------------
      if [ $SWAP_VALUE -ne $NEW_SWAPPING ];
      then
        sysctl vm.swappiness=${NEW_SWAPPING} &>/dev/null
      fi
      # Permanent ---------------------------------------------------------------
      create_backup_file "$SYSCTL_CONF"
      # Alle eventuell bestehenden Einträge löschen
      if [ -s "$SYSCTL_CONF" ];
      then
        SEARCH_SWAP_STRING="^vm.swappiness\s*=\s*"
        OLD_ENTRY_LINE=$(grep -i -m 1 -n -E "$SEARCH_SWAP_STRING" "$SYSCTL_CONF" 2>/dev/null)
        while [ "$OLD_ENTRY_LINE" != "" ];
        do
          DELETE_PART=${OLD_ENTRY_LINE##*\:}
          OLD_ENTRY_LINE=$(echo ${OLD_ENTRY_LINE/:$DELETE_PART/} | xargs)
          sed -i "${OLD_ENTRY_LINE}d" "$SYSCTL_CONF"
          OLD_ENTRY_LINE=$(grep -i -m 1 -n -E "$SEARCH_SWAP_STRING" "$SYSCTL_CONF" 2>/dev/null)
        done
      fi
      # Neuen Eintrag hinzufügen
      echo -e "vm.swappiness=$NEW_SWAPPING" >> "$SYSCTL_CONF"
      if [ $? -eq 0 ];
      then
        e_and_l "$OK_TAG ${light_yellow}(NEU: $NEW_SWAPPING%)${colors_off}"
        CHANGES_MADE=1
      else
        e_and_l "$ERROR_TAG"
        add_full_log
      fi
    fi
  fi

  # ===========================================================================
  # Reduzierung unnötiger Schreibvorgänge auf Festplatten
  # ===========================================================================
  ACTION_MESSAGE=" Reduzierung unnötiger ${light_cyan}Festplatten-Zugriffe${colors_off} ... "
  if [ -s "/etc/fstab" ];
  then
    FSTAB_EXT4_LINES=$(grep -i -c -E "\sext4\s" "/etc/fstab")
    FSTAB_AUTO_LINES=$(grep -i -c -E "\sauto\s" "/etc/fstab")
    FSTAB_RELEVANT_LINES=$((FSTAB_EXT4_LINES+FSTAB_AUTO_LINES))
    FSTAB_NOATIME_EXT4_LINES=$(grep -i -c -E "\sext4\s*.*noatime" "/etc/fstab")
    FSTAB_NOATIME_AUTO_LINES=$(grep -i -c -E "\sauto\s*.*noatime" "/etc/fstab")
    FSTAB_OCCURES_LINES=$((FSTAB_NOATIME_EXT4_LINES+FSTAB_NOATIME_AUTO_LINES))
    if [ $FSTAB_RELEVANT_LINES -ne $FSTAB_OCCURES_LINES ]
    then
      ask_yes_or_no " Unnötige ${light_cyan}Festplatten-Zugriffe${colors_off} reduzieren"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m}"
        create_backup_file "/etc/fstab"
        # 1. "noatime" an allen relevanten Stellen hinzufügen. Dazu werden alle
        # Dateisysteme im Format "ext4" und "auto" als relevant angesehen
        sed -i -E "s/(\s*\sext4\s\s*)/\1noatime,/g" "/etc/fstab"
        sed -i -E "s/(\s*\sauto\s\s*)/\1noatime,/g" "/etc/fstab"
        # 2. Bestehende oder entstandene Mehrfacheinträge von "noatime" korrigieren
        sed -i -E "s/(noatime.*),noatime/\1/g" "/etc/fstab"
        sed -i -E "s/noatime,(.*noatime)/\1/g" "/etc/fstab"
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG"
          CHANGES_MADE=1
        else
          e_and_l "$ERROR_TAG"
        fi
      fi
    else
      e_and_l "$ACTION_MESSAGE$NC_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "keine fstab!")"
  fi

  # ===========================================================================
  # Temporäre System-Ordner ins RAM verlagern (NICHT eigene RAM Disk - s.u.)
  # Das erstellte Laufwerk (tmpfs) ist dynamisch und belegt nur soviel Memory
  # wie es braucht, maximal 50% des zur Verfügung stehenden Hauptspeichers
  # ACHTUNG: Diesen Teil immer VOR der Erstellung der permanenten dynamischen
  #          RAM Disk lassen, weil hier REDUCE_TMP_RAM ermittelt wird!
  # ===========================================================================
  REDUCE_TMP_RAM=0
  ACTION_MESSAGE=" Ordner ${light_cyan}/tmp${colors_off} in den ${light_cyan}Hauptspeicher${colors_off} auslagern"
  if [ -s "/etc/fstab" ];
  then
    HALF_TOTAL_MEMORY=$((MEMORY_TOTAL / 2))
    RAMDISK_ENABLED_SIZE=$(get_tmpfs_size "$RAMDISK_MOUNTPOINT")
    RAMDISK_ENABLED_SIZE=$((RAMDISK_ENABLED_SIZE * 1024 * 1024))
    FREE_FOR_TMP_DIR=$((MEMORY_TOTAL - MIN_LINUX_RAM - RAMDISK_ENABLED_SIZE))
    TEMP_MSG="$ACTION_MESSAGE ..."
    if [ $(cat "/etc/fstab" | grep -i -c -E "^\s*tmpfs\s*\/tmp\s*tmpfs") -gt 0 ];
    then
      e_and_l "$TEMP_MSG $NC_TAG"
      REDUCE_TMP_RAM=1
    else
      # Abfrage ---------------------------------------------------------------
      # Wenn nach Abzug einer ev. vorhandenen RAM Disk und der Sicherheitsreserve für Linux
      # noch Platz ist, dann anbieten /tmp in den Hauptspeicher zu verlagern ...
      FREE_MEMORY=$(show_human_bytes ${MEMORY_AVAIL} "M")
      if [ $FREE_FOR_TMP_DIR -gt $HALF_TOTAL_MEMORY ];
      then
        e_and_l " Es sind ${light_yellow}$FREE_MEMORY${colors_off} Hauptspeicher frei - Vorschläge zur Verwendung:"
        ask_yes_or_no " 1.$ACTION_MESSAGE"
        DO_MOVE_TMP=$?
      else # ... sonst fragen ob das trotzdem gewollt ist
        e_and_l " Es sind nur ${light_yellow}$FREE_MEMORY${colors_off} Hauptspeicher frei. Soll der Ordner ${light_cyan}/tmp${colors_off} trotzdem in den"
        ask_yes_or_no " ${light_cyan}Hauptspeicher${colors_off} auslagert werden (NICHT empfohlen)"
        DO_MOVE_TMP=$?
      fi
      # Auslagern -------------------------------------------------------------
      if [ $DO_MOVE_TMP -eq 1 ];
      then
        e_and_l -n " Verlagere Ordner ${light_yellow}/tmp${colors_off} in den ${light_yellow}Hauptspeicher${colors_off} ... "
        create_backup_file "/etc/fstab"
        # Wenn es den Eintrag schon gibt, diesen auskommentieren ...
        if [ $(cat "/etc/fstab" | grep -i -c -E "^#\s*tmpfs\s\s*\/tmp\s\s*tmpfs\s\s*noatime,nosuid,mode=1777\s\s*0\s\s*0") -gt 0 ];
        then
          sed -i -E "s/^#\s*tmpfs\s\s*\/tmp\s\s*tmpfs\s\s*noatime,nosuid,mode=1777\s\s*0\s\s*0/tmpfs  \/tmp  tmpfs  noatime,nosuid,mode=1777  0  0/g" "/etc/fstab"
        else # ... sonst neu anlegen
          echo -e "tmpfs  /tmp  tmpfs  noatime,nosuid,mode=1777  0  0" >> "/etc/fstab" 2>"$LOG_TEMP"
        fi
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG (${light_yellow}Neustart erforderlich${colors_off})"
          CHANGES_MADE=1
          REDUCE_TMP_RAM=1
        else
          restore_backup_file "/etc/fstab"
          e_and_l "$ERROR_TAG $LINENO"
          add_full_log
        fi
      fi
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "keine fstab!")"
  fi

  # ===========================================================================
  # Permanente dynamische RAM Disk einrichten (NICHT /tmp verlagern - s.o.)
  # Das erstellte Laufwerk (tmpfs) ist dynamisch und belegt nur soviel Memory
  # wie es braucht, maximal soviel Platz wie in der Eingabe angegeben wird
  # ACHTUNG: Diesen Teil immer HINTER der Verlagerung des temporären System-
  #          Ordners ins RAM lassen, weil dort REDUCE_TMP_RAM ermittelt wird!
  # ===========================================================================
  RAMDISK_MOUNTPOINT="/media/ramdisk"
  # Platz für ggf. ausgelagerten Ordner /tmp freilassen (s.o.)
  REDUCE_TMP_RAM=$((REDUCE_TMP_RAM * MEMORY_TOTAL / 2))
  # Verbleidener Platz für die RAM DISK
  FREE_FOR_RAMDISK=$((MEMORY_TOTAL - MIN_LINUX_RAM - REDUCE_TMP_RAM))
  FREE_FOR_RAMDISK=$((FREE_FOR_RAMDISK / 1024 / 1024))
  # ---------------------------------------------------------------------------
  ACTION_MESSAGE=" Permanente dynamische ${light_cyan}RAM Disk${colors_off} einrichten"
  if [ -s "/etc/fstab" ];
  then
    TEMP_MSG="$ACTION_MESSAGE  ..."
    RAMDISK_ENABLED_SIZE=$(get_tmpfs_size "$RAMDISK_MOUNTPOINT")
    if [ $RAMDISK_ENABLED_SIZE -gt 0 ];
    then
      e_and_l "$TEMP_MSG $OK_TAG ${dark_grey}(Wert: $RAMDISK_ENABLED_SIZE MB)${colors_off}"
    else
      if [ $FREE_FOR_RAMDISK -ge $RAMDISK_MIN_SIZE ];
      then
        ask_yes_or_no " 2.$ACTION_MESSAGE"
        if [ $? -eq 1 ];
        then
          RAMDISK_SIZE=0
          while [ $RAMDISK_SIZE -lt $RAMDISK_MIN_SIZE ] ||
                [ $RAMDISK_SIZE -gt $FREE_FOR_RAMDISK ];
          do
            if [ $FREE_FOR_RAMDISK -ge $BROWSER_CACHE_MIN_SIZE ];
            then
              e_and_l " ${bold_yellow}Tipp${colors_off}: Für die Verlagerung von Browser-Caches mind. ${light_yellow}$BROWSER_CACHE_MIN_SIZE${colors_off} (MB) angeben."
            fi
            e_and_l -n " Bitte maximale Größe angeben von ${bold_yellow}$RAMDISK_MIN_SIZE${colors_off} bis ${bold_yellow}$FREE_FOR_RAMDISK${colors_off} (MB)"
            read -p ": " RAMDISK_SIZE
            RAMDISK_SIZE=$(echo $RAMDISK_SIZE | sed 's/[^0-9]*//g')
            if [ "$RAMDISK_SIZE" = "" ]; then RAMDISK_SIZE=0; fi
          done
          ask_yes_or_no " Jetzt dynamische ${light_yellow}RAM Disk${colors_off} von ${light_yellow}max. $RAMDISK_SIZE MB${colors_off} anlegen"
          if [ $? -eq 1 ];
          then
            if [ $(df | grep -i -c -E "$RAMDISK_MOUNTPOINT") -gt 0 ];
            then
              e_and_l " ${bold_yellow}Ups${colors_off}, das Dateisystem ${light_cyan}$RAMDISK_MOUNTPOINT${colors_off} ist noch eingehangen."
              ask_yes_or_no " Jetzt aushängen (alle Daten darauf werden gelöscht)"
              if [ $? -eq 1 ];
              then
                umount "$RAMDISK_MOUNTPOINT" &>/dev/null
                RAMDISK_IS_MOUNTED=$?
              else
                RAMDISK_IS_MOUNTED=1
              fi
            else
              RAMDISK_IS_MOUNTED=0
            fi
            if [ $RAMDISK_IS_MOUNTED -eq 0 ];
            then
              e_and_l -n " Erstellung der neuen dynamischen ${light_cyan}RAM Disk${colors_off}  ... "
              if [ ! -d "$RAMDISK_MOUNTPOINT" ];
              then
                mkdir -p "$RAMDISK_MOUNTPOINT" &>"$LOG_TEMP"
              fi
              if [ -d "$RAMDISK_MOUNTPOINT" ];
              then
                chmod -R 0777 "$RAMDISK_MOUNTPOINT" &>/dev/null
                create_backup_file "/etc/fstab"
                echo -e "tmpfs  ${RAMDISK_MOUNTPOINT}  tmpfs  noatime,defaults,size=${RAMDISK_SIZE}M,x-gvfs-show,x-gvfs-name=RAM%20Disk  0  0" >> "/etc/fstab" 2>"$LOG_TEMP"
                if [ $? -eq 0 ];
                then
                  mount "$RAMDISK_MOUNTPOINT" &>"$LOG_TEMP"
                  e_and_l "$OK_TAG (${light_yellow}$RAMDISK_MOUNTPOINT${colors_off})"
                else
                  restore_backup_file "/etc/fstab"
                  e_and_l "$ERROR_TAG $LINENO"
                  add_full_log
                fi
              else
                e_and_l "$ERROR_TAG $LINENO"
                add_full_log
              fi
            else
              e_and_l " Sicherheitshalber wurde die ${light_cyan}RAM Disk${colors_off} ${bold_red}nicht${colors_off} neu erstellt!"
            fi
          fi
        fi
      else
        e_and_l "$TEMP_MSG ${bold_yellow}besser nicht${colors_off} ${dark_grey}(zu wenig Memory)${colors_off}"
      fi
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE " "keine fstab!")"
  fi

  # ===========================================================================
  # Verlagerung der Browser-Caches in den Hauptspeicher (RAM Disk)
  # ---------------------------------------------------------------------------
  # Dazu wird ein Autostart-Eintrag angelegt, welcher mittels eines Scripts
  # "browser-cache-to-ram" bei der Anmeldung des Benutzers für jeden Browser
  # einen Unterordner auf einer dynamischen RAM Disk (sofern diese angelegt
  # ist) erstellt, sowie die Cache-Ordner dorthin umlenkt.
  # ===========================================================================
  THE_BCD_SCRIPT_NAME="browser-cache-to-ram"
  THE_BCD_SCRIPT_DIR="$USER_HOME_DIR/.local/bin"
  THE_BCD_SCRIPT_FILE="$THE_BCD_SCRIPT_DIR/$THE_BCD_SCRIPT_NAME"
  ACTION_MESSAGE=" ${light_cyan}Browser-Caches${colors_off} auf die ${light_cyan}RAM Disk${colors_off} verlagern "
  if [ "$USER_USERNAME" != "root" ];
  then
    if [ ! -s "$THE_BCD_SCRIPT_FILE" ];
    then
      CHECK_RAMDISK_SIZE=$(get_tmpfs_size "/media/ramdisk")
      if [ $CHECK_RAMDISK_SIZE -ge $BROWSER_CACHE_MIN_SIZE ];
      then
        ask_yes_or_no "$ACTION_MESSAGE"
        if [ $? -eq 1 ];
        then
          e_and_l -n " Verlagere ${light_yellow}Browser-Caches${colors_off} auf die ${light_yellow}RAM Disk${colors_off}  ... "
          # 1. Download des Scriptes zur Anlage der Ordner und Verknüpfungen
          DOWNLOAD_FILE_URL="$RESSOURCE_SERVER_DIR/scripts/$THE_BCD_SCRIPT_NAME"
          DOWNLOAD_FILE_NAME="${DOWNLOAD_FILE_URL##*/}"
          LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$DOWNLOAD_FILE_NAME"
          wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$DOWNLOAD_FILE_URL" &>"$LOG_TEMP"
          if [ $? -eq 0 ] &&
             [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
             [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
          then
            chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
            if [ ! -d "$THE_BCD_SCRIPT_DIR" ];
            then
              mkdir -p "$THE_BCD_SCRIPT_DIR" &>"$LOG_TEMP"
              chown -R "$USER_USERNAME:$USER_USERNAME" "$THE_BCD_SCRIPT_DIR" &>/dev/null
            fi
            if [ -d "$THE_BCD_SCRIPT_DIR" ];
            then
              create_backup_file "$THE_BCD_SCRIPT_FILE"
              mv -f "$LOCAL_DOWNLOAD_FILE" "$THE_BCD_SCRIPT_FILE" &>"$LOG_TEMP"
              if [ $? -eq 0 ];
              then
                chown "$USER_USERNAME:$USER_USERNAME" "$THE_BCD_SCRIPT_FILE" &>/dev/null
                chmod 0744 "$THE_BCD_SCRIPT_FILE" &>/dev/null
                # 2. Autostart-Eintrag für das Script erzeugen
                create_autostart_file "$USER_CONFIG_DIR/autostart/$THE_BCD_SCRIPT_NAME.desktop" "Browser-Caches to RAM" "Verlagert Browser-Cache-Ordner auf die RAM Disk und passt die Standard-Ordner je nach Existenz der RAM-Ordner entsprechend an" "$THE_BCD_SCRIPT_FILE" "browser"
                if [ $? -eq 0 ];
                then
                  # 3. Script starten
                  THE_EVAL_ACTION="$THE_BCD_SCRIPT_FILE \"$USER_USERNAME\" -quiet"
                  { eval "$THE_EVAL_ACTION" 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
                  if [ $(cat "$LAST_EXIT_CODE") -eq 0 ];
                  then
                    e_and_l "$OK_TAG"
                    CHANGES_MADE=1
                  else
                    e_and_l "$ERROR_TAG $LINENO"
                    add_full_log
                  fi
                else
                  e_and_l "$ERROR_TAG $LINENO"
                  add_full_log
                fi
              else
                restore_backup_file "$THE_BCD_SCRIPT_FILE"
                e_and_l "$ERROR_TAG $LINENO"
                add_full_log
              fi
            else
              e_and_l "$ERROR_TAG $LINENO"
              add_full_log
            fi
          else
            e_and_l "$ERROR_TAG $LINENO"
            remove_file "$LOCAL_DOWNLOAD_FILE"
            add_full_log
          fi
        fi
      else
        e_and_l "$(skip_text "$ACTION_MESSAGE" "ab $BROWSER_CACHE_MIN_SIZE MB RDisk")"
      fi
    else
      e_and_l "$ACTION_MESSAGE ... $NC_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$NR_TXT")"
  fi

  # ===========================================================================
  # WiFi-Geschwindigkeit für Intel-Chipsatz erhöhen
  # ===========================================================================
  ACTION_MESSAGE=" Erhöhung des ${light_cyan}WiFi-Datendurchsatzes${colors_off} (Intel)"
  if [ $(lsmod | grep -i -c -E "^iwlwifi") -ne 0 ];
  then
    WLAN_CONF_FILE="/etc/modprobe.d/iwlwifi-speed.conf"
    WLAN_CONF_TEXT="options iwlwifi 11n_disable=8"
    if [ -s "$WLAN_CONF_FILE" ] &&
       [ $(grep -i -c -E "$WLAN_CONF_TEXT" "$WLAN_CONF_FILE" 2>/dev/null) -gt 0 ];
    then
      e_and_l "$ACTION_MESSAGE ... $NC_TAG"
    else
      ask_yes_or_no "$ACTION_MESSAGE"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m} ..."
        create_backup_file "$WLAN_CONF_FILE"
        echo "$WLAN_CONF_TEXT" >> "$WLAN_CONF_FILE" 2>/dev/null
        modprobe -r iwlwifi &>/dev/null
        modprobe iwlwifi &>/dev/null
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG"
          CHANGES_MADE=1
        else
          e_and_l "$ERROR_TAG"
          remove_file "$WLAN_CONF_FILE"
          restore_backup_file "$WLAN_CONF_FILE"
        fi
      fi
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$NV_TXT")"
  fi

  # ===========================================================================
  # Stabilisierung des WLAN-Durchsatzes durch Ausschalten des Power-Management
  # ===========================================================================
  ACTION_MESSAGE=" Stabilisierung des ${light_cyan}WiFi-Datendurchsatzes${colors_off}"
  WLAN_CONF_FILE="/etc/NetworkManager/conf.d/default-wifi-powersave-on.conf"
  if [ -s "$WLAN_CONF_FILE" ];
  then
    if [ $(grep -i -c -E "wifi.powersave\s*=\s*2" "$WLAN_CONF_FILE" 2>/dev/null) -gt 0 ];
    then
      e_and_l "$ACTION_MESSAGE   ... $NC_TAG"
    else
      ask_yes_or_no "$ACTION_MESSAGE"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m}  "
        create_backup_file "$WLAN_CONF_FILE"
        sed -i -E "s/wifi\.powersave\s*\=\s*[0-9]*/wifi.powersave = 2/g" "$WLAN_CONF_FILE"
        if [ $? -eq 0 ];
        then
          e_and_l " ... $OK_TAG"
          CHANGES_MADE=1
        else
          e_and_l " ... $ERROR_TAG $LINENO"
        fi
      fi
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE  " "kein PowerMgmnt")"
  fi

  # ===========================================================================
  # Flackern der WiFi-LED bei Netzwerk-Traffik ausschalten
  # ===========================================================================
  ACTION_MESSAGE=" Traffikflackern der ${light_cyan}WiFi-LED${colors_off} ausschalten"
  if [ $(lsmod | grep -i -c -E "^iwlwifi") -ne 0 ];
  then
    WLAN_CONF_FILE="/etc/modprobe.d/wlan.conf"
    WLAN_CONF_TEXT="options iwlwifi led_mode=1"
    if [ -s "$WLAN_CONF_FILE" ] &&
       [ $(grep -i -c -E "$WLAN_CONF_TEXT" "$WLAN_CONF_FILE" 2>/dev/null) -gt 0 ];
    then
      e_and_l "$ACTION_MESSAGE   ... $NC_TAG"
    else
      ask_yes_or_no "$ACTION_MESSAGE"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m}   ... "
        create_backup_file "$WLAN_CONF_FILE"
        echo "$WLAN_CONF_TEXT" >> "$WLAN_CONF_FILE" 2>/dev/null
        modprobe -r iwlwifi &>/dev/null
        modprobe iwlwifi &>/dev/null
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG"
          CHANGES_MADE=1
        else
          e_and_l "$ERROR_TAG"
          remove_file "$WLAN_CONF_FILE"
          restore_backup_file "$WLAN_CONF_FILE"
        fi
      fi
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE  " "$NV_TXT")"
  fi

  # ===========================================================================
  # Fehlerberichte deaktivieren
  # ===========================================================================
  ACTION_MESSAGE=" Deaktivierung der ${light_cyan}Fehlerbericht-Erstellung${colors_off}"
  # Wenn es apport oder whoopsie gibt
  if [ $(apt list "apport" 2>/dev/null | grep -i -c -E "apport") -gt 0 ] ||
     [ $(apt list "whoopsie" 2>/dev/null | grep -i -c -E "whoopsie") -gt 0 ];
  then
    APPORT_INSTALL_STATUS=$(LANG=en dpkg-query -W -f='${Status}' "apport" 2>/dev/null | grep -i -c -E "ok installed")
    WHOOPSIE_INSTALL_STATUS=$(LANG=en dpkg-query -W -f='${Status}' "whoopsie" 2>/dev/null | grep -i -c -E "ok installed")
    # Wenn apport oder whoopsie installiert sind, diese deinstallieren
    if [ $APPORT_INSTALL_STATUS -gt 0 ] ||
       [ $WHOOPSIE_INSTALL_STATUS -gt 0 ];
    then
      ask_yes_or_no " Erstellung von ${light_cyan}Fehlerberichten${colors_off} komplett deaktivieren"
      if [ $? -eq 1 ];
      then
        e_and_l " Ok, die Module zur ${light_yellow}Fehlerbericht-Erstellung${colors_off} werden jetzt entfernt."
        echo -e "$HALF_MINUS_LINE"
        if [ $APPORT_INSTALL_STATUS -gt 0 ];
        then
          INST_STATUS=1
          remove_pkg apport 0
          echo -e "$HALF_MINUS_LINE"
        fi
        if [ $WHOOPSIE_INSTALL_STATUS -gt 0 ];
        then
          INST_STATUS=1
          remove_pkg whoopsie 0
          echo -e "$HALF_MINUS_LINE"
        fi
      else
        # Wenn die System-Fehlerberichte nicht komplett deaktiviert werden sollen,
        # fragen ob nur die Sendung der Berichte unterbunden werden soll ...
        ACTION_MESSAGE=" Ausschalten der ${light_cyan}Sendung der Fehlerberichte${colors_off} ... "
        APPORT_FILE="/etc/default/apport"
        if [ -s "$APPORT_FILE" ];
        then
          APPORT_FILE_STATUS=$(cat "$APPORT_FILE" | grep -i -c -E "^\s*enabled\s*=\s*0")
          APPORT_SERVICE_STATUS=$(LANG=en systemctl is-enabled apport 2>/dev/null | grep -i -c -E "^\s*disabled")
          if [ $APPORT_FILE_STATUS -eq 0 ] ||
             [ $APPORT_SERVICE_STATUS -eq 0 ];
          then
            ask_yes_or_no " Sendung der ${light_cyan}Fehlerberichte${colors_off} ausschalten"
            if [ $? -eq 1 ];
            then
              e_and_l -n "${ACTION_MESSAGE//96m/93m}"
              # 1. Datei
              APPORT_FILE_RESULT=0
              if [ $APPORT_FILE_STATUS -eq 0 ];
              then
                create_backup_file "$APPORT_FILE"
                sed -i "s/enabled=1/enabled=0/g" "$APPORT_FILE"
                APPORT_FILE_RESULT=$?
              fi
              # 2. Service
              APPORT_SERVICE_RESULT=0
              if [ $APPORT_SERVICE_STATUS -eq 0 ];
              then
                systemctl stop apport &>"$LOG_TEMP"
                systemctl disable apport &>"$LOG_TEMP"
                APPORT_SERVICE_RESULT=$?
              fi
              # Ergebnis
              if [ $APPORT_FILE_RESULT -eq 0 ] &&
                 [ $APPORT_SERVICE_RESULT -eq 0 ];
              then
                e_and_l "$OK_TAG"
                CHANGES_MADE=1
              else
                e_and_l "$ERROR_TAG"
                add_full_log
              fi
            fi
          else
            e_and_l "$ACTION_MESSAGE$NC_TAG"
          fi
        fi
      fi
    else # (wenn es apport oder whoopsie gibt, aber beide nicht installiert sind)
      e_and_l "$ACTION_MESSAGE ... $NC_TAG"
    fi
  else # (wenn es überhaupt kein apport und auch kein whoopsie gibt)
    e_and_l "$(skip_text "$ACTION_MESSAGE" "nur bei Ubuntu")"
  fi

  # ===========================================================================
  # Anzahl und Größe der System-Log-Dateien begrenzen
  # ===========================================================================
  ANZ_LOG_DAYS=5   # Tage
  MAX_LOG_SIZE=100 # MB
  # ----------------------
  ACTION_MESSAGE=" Begrenzung gespeicherter ${light_cyan}System-Logdateien${colors_off} ... "
  VALUE_MESSAGE="$ANZ_LOG_DAYS Tage und $MAX_LOG_SIZE MB"
  SYSLOG_CFG_FILE="/etc/systemd/journald.conf"
  if [ -s "$SYSLOG_CFG_FILE" ];
  then
    if [ $(cat "$SYSLOG_CFG_FILE" | grep -i -c -E "^\s*SystemMaxFiles\s*=\s*${ANZ_LOG_DAYS}d") -eq 0 ] ||
       [ $(cat "$SYSLOG_CFG_FILE" | grep -i -c -E "^\s*SystemMaxFileSize\s*=\s*${MAX_LOG_SIZE}M") -eq 0 ] ||
       [ $(cat "$SYSLOG_CFG_FILE" | grep -i -c -E "^\s*SystemMaxUse\s*=\s*${MAX_LOG_SIZE}M") -eq 0 ];
    then
      ask_yes_or_no " Speicherplatz für ${light_cyan}System-Logdateien${colors_off} begrenzen"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m}"
        create_backup_file "$SYSLOG_CFG_FILE"
        # Neue Werte sofort setzen
        journalctl --vacuum-time="${ANZ_LOG_DAYS}d" &>/dev/null
        journalctl --vacuum-size="${MAX_LOG_SIZE}M" &>/dev/null
        # Neue Werte permanent einstellen
        sed -i "s/^#*\s*SystemMaxFiles\s*=\s*[0-9]*[a-zA-Z]*/SystemMaxFiles=${ANZ_LOG_DAYS}d/g" "$SYSLOG_CFG_FILE"
        sed -i "s/^#*\s*SystemMaxFileSize\s*=\s*[0-9]*[a-zA-Z]*/SystemMaxFileSize=${MAX_LOG_SIZE}M/g" "$SYSLOG_CFG_FILE"
        sed -i "s/^#*\s*SystemMaxUse\s*=\s*[0-9]*[a-zA-Z]*/SystemMaxUse=${MAX_LOG_SIZE}M/g" "$SYSLOG_CFG_FILE"
        # Log-Dienst mit geänderter Konfiguration neu starten
        service systemd-journald restart &>/dev/null
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG ${light_yellow}(NEU: $VALUE_MESSAGE)${colors_off}"
          CHANGES_MADE=1
        else
          e_and_l "$ERROR_TAG"
          add_full_log
        fi
      fi
    else
      e_and_l "$ACTION_MESSAGE$OK_TAG ${dark_grey}(Wert: $VALUE_MESSAGE)${colors_off}"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$NA_TXT")"
  fi

  # ===========================================================================
  # Taktfrequenzen des Raspberry Pi 4 einstellen
  # ===========================================================================
  SHOW_SKIP_MESSAGE=""
  if [ $RASPBERRY -ne 0 ];
  then
    PI_CONF_FILE="/boot/config.txt"
    if [ -s "$PI_CONF_FILE" ];
    then
      if [ $(cat "$PI_CONF_FILE" | grep -i -c -E "\[pi4\]") -gt 0 ];
      then
        pi_perfname=('Low'  'Medium' 'High')
        pi_overvolt=('0'    '2'      '6'   )
        pi_arm_freq=('1500' '1750'   '2000')
        pi_gpu_freq=('500'  '600'    '750' )
        CURRENT_OVERVOLT="$(cat "$PI_CONF_FILE" | grep -i -E "^\s*over_voltage\s*=" | cut -d"=" -f 2 | xargs)"
        CURRENT_ARM_FREQ="$(cat "$PI_CONF_FILE" | grep -i -E "^\s*arm_freq\s*=" | cut -d"=" -f 2 | xargs)"
        CURRENT_GPU_FREQ="$(cat "$PI_CONF_FILE" | grep -i -E "^\s*gpu_freq\s*=" | cut -d"=" -f 2 | xargs)"
        CURRENT_PI_PERFNAME="Low" # Standard, wenn nichts anderes konfiguriert ist
        if [ "$CURRENT_ARM_FREQ" != "" ];
        then
          i=0
          for cpu_freq in ${pi_arm_freq[@]};
          do
            if [ $CURRENT_ARM_FREQ -ge $cpu_freq ];
            then
              CURRENT_PI_PERFNAME=${pi_perfname[$i]}
            fi
            ((i+=1))
          done
        fi
        e_and_l " Die aktuellen ${light_cyan}Taktfrequenzen${colors_off} dieses Pi sind auf ${light_yellow}$CURRENT_PI_PERFNAME-Performance${colors_off} eingestellt"
        ask_yes_or_no " Sollen die Taktfreqenzen geändert werden"
        if [ $? -eq 1 ];
        then
          echo -e " Bitte neues Performance-Profil auswählen"
          i=0
          for perfname in ${pi_perfname[@]};
          do
            echo -e " [${bold_yellow}$i${colors_off}] $perfname (${pi_arm_freq[$i]} MHz)"
            ((i+=1))
          done
          setterm -cursor off 2>/dev/null
          NEW_PERF_MODE=-1
          MAX_NEW_MODE=${#pi_perfname[@]}
          ((MAX_NEW_MODE-=1))
          while [ $NEW_PERF_MODE -lt 0 ] ||
                [ $NEW_PERF_MODE -gt $MAX_NEW_MODE ];
          do
            read -N 1 -r -s NEW_PERF_MODE
            NEW_PERF_MODE=$(echo $NEW_PERF_MODE | sed 's/[^0-9]*//g')
            if [ "$NEW_PERF_MODE" = "" ]; then NEW_PERF_MODE=-1; fi
          done
          setterm -cursor on 2>/dev/null
          ask_yes_or_no " Taktfrequenzen auf das Profil ${light_yellow}${pi_perfname[$NEW_PERF_MODE]}${colors_off} umstellen"
          if [ $? -eq 1 ];
          then
            e_and_l -n " OK, ändere Einstellung der ${light_yellow}Taktfrequenzen${colors_off}  ... "
            create_backup_file "$PI_CONF_FILE"
            # -----------------------------------------------------------------
            # 1. Zur Vermeidung und Bereinigung eventuell redundanter Eintragungen
            #    alle bestehenden Einträge deaktivieren (auskommentieren)
            # -----------------------------------------------------------------
            sed -i -E "s/(^\s*over_voltage\s*=)/\# \1/g" "$PI_CONF_FILE"
            sed -i -E "s/(^\s*arm_freq\s*=)/\# \1/g" "$PI_CONF_FILE"
            sed -i -E "s/(^\s*gpu_freq\s*=)/\# \1/g" "$PI_CONF_FILE"
            # -----------------------------------------------------------------
            # 2. Neue Werte durch die Re-Aktivierung passender (falls vorhanden)
            #    oder das Hinzufügen neuer Eintragungen einstellen
            # -----------------------------------------------------------------
            PI4_NEWLINE=$'\n'
            # --------
            # 2.1 GPU
            # --------
            NEW_GPU_FREQ=${pi_gpu_freq[$NEW_PERF_MODE]}
            if [ $(cat "$PI_CONF_FILE" | grep -i -c -E "^\s*#\s*gpu_freq\s*=\s*$NEW_GPU_FREQ") -gt 0 ];
            then
              sed -i -E "s/^\s*#\s*gpu_freq\s*=\s*$NEW_GPU_FREQ/gpu_freq=$NEW_GPU_FREQ/g" "$PI_CONF_FILE"
            else
              sed -i -E "s/\[pi4\]/[pi4]\\${PI4_NEWLINE}gpu_freq=$NEW_GPU_FREQ/g" "$PI_CONF_FILE"
            fi
            # --------
            # 2.2 CPU
            # --------
            NEW_ARM_FREQ=${pi_arm_freq[$NEW_PERF_MODE]}
            if [ $(cat "$PI_CONF_FILE" | grep -i -c -E "^\s*#\s*arm_freq\s*=\s*$NEW_ARM_FREQ") -gt 0 ];
            then
              sed -i -E "s/^\s*#\s*arm_freq\s*=\s*$NEW_ARM_FREQ/arm_freq=$NEW_ARM_FREQ/g" "$PI_CONF_FILE"
            else
              sed -i -E "s/\[pi4\]/[pi4]\\${PI4_NEWLINE}arm_freq=$NEW_ARM_FREQ/g" "$PI_CONF_FILE"
            fi
            # ---------
            # 2.3 VOLT
            # ---------
            NEW_OVERVOLT=${pi_overvolt[$NEW_PERF_MODE]}
            if [ $(cat "$PI_CONF_FILE" | grep -i -c -E "^\s*#\s*over_voltage\s*=\s*$NEW_OVERVOLT") -gt 0 ];
            then
              sed -i -E "s/^\s*#\s*over_voltage\s*=\s*$NEW_OVERVOLT/over_voltage=$NEW_OVERVOLT/g" "$PI_CONF_FILE"
            else
              sed -i -E "s/\[pi4\]/[pi4]\\${PI4_NEWLINE}over_voltage=$NEW_OVERVOLT/g" "$PI_CONF_FILE"
            fi
            # -----------------------------------------------------------------
            e_and_l "$OK_TAG"
            CHANGES_MADE=1
          fi
        fi
      else # Kein [pi4]-Eintrag in /boot/config.txt
        SHOW_SKIP_MESSAGE="$PIOS_TXT"
      fi
    else # Keine /boot/config.txt
      SHOW_SKIP_MESSAGE="$PIOS_TXT"
    fi
  else # Kein Raspberry
    SHOW_SKIP_MESSAGE="$RASPY_TXT"
  fi
  if [ "$SHOW_SKIP_MESSAGE" != "" ];
  then
    e_and_l "$(skip_text " Taktfrequenzen des Raspberry Pi einstellen" "$SHOW_SKIP_MESSAGE")"
  fi

  # ===========================================================================
  # Optimierung des Raspberry Pi GPU-Speichers
  # ===========================================================================
  # <2GB MEM => gpu_mem=128
  # >2GB MEM => gpu_mem=256
  ACTION_MESSAGE=" Optimierung des Raspberry Pi ${light_cyan}GPU-Speichers${colors_off} ... "
  SHOW_SKIP_MESSAGE=""
  if [ $RASPBERRY -ne 0 ];
  then
    PI_CONF_FILE="/boot/config.txt"
    if [ -s "$PI_CONF_FILE" ];
    then
      TWO_GIGABYTES=$((2 * 1024 * 1024 * 1024))
      FOUR_GIGABYTES=$((4 * 1024 * 1024 * 1024))
      NEW_MEM_SIZE=0
      if [ $MEMORY_TOTAL -gt $TWO_GIGABYTES ]; then NEW_MEM_SIZE=128; fi
      if [ $MEMORY_TOTAL -gt $FOUR_GIGABYTES ]; then NEW_MEM_SIZE=256; fi
      VALUE_MESSAGE="$NEW_MEM_SIZE MB"
      if [ $NEW_MEM_SIZE -ne 0 ];
      then
        if [ $(cat "$PI_CONF_FILE" | grep -i -c -E "gpu_mem") -eq 0 ] ||
           [ $(cat "$PI_CONF_FILE" | grep -i -c -E "gpu_mem\s*=\s*$NEW_MEM_SIZE") -eq 0 ];
        then
          ask_yes_or_no " Soll der ${light_cyan}GPU-Speicher${colors_off} optimiert werden"
          if [ $? -eq 1 ];
          then
            e_and_l -n "$ACTION_MESSAGE"
            # Wenn ein Eintrag vorhanden ist, diesen ändern ...
            if [ $(cat "$PI_CONF_FILE" | grep -i -c -E "gpu_mem") -gt 0 ];
            then
              if [ $(cat "$PI_CONF_FILE" | grep -i -c -E "gpu_mem\s*=\s*$NEW_MEM_SIZE") -eq 0 ];
              then
                create_backup_file "$PI_CONF_FILE"
                sed -i -E "s/^#*gpu_mem\s*=\s*[0-9]*/gpu_mem=$NEW_MEM_SIZE/gi" "$PI_CONF_FILE"
                if [ $? -eq 0 ];
                then
                  e_and_l "$OK_TAG ${light_yellow}(NEU: $VALUE_MESSAGE)${colors_off}"
                  CHANGES_MADE=1
                else
                  e_and_l "$ERROR_TAG $LINENO"
                fi
              else
                e_and_l "$OK_TAG ${dark_grey}(Wert: $VALUE_MESSAGE)${colors_off}"
              fi
            else # ... sonst einen neuen Eintrag hinzufügen
              echo -e $'\n'"gpu_mem=$NEW_MEM_SIZE" >> "$PI_CONF_FILE"
              if [ $? -eq 0 ];
              then
                e_and_l "$OK_TAG ${light_yellow}(NEU: $VALUE_MESSAGE)${colors_off}"
                CHANGES_MADE=1
              else
                e_and_l "$ERROR_TAG $LINENO"
              fi
            fi
          fi
        fi
      else
        SHOW_SKIP_MESSAGE="erst ab 2GB RAM"
      fi
    else # Keine /boot/config.txt
      SHOW_SKIP_MESSAGE="$PIOS_TXT"
    fi
  else # Kein Raspberry
    SHOW_SKIP_MESSAGE="$RASPY_TXT"
  fi
  if [ "$SHOW_SKIP_MESSAGE" != "" ];
  then
    e_and_l "$(skip_text "${ACTION_MESSAGE//96m/93m}" "$SHOW_SKIP_MESSAGE")"
  fi

  # ===========================================================================
  # Deaktivierung des internen Screen Blanking
  # ===========================================================================
  SHOW_SKIP_MESSAGE=""
  if [ $RASPBERRY -ne 0 ];
  then
    e_and_l -n " Deaktivierung des internen ${light_cyan}Screen Blanking${colors_off} ... "
    PI_X_CONF_DIR="/etc/X11/xorg.conf.d"
    PI_X_CONF_FILE="$PI_X_CONF_DIR/10-blanking.conf"
    # Wenn es die X-Konfig-Datei noch nicht gibt, dann diese neu anlegen
    if [ ! -f "$PI_X_CONF_FILE" ];
    then
      if [ ! -d "$PI_X_CONF_DIR" ];
      then
        mkdir -p "$PI_X_CONF_DIR" &>/dev/null
      fi
      if [ -d "$PI_X_CONF_DIR" ];
      then
        echo -e "Section \"ServerLayout\"" > "$PI_X_CONF_FILE"
        if [ $? -eq 0 ];
        then
          echo -e "  Identifier \"ServerLayout0\"" >> "$PI_X_CONF_FILE"
          echo -e "  Option \"BlankTime\" \"0\"" >> "$PI_X_CONF_FILE"
          echo -e "EndSection" >> "$PI_X_CONF_FILE"
          e_and_l "$OK_TAG"
          CHANGES_MADE=1
        else
          e_and_l "$ERROR_TAG $LINENO"
        fi
      else
        e_and_l "$ERROR_TAG $LINENO"
      fi
    else
      if [ $(cat "$PI_X_CONF_FILE" 2>/dev/null | grep -i -c -E "BlankTime\"*\s*\s\"*0") -gt 0 ];
      then
        e_and_l "$NC_TAG"
      else
        e_and_l "$ERROR_TAG (manuelle Konfiguration)"
      fi
    fi
  else # Kein Raspberry
    SHOW_SKIP_MESSAGE="$RASPY_TXT"
  fi
  if [ "$SHOW_SKIP_MESSAGE" != "" ];
  then
    e_and_l "$(skip_text " Deaktivierung des internen Screen Blanking" "$SHOW_SKIP_MESSAGE")"
  fi

  # ===========================================================================
  # Aktivierung der Sudo-Passworteingabe von Standard-Benutzer pi
  # ===========================================================================
  ACTION_MESSAGE=" Aktivierung ${light_cyan}sudo-Passwort${colors_off} für Benutzer pi "
  if [ $RASPBIAN -ne 0 ];
  then
    PI_NOPASS_FILE="/etc/sudoers.d/010_pi-nopasswd"
    CREATE_NEW_FILE=1
    if [ -s "$PI_NOPASS_FILE" ];
    then
      if [ $(cat ${PI_NOPASS_FILE} | grep -i -c -E "^\s*pi\s*ALL\s*\=\s*\(ALL\)\s*PASSWD\s*\:\s*ALL") -gt 0 ];
      then
        CREATE_NEW_FILE=0
      fi
    fi
    if [ $CREATE_NEW_FILE -eq 1 ];
    then
      ask_yes_or_no " Für Benutzer pi ${light_cyan}sudo-Passwort${colors_off} aktivieren"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m} ... "
        create_backup_file "$PI_NOPASS_FILE"
        echo -e "pi ALL=(ALL) PASSWD: ALL" > "$PI_NOPASS_FILE" 2>"$LOG_TEMP"
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG"
        else
          restore_backup_file "$PI_NOPASS_FILE"
          e_and_l "$ERROR_TAG $LINENO"
          add_full_log
        fi
      fi
    else
      e_and_l "$ACTION_MESSAGE ... $NC_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$PIOS_TXT")"
  fi

  # ===========================================================================
  # Bei Pi-Upgrades Test-Versionen ausschließen
  # ===========================================================================
  ACTION_MESSAGE=" Test-Kanal von ${light_cyan}Pi OS Upgrades${colors_off} ausschließen"
  if [ $RASPBIAN -ne 0 ];
  then
    RASPI_DEB_FILE="/etc/apt/sources.list.d/raspi.list"
    # Nur weitermachen, wenn es die Datei gibt
    if [ -s "$RASPI_DEB_FILE" ];
    then
      # Nur weitermachen, wenn die Datei auch einen entsprechenden Eintrag hat
      if [ $(cat ${RASPI_DEB_FILE} | grep -i -c -E "deb\s*http\:\/\/archive\.raspberrypi\.org\/debian") -gt 0 ];
      then
        # Wenn der Eintrag aktiv ist, diesen auskommentieren
        if [ $(cat ${RASPI_DEB_FILE} | grep -i -c -E "^\s*deb\s\s*http\:\/\/archive\.raspberrypi\.org\/debian") -gt 0 ];
        then
          ask_yes_or_no "$ACTION_MESSAGE"
          if [ $? -eq 1 ];
          then
            e_and_l -n "${ACTION_MESSAGE//96m/93m} ... "
            create_backup_file "$RASPI_DEB_FILE"
            sed -i -E "s/(^\s*deb\s\s*http\:\/\/archive\.raspberrypi\.org\/debian)/\# \1/g" "$RASPI_DEB_FILE"
            if [ $? -eq 0 ];
            then
              e_and_l "$OK_TAG"
              CHANGES_MADE=1
            else
              e_and_l "$ERROR_TAG $LINENO"
            fi
          fi
        else
          e_and_l "$ACTION_MESSAGE ... $NC_TAG"
        fi
      fi
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$PIOS_TXT")"
  fi

  e_and_l "$HALF_LINE"
  e_and_l " ${bold_blue}Desktop${colors_off}"
  e_and_l "$HALF_LINE"

  # ===========================================================================
  # Für die Einstellungen zur Anmeldung am Desktop des LightDM prüfen ob die
  # Datei lightdm.conf existiert und diese ggf. erstellen oder erweitern
  # ===========================================================================
  LDM_CONF_DIR="/etc/lightdm"
  if [ -d "$LDM_CONF_DIR" ]
  then
    # Wenn es schon eine Konfigurations-Datei gibt, diese vervollständigen ...
    LDM_CONF_FILE="$LDM_CONF_DIR/lightdm.conf"
    if [ -s "$LDM_CONF_FILE" ] &&
       [ $(cat "$LDM_CONF_FILE" 2>/dev/null | grep -i -c -E "\[Seat") -gt 0 ];
    then
      # Fehlende Default-Einträge ergänzen ------------------------------------
      if [ $(cat "$LDM_CONF_FILE" 2>/dev/null | grep -i -c -E "^#*\s*autologin-guest\s*=") -eq 0 ];
      then
        echo -e "autologin-guest=false" >> "$LDM_CONF_FILE" 2>/dev/null
      fi
      if [ $(cat "$LDM_CONF_FILE" 2>/dev/null | grep -i -c -E "^#*\s*autologin-user\s*=") -eq 0 ];
      then
        echo -e "#autologin-user=" >> "$LDM_CONF_FILE" 2>/dev/null
      fi
      if [ $(cat "$LDM_CONF_FILE" 2>/dev/null | grep -i -c -E "^#*\s*autologin-user-timeout\s*=") -eq 0 ];
      then
        echo -e "autologin-user-timeout=0" >> "$LDM_CONF_FILE" 2>/dev/null
      fi
      if [ $(cat "$LDM_CONF_FILE" 2>/dev/null | grep -i -c -E "^#*\s*allow-guest\s*=") -eq 0 ];
      then
        echo -e "allow-guest=true" >> "$LDM_CONF_FILE" 2>/dev/null
      fi
    else # ... sonst komplett neu anlegen
# ---------------------------
cat > "$LDM_CONF_FILE" <<EOF
[Seat:*]
autologin-guest=false
autologin-user=
autologin-user-timeout=0
allow-guest=true
EOF
# ---------------------------
    fi
  fi

  # ===========================================================================
  # Automatische Anmeldung am Desktop deaktivieren
  # ===========================================================================
  ACTION_MESSAGE=" Deaktivierung der ${light_cyan}automatischen Anmeldung${colors_off} "
  if [ -d "$LDM_CONF_DIR" ]
  then
    THE_AUTOSTART_LINE="^\s*autologin-user\s*=\s*[0-9a-z]"
    if [ -s "$LDM_CONF_FILE" ] &&
       [ $(cat "$LDM_CONF_FILE" 2>/dev/null | grep -i -c -E "$THE_AUTOSTART_LINE") -gt 0 ];
    then
      THE_BAD_LINE=$(cat "$LDM_CONF_FILE" | grep -i -E "$THE_AUTOSTART_LINE")
      TEST_USER_NAME=$(echo ${THE_BAD_LINE##*=} | xargs)
      e_and_l " $WARN_TAG: Der Benutzer ${light_cyan}$TEST_USER_NAME${colors_off} wird automatisch am System angemeldet!"
      ask_yes_or_no " Soll die ${light_cyan}automatische Anmeldung${colors_off} deaktiviert werden"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m} ... "
        create_backup_file "$LDM_CONF_FILE"
        sed -i -E "s/$THE_BAD_LINE/#autologin-user=/g" "$LDM_CONF_FILE"
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG"
          CHANGES_MADE=1
        else
          e_and_l "$ERROR_TAG"
        fi
      fi
    else
      e_and_l -n "$ACTION_MESSAGE ... "
      e_and_l "$NC_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "nur bei LDM")"
  fi

  # ===========================================================================
  # Anmeldung mit Gastzugang deaktivieren
  # ===========================================================================
  ACTION_MESSAGE=" Deaktivierung der ${light_cyan}Anmeldung mit Gastzugang${colors_off}"
  if [ -d "$LDM_CONF_DIR" ]
  then
    THE_GUESTUSER_LINE="^\s*allow-guest\s*=\s*true"
    if [ -s "$LDM_CONF_FILE" ] &&
       [ $(cat "$LDM_CONF_FILE" 2>/dev/null | grep -i -c -E "$THE_GUESTUSER_LINE") -gt 0 ];
    then
      THE_BAD_LINE=$(cat "$LDM_CONF_FILE" | grep -i -E "$THE_GUESTUSER_LINE")
      e_and_l " $WARN_TAG: Die Anmeldung enthält einen ${light_cyan}Gastzugang${colors_off}."
      ask_yes_or_no " Soll die ${light_cyan}Anmeldung als Gast${colors_off} deaktiviert werden"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m} ... "
        create_backup_file "$LDM_CONF_FILE"
        sed -i -E "s/$THE_BAD_LINE/allow-guest=false/g" "$LDM_CONF_FILE"
        if [ $? -eq 0 ];
        then
          # Zur Sicherheit ggf. auch die automatische Anmeldung als Gast deaktivieren
          THE_BAD_LINE=$(cat "$LDM_CONF_FILE" | grep -i -E "^\s*autologin-guest\s*=\s*true")
          if [ "$THE_BAD_LINE" != "" ];
          then
            sed -i -E "s/$THE_BAD_LINE/autologin-guest=false/g" "$LDM_CONF_FILE"
          fi
          e_and_l "$OK_TAG"
          CHANGES_MADE=1
        else
          e_and_l "$ERROR_TAG"
        fi
      fi
    else
      e_and_l -n "$ACTION_MESSAGE ... "
      e_and_l "$NC_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "nur bei LDM")"
  fi

  # ===========================================================================
  # Bei der Anmeldung Nummernblock aktivieren
  # ===========================================================================
  # numlockx installieren (sofern nicht bereits vorher passiert)
  NUMLOCK_INSTALL_STATUS=0
  ASKED_NUMLOCKX_INST_NO=0
  if [ $(LANG=en dpkg-query -W -f='${Status}' "numlockx" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
  then
    ask_yes_or_no " Zur Aktivierung des Nummernblocks ${light_cyan}numlockx${colors_off} installieren"
    if [ $? -eq 1 ];
    then
      e_and_l -n " Installiere ${light_yellow}numlockx${colors_off}, bitte warten         "
      apt install "numlockx" -y &>"$LOG_TEMP"
      NUMLOCK_INSTALL_STATUS=$?
      if [ $NUMLOCK_INSTALL_STATUS -eq 0 ];
      then
        e_and_l "... $OK_TAG"
      else
        e_and_l "... $ERROR_TAG"
        add_full_log
      fi
    else
      ASKED_NUMLOCKX_INST_NO=1
    fi
  fi
  # Nur weitermachen, wenn numlockx installiert ist
  ACTION_MESSAGE=" Bei der Anmeldung ${light_cyan}Nummernblock${colors_off} einschalten"
  TEMP_MSG="$ACTION_MESSAGE ... "
  if [ $NUMLOCK_INSTALL_STATUS -eq 0 ];
  then
    NUMLOCK_FILE="/usr/share/lightdm/lightdm.conf.d/01_debian.conf"
    if [ $RASPBIAN -ne 0 ] ||
       [ -s "$NUMLOCK_FILE" ];
    then
      NUMLOCK_IS_OK="numlockx on"
      NUMLOCK_WRONG="numlockx off"
      NUMLOCK_ENTRY="greeter-setup-script=/usr/bin/numlockx on"
    else
      NUMLOCK_FILE="/etc/lightdm/slick-greeter.conf"
      NUMLOCK_IS_OK="activate-numlock=true"
      NUMLOCK_WRONG="activate-numlock=false"
      NUMLOCK_ENTRY="activate-numlock=true"
    fi
    # Wenn eine passende Basis-Konfigurations-Datei existiert, dann diese erweitern
    if [ -s "$NUMLOCK_FILE" ];
    then
      # Nur weitermachen, wenn kein korrekter Eintrag existiert
      if [ $(grep -i -c -E "$NUMLOCK_IS_OK" "$NUMLOCK_FILE") -eq 0 ];
      then
        # Wenn schon ein (falscher) Eintrag existiert, dann diesen ändern ...
        create_backup_file "$NUMLOCK_FILE"
        if [ $(grep -i -c -E "$NUMLOCK_WRONG" "$NUMLOCK_FILE") -ne 0 ];
        then
          sed -i "s/$NUMLOCK_WRONG/$NUMLOCK_ENTRY/g" "$NUMLOCK_FILE"
          if [ $? -eq 0 ];
          then
            TEMP_MSG+="$OK_TAG"
            CHANGES_MADE=1
          else
            TEMP_MSG+="$ERROR_TAG $LINENO"
          fi
        else # ... sonst einen neuen Eintrag hinzufügen
          echo -e $'\n'"$NUMLOCK_ENTRY" >> "$NUMLOCK_FILE" 2>/dev/null
          if [ $? -eq 0 ];
          then
            TEMP_MSG+="$OK_TAG"
            CHANGES_MADE=1
          else
            TEMP_MSG+="$ERROR_TAG $LINENO"
          fi
        fi
      else
        TEMP_MSG+="$NC_TAG"
      fi
    else # .... sonst unter lightdm eine neue Datei anlegen
      if [ "$DISPLAY_MANAGER" = "lightdm" ];
      then
        echo -e "[Greeter]" > "$NUMLOCK_FILE" 2>/dev/null
        echo -e "activate-numlock=true"$'\n' >> "$NUMLOCK_FILE" 2>/dev/null
        if [ $? -eq 0 ];
        then
          TEMP_MSG+="$OK_TAG"
          CHANGES_MADE=1
        else
          TEMP_MSG+="$ERROR_TAG $LINENO"
        fi
      else
        TEMP_MSG+="$NA_TXT"
      fi
    fi
    # Sicherheitshalber zusätzlich die DCONF-Settings erweitern
    # (dabei keine weitere Ausgabe erzeugen)
    if [ "$DESKTOP_ENVIRONMENT" = "MATE" ];
    then
      CURRENT_MATE_NUMLOCK_SETTING="$(gsettings_get org.mate.peripherals-keyboard numlock-state)"
      # echo -e "$CURRENT_MATE_NUMLOCK_SETTING" # NUR ZUM TESTEN
      if [ "$CURRENT_MATE_NUMLOCK_SETTING" != "on" ] &&
         [ "$CURRENT_MATE_NUMLOCK_SETTING" != "true" ];
      then
        gsettings_set "org.mate.peripherals-keyboard" "remember-numlock-state" "true"
        gsettings_set "org.mate.peripherals-keyboard" "numlock-state" "on"
        # TEMP_MSG+="$OK_TAG"
        CHANGES_MADE=1
      # else
        # TEMP_MSG+="$NC_TAG"
      fi
    else
      CURRENT_GNOME_NUMLOCK_SETTING="$(gsettings_get org.gnome.desktop.peripherals.keyboard numlock-state)"
      # echo -e "$CURRENT_GNOME_NUMLOCK_SETTING" # NUR ZUM TESTEN
      if [ "$CURRENT_GNOME_NUMLOCK_SETTING" != "on" ] &&
         [ "$CURRENT_GNOME_NUMLOCK_SETTING" != "true" ];
      then
        gsettings_set "org.gnome.desktop.peripherals.keyboard" "remember-numlock-state" "true"
        gsettings_set "org.gnome.desktop.peripherals.keyboard" "numlock-state" "true"
        # TEMP_MSG+="$OK_TAG"
        CHANGES_MADE=1
      # else
        # TEMP_MSG+="$NC_TAG"
      fi
      # In neueren Ubuntu-Versionen gibt es zudem folgende Einträge,
      # deren Wirkung jedoch noch nicht zuverlässig verifiziert ist:
      # gsettings_set "org.mate.peripherals-keyboard-xkb.kbd" "options" "['compat\tnumpad:mac']"
      # gsettings_set "org.gnome.libgnomekbd.keyboard" "options" "['compat\tnumpad:mac']"
      # gsettings_set "org.ArcticaProject.arctica-greeter" "activate-numlock" "true"
    fi
  else # numlockx nicht installiert
    TEMP_MSG+="${bold_red}nicht${colors_off} eingerichtet"
  fi
  if [ $ASKED_NUMLOCKX_INST_NO -eq 0 ];
  then
    e_and_l "$TEMP_MSG"
  fi

  # ===========================================================================
  # Anzeige der Tastatur-LEDs einschalten
  # ===========================================================================
  ACTION_MESSAGE=" Anzeige der ${light_cyan}Tastatur-LEDs${colors_off} einschalten"
  if [ "$DESKTOP_ENVIRONMENT" = "MATE" ];
  then
    LED_STATUS="$(gsettings_get org.mate.peripherals-keyboard-xkb.general duplicate-leds)"
    if [ "$LED_STATUS" != "true" ];
    then
      ask_yes_or_no "$ACTION_MESSAGE"
      if [ $? -eq 1 ];
      then
        e_and_l -n " Schalte die Anzeige der ${light_yellow}Tastatur-LEDs${colors_off} ein  ... "
        INSTALL_STATUS=0
        if [ $(LANG=en dpkg-query -W -f='${Status}' "libmatekbd-common" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ] ||
           [ $(LANG=en dpkg-query -W -f='${Status}' "libmatekbd4" 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
        then
          sudo apt install --reinstall libmatekbd-common libmatekbd4 -y &>/dev/null
          INSTALL_STATUS=$?
        fi
        if [ $INSTALL_STATUS -eq 0 ];
        then
          gsettings_set "org.mate.peripherals-keyboard-xkb.general" "duplicate-leds" "true"
          if [ $? -eq 0 ];
          then
            e_and_l "$OK_TAG"
            CHANGES_MADE=1
          else
            e_and_l "$ERROR_TAG $LINENO"
          fi
        else
          e_and_l "$ERROR_TAG $LINENO"
        fi
      fi
    else
      e_and_l "$ACTION_MESSAGE      ... $NC_TAG"
    fi
  else # kein MATE
    e_and_l "$(skip_text "$ACTION_MESSAGE     " "$NM_TXT")"
  fi

  # ===========================================================================
  # Asiatische Schriftarten ausblenden (nur für den aktuellen Benutzer)
  # ===========================================================================

  ACTION_MESSAGE=" Ausblenden der ${light_cyan}asiatischen Schriftarten${colors_off}    ... "
  # if [ $(echo "$OPERATION_SYSTEM" | grep -i -c -E "ubuntu") -gt 0 ] ||
  #    [ $(echo "$OPERATION_SYSTEM" | grep -i -c -E " mint ") -gt 0 ];
  # then
    FONT_CONF_DIR="$USER_CONFIG_DIR/fontconfig"
    FONT_CFG_FILE="$FONT_CONF_DIR/fonts.conf"
    COPY_FONTS_FILE=0
    DOWNLOAD_FILE_URL="$RESSOURCE_SERVER_DIR/cfg/fonts.conf"
    DOWNLOAD_FILE_NAME="${DOWNLOAD_FILE_URL##*/}"
    LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$DOWNLOAD_FILE_NAME"
    wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$DOWNLOAD_FILE_URL" &>"$LOG_TEMP"
    if [ $? -eq 0 ] &&
      [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
      [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
    then
      if [ -s "$FONT_CFG_FILE" ];
      then
        # ALT: SIZE_NEW_FONTS_FILE=$(ls -l "$LOCAL_DOWNLOAD_FILE" | awk '{print $5}' | xargs)
        SIZE_NEW_FONTS_FILE=$(stat -c %s "$LOCAL_DOWNLOAD_FILE")
        # ALT: SIZE_OLD_FONTS_FILE=$(ls -l "$FONT_CFG_FILE" | awk '{print $5}' | xargs)
        SIZE_OLD_FONTS_FILE=$(stat -c %s "$FONT_CFG_FILE")
        if [ $SIZE_NEW_FONTS_FILE -ne $SIZE_OLD_FONTS_FILE ];
        then
          COPY_FONTS_FILE=1
        else
          e_and_l "$ACTION_MESSAGE$NC_TAG"
        fi
      else
        COPY_FONTS_FILE=1
      fi
    else
      e_and_l "$ACTION_MESSAGE$ERROR_TAG $LINENO"
      add_full_log
    fi
    if [ $COPY_FONTS_FILE -eq 1 ];
    then
      ask_yes_or_no " Sollen ${light_cyan}asiatische Schriftarten${colors_off} ausgeblendet werden"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m}"
        chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
        if [ ! -d "$FONT_CONF_DIR" ];
        then
          mkdir -p "$FONT_CONF_DIR" &>/dev/null
        fi
        create_backup_file "$FONT_CFG_FILE"
        cp -f "$LOCAL_DOWNLOAD_FILE" "$FONT_CFG_FILE" &>"$LOG_TEMP"
        if [ $? -eq 0 ];
        then
          chown -R "$USER_USERNAME:$USER_USERNAME" "$FONT_CONF_DIR" &>/dev/null
          fc-cache &>/dev/null
          dpkg-reconfigure fontconfig &>/dev/null
          e_and_l "$OK_TAG"
          CHANGES_MADE=1
        else
          restore_backup_file "$FONT_CFG_FILE"
          e_and_l "$ERROR_TAG $LINENO"
          add_full_log
        fi
      fi
    fi
    remove_file "$LOCAL_DOWNLOAD_FILE"
  # else
  #   e_and_l "$(skip_text "$ACTION_MESSAGE" "$NU_TXT")"
  # fi

  # ===========================================================================
  # Sichtbarkeit der Scrollbalken verbessern (nur für den aktuellen Benutzer)
  # ===========================================================================
  ACTION_MESSAGE=" Sichtbarkeit der ${light_cyan}Scrollbalken${colors_off} verbessern"
  if [ $(echo "$WINDOW_THEME" | grep -i -c -E "\-Dark") -gt 0 ];
  then
    GTK3_CONF_DIR="$USER_CONFIG_DIR/gtk-3.0"
    if [ -d "$GTK3_CONF_DIR" ];
    then
      GTK3_CFG_FILE="$GTK3_CONF_DIR/gtk.css"
      if [ ! -s "$GTK3_CFG_FILE" ];
      then
        ask_yes_or_no "$ACTION_MESSAGE"
        if [ $? -eq 1 ];
        then
          e_and_l -n "${ACTION_MESSAGE//96m/93m}   ... "
          DOWNLOAD_FILE_URL="$RESSOURCE_SERVER_DIR/cfg/gtk.css"
          DOWNLOAD_FILE_NAME="${DOWNLOAD_FILE_URL##*/}"
          LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$DOWNLOAD_FILE_NAME"
          wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$DOWNLOAD_FILE_URL" &>"$LOG_TEMP"
          if [ $? -eq 0 ] &&
             [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
             [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
          then
            chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
            if [ ! -d "$GTK3_CONF_DIR" ];
            then
              mkdir -p "$GTK3_CONF_DIR" &>/dev/null
            fi
            if [ $? -eq 0 ];
            then
              create_backup_file "$GTK3_CFG_FILE"
              cp -f "$LOCAL_DOWNLOAD_FILE" "$GTK3_CFG_FILE" &>"$LOG_TEMP"
              if [ $? -eq 0 ];
              then
                chown -R "$USER_USERNAME:$USER_USERNAME" "$GTK3_CONF_DIR" &>/dev/null
                e_and_l "$OK_TAG"
                CHANGES_MADE=1
              else
                restore_backup_file "$GTK3_CFG_FILE"
                e_and_l "$ERROR_TAG $LINENO"
                add_full_log
              fi
            else
              e_and_l "$ERROR_TAG $LINENO"
              add_full_log
            fi
          else
            e_and_l "$ERROR_TAG $LINENO"
            remove_file "$LOCAL_DOWNLOAD_FILE"
            add_full_log
          fi
        fi
      else
        e_and_l "$ACTION_MESSAGE   ... $NC_TAG"
      fi
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE  " "nur Dark-Themen")"
  fi

  # ===========================================================================
  # Alle Autostart-Programme zugänglich (sichtbar) machen
  # ===========================================================================
  ACTION_MESSAGE=" Alle ${light_cyan}Autostart-Programme${colors_off} zugänglich machen"
  AUTOSTARTS_DIR="/etc/xdg/autostart"
  if [ -d "$AUTOSTARTS_DIR" ];
  then
    if [ $(grep -l -i -c -E "^\s*NoDisplay\s*=\s*true" "$AUTOSTARTS_DIR"/* | wc -l) -gt 0 ];
    then
      ask_yes_or_no "$ACTION_MESSAGE"
      if [ $? -eq 1 ];
      then
        e_and_l -n " Mache alle ${light_yellow}Autostart-Programme${colors_off} zugänglich  ... "
        if [ ! -d "$AUTOSTARTS_DIR.bak" ];
        then
          mkdir -p "$AUTOSTARTS_DIR.bak" &>/dev/null
        fi
        if [ -d "$AUTOSTARTS_DIR.bak" ];
        then
          cp -n ${AUTOSTARTS_DIR}/* "$AUTOSTARTS_DIR.bak" &>/dev/null
          if [ $? -eq 0 ];
          then
            sed -i "s/^\s*NoDisplay\s*=\s*true/NoDisplay=false/g" ${AUTOSTARTS_DIR}/*.desktop*
            if [ $? -eq 0 ];
            then
              e_and_l "$OK_TAG"
              CHANGES_MADE=1
            else
              e_and_l "$ERROR_TAG $LINENO"
            fi
          else
            e_and_l "$ERROR_TAG $LINENO"
          fi
        else
          e_and_l "$ERROR_TAG $LINENO"
        fi
      fi
    else
      e_and_l "$ACTION_MESSAGE ... $NC_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$NF_TXT")"
  fi

  # ===========================================================================
  # Begrenzung des Thumbnail-Zwischenspeichers
  # ===========================================================================
  GS_MAX_AGE=30   # Tage
  GS_MAX_SIZE=100 # MB
  # ---------------------
  VALUE_MESSAGE="$GS_MAX_AGE Tage und $GS_MAX_SIZE MB"
  GS_G_ERRORS=0
  GS_OLD_G_MAX_AGE=$(gsettings_get org.gnome.desktop.thumbnail-cache maximum-age)
  ((GS_G_ERRORS+=$?))
  GS_OLD_G_MAX_SIZE=$(gsettings_get org.gnome.desktop.thumbnail-cache maximum-size)
  ((GS_G_ERRORS+=$?))
  GS_M_ERRORS=0
  GS_OLD_M_MAX_AGE=$(gsettings_get org.mate.thumbnail-cache maximum-age)
  ((GS_M_ERRORS+=$?))
  GS_OLD_M_MAX_SIZE=$(gsettings_get org.mate.thumbnail-cache maximum-size)
  ((GS_M_ERRORS+=$?))
  ACTION_MESSAGE=" Begrenzung des ${light_cyan}Thumbnail-Zwischenspeichers${colors_off} ... "
  if [ $GS_G_ERRORS -eq 0 ] ||
     [ $GS_M_ERRORS -eq 0 ];
  then
    VALUES_DIFFERENT=0
    if [ $GS_G_ERRORS -eq 0 ];
    then
      if [[ $GS_OLD_G_MAX_AGE -ne $GS_MAX_AGE || $GS_OLD_G_MAX_SIZE -ne $GS_MAX_SIZE ]];
      then
        VALUES_DIFFERENT=1
      fi
    fi
    if [ $GS_M_ERRORS -eq 0 ];
    then
      if [[ $GS_OLD_M_MAX_AGE -ne $GS_MAX_AGE || $GS_OLD_M_MAX_SIZE -ne $GS_MAX_SIZE ]];
      then
        VALUES_DIFFERENT=1
      fi
    fi
    if [ $VALUES_DIFFERENT -eq 1 ];
    then
      ask_yes_or_no " Speicherplatz für ${light_cyan}Thumbnail-Zwischenspeicher${colors_off} begrenzen"
      if [ $? -eq 1 ];
      then
        e_and_l -n "${ACTION_MESSAGE//96m/93m}"
        # -------------------------------------------------------------------------
        # Wenn es die GNOME-Einträge gibt, dann diese anpassen,
        # ansonsten wird dieser Schritt als OK übersprungen
        GS_G_RESULT=0 # (0 = OK)
        if [ $GS_G_ERRORS -eq 0 ];
        then
          if [ $GS_OLD_G_MAX_AGE -ne $GS_MAX_AGE ] ||
            [ $GS_OLD_G_MAX_SIZE -ne $GS_MAX_SIZE ];
          then
            gsettings_set "org.gnome.desktop.thumbnail-cache" "maximum-age" "$GS_MAX_AGE"
            GS_G_RESULT=$?
            if [ $GS_G_RESULT -eq 0 ];
            then
              gsettings_set "org.gnome.desktop.thumbnail-cache" "maximum-size" "$GS_MAX_SIZE"
              GS_G_RESULT=$?
            fi
          fi
        fi
        # -------------------------------------------------------------------------
        # Wenn es die MATE-Einträge gibt, dann diese anpassen,
        # ansonsten wird dieser Schritt als OK übersprungen
        GS_M_RESULT=0 # (0 = OK)
        if [ $GS_M_ERRORS -eq 0 ];
        then
          if [ $GS_OLD_M_MAX_AGE -ne $GS_MAX_AGE ] ||
            [ $GS_OLD_M_MAX_SIZE -ne $GS_MAX_SIZE ];
          then
            gsettings_set "org.mate.thumbnail-cache" "maximum-age" "$GS_MAX_AGE"
            GS_M_RESULT=$?
            if [ $GS_M_RESULT -eq 0 ];
            then
              gsettings_set "org.mate.thumbnail-cache" "maximum-size" "$GS_MAX_SIZE"
              GS_M_RESULT=$?
            fi
          fi
        fi
        # -------------------------------------------------------------------------
        if [ $GS_G_RESULT -eq 0 ] &&
          [ $GS_M_RESULT -eq 0 ];
        then
          e_and_l "$OK_TAG ${light_yellow}(NEU: $VALUE_MESSAGE)${colors_off}"
        else
          e_and_l "$ERROR_TAG"
        fi
      fi
    else
      e_and_l "$ACTION_MESSAGE$OK_TAG ${dark_grey}(Wert: $VALUE_MESSAGE)${colors_off}"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$NF_TXT")"
  fi

  e_and_l "$HALF_LINE"
  e_and_l " ${bold_blue}Konsole${colors_off}"
  e_and_l "$HALF_LINE"

  # ===========================================================================
  # Zur Angleichung verschiedener Linux-Systeme die Benutzerordner "Desktop"
  # und "Schreibtisch" je nach Existenz gegenseitig symbolisch verlinken
  # ===========================================================================
  TARGET_NAME=""
  LINK_NAME=""
  if [ -d "/home/$USER_USERNAME/Schreibtisch" ] &&
     [ ! -L "/home/$USER_USERNAME/Schreibtisch" ];
  then
    TARGET_NAME="Schreibtisch"
    LINK_NAME="Desktop"
  fi
  if [ -d "/home/$USER_USERNAME/Desktop" ] &&
     [ ! -L "/home/$USER_USERNAME/Desktop" ];
  then
    TARGET_NAME="Desktop"
    LINK_NAME="Schreibtisch"
  fi
  TARGET_PATH="/home/$USER_USERNAME/$TARGET_NAME"
  LINK_PATH="/home/$USER_USERNAME/$LINK_NAME"
  ACTION_MESSAGE=" Verknüpfung von ${light_cyan}$LINK_NAME${colors_off} zu ${light_cyan}$TARGET_NAME${colors_off}    ... "
  if [ "$TARGET_NAME" != "" ] &&
     [ -d "$TARGET_PATH" ] &&
     [ "$LINK_NAME" != "" ] &&
     [ ! -d "$LINK_PATH" ] &&
     [ ! -f "$LINK_PATH" ] &&
     [ ! -L "$LINK_PATH" ];
  then
    ask_yes_or_no " Verknüpfung ${light_cyan}$LINK_NAME${colors_off} zu ${light_cyan}$TARGET_NAME${colors_off} anlegen"
    if [ $? -eq 1 ];
    then
      e_and_l -n "${ACTION_MESSAGE//96m/93m}"
      ln -s "$TARGET_PATH" "$LINK_PATH" &>/dev/null
      if [ $? -eq 0 ];
      then
        chown "$USER_USERNAME:$USER_USERNAME" "$LINK_PATH" &>/dev/null
        e_and_l "$OK_TAG"
      else
        e_and_l "kann ${bold_red}nicht${colors_off} eingerichtet werden"
      fi
    fi
  else
    if [ "$TARGET_PATH" != "" ] &&
       [ -d "$TARGET_PATH" ] &&
       [ "$LINK_PATH" != "" ] &&
       [ -L "$LINK_PATH" ];
    then
      e_and_l "$ACTION_MESSAGE$NC_TAG"
#     else
#       e_and_l "$(skip_text "$ACTION_MESSAGE" "$NV_TXT")"
    fi
  fi

  # ===========================================================================
  # Erweitertes Prompt einrichten (nur für den aktuellen Benutzer)
  # ===========================================================================
  SIMPLE_PROMPT="PS1='\${debian_chroot:+(\$debian_chroot)}\\\u@\h:\\\w\\\$ '"
  COLOR_PROMPT="PS1='\${debian_chroot:+(\$debian_chroot)}\\\[\\\033[0;92m\\\]\\\u\\\[\\\033[0;37m\\\]|\\\[\\\033[0;94m\\\]\\\h\\\[\\\033[0;37m\\\]|\\\[\\\033[1;34m\\\]\\\w\\\[\\\033[00m\\\]\\\$ '"
  SUPER_PROMPT1="PS1='\\\n\\\[\\\033[1;30m\\\]┌─\${debian_chroot:+(\$debian_chroot)─}\\\[\\\033[0;92m\\\] \\\u \\\[\\\033[1;30m\\\]|\\\033[0;94m\\\] \\\h \\\[\\\033[1;30m\\\]|\\\[\\\033[1;34m \\\w\\\n\\\[\\\033[1;30m\\\]└─\\\[\\\033[0m\\\] \\\$ '"
  SUPER_PROMPT2="PS1='\\\n\\\[\\\033[1;30m\\\]┌─\${debian_chroot:+(\$debian_chroot)─}(\\\[\\\033[0;92m\\\]\\\u\\\[\\\033[1;30m\\\]@\\\033[0;94m\\\]\\\h\\\[\\\033[1;30m\\\])─[\\\[\\\033[1;34m\\\w\\\[\\\033[1;30m\\\]]\\\n└─\\\[\\\033[0m\\\] \\\$ '"
  USER_BASHRC_FILE="$USER_HOME_DIR/.bashrc"
  ACTION_MESSAGE=" Erweitertes ${light_cyan}Prompt${colors_off} für die Kommandozeile"
  if [ -s "$USER_BASHRC_FILE" ];
  then
    if [ $(grep -c -E "Extended Prompt" "$USER_BASHRC_FILE") -eq 0 ];
    then
      ask_yes_or_no "$ACTION_MESSAGE einrichten"
      if [ $? -eq 1 ];
      then
        e_and_l -n " Richte erweitertes ${light_yellow}Konsolen-Prompt${colors_off} ein     ... "
        create_backup_file "$USER_BASHRC_FILE"
        echo -e "" >> "$USER_BASHRC_FILE"
        echo -e "# ----------------"$'\n'"# Extended Prompt"$'\n'"# ----------------" >> "$USER_BASHRC_FILE"
        echo -e "if [ -x /usr/bin/tput ] && tput setaf 1 &>/dev/null;" >>  "$USER_BASHRC_FILE"
        echo -e "then" >>  "$USER_BASHRC_FILE"
        echo -e "  # $COLOR_PROMPT"  >>  "$USER_BASHRC_FILE"
        echo -e "  $SUPER_PROMPT1" >>  "$USER_BASHRC_FILE"
        echo -e "  # $SUPER_PROMPT2" >>  "$USER_BASHRC_FILE"
        echo -e "else" >>  "$USER_BASHRC_FILE"
        echo -e "  $SIMPLE_PROMPT" >>  "$USER_BASHRC_FILE"
        echo -e "fi" >>  "$USER_BASHRC_FILE"
        echo -e "# ----------------" >>  "$USER_BASHRC_FILE"
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG"
          CHANGES_MADE=1
        else
          e_and_l "$ERROR_TAG $LINENO"
        fi
      fi
    else
      e_and_l "$ACTION_MESSAGE   ... $NC_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE  " "nur für Bash")"
  fi

  # ===========================================================================
  # Alias Definitionen für Befehle einrichten (für ALLE Benutzer)
  # ===========================================================================
  GLOBAL_BASHRC_FILE="/etc/bash.bashrc"
  USER_BASHRC_FILE="$USER_HOME_DIR/.bashrc"
  BASH_ALIAS_FILE="/etc/bash_aliases"
  ACTION_MESSAGE=" Definitionen der ${light_cyan}Befehls-Aliase${colors_off} erweitern"
  if [ -s "$GLOBAL_BASHRC_FILE" ];
  then
    # bash_aliases downloaden
    DOWNLOAD_FILE_URL="$RESSOURCE_SERVER_DIR/cfg/bash_aliases"
    DOWNLOAD_FILE_NAME="${DOWNLOAD_FILE_URL##*/}"
    LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$DOWNLOAD_FILE_NAME"
    wget -nv -O "$LOCAL_DOWNLOAD_FILE" "$DOWNLOAD_FILE_URL" &>"$LOG_TEMP"
    if [ $? -eq 0 ] &&
       [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
       [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
    then
      # bash_aliases nur ersetzen, wenn die neue Datei eine andere Größe hat
      # bzw. durch kopieren neu anlegen, wenn sie noch nicht existiert
      COPY_NEW_ALIAS_FILE=0
      if [ -s "$BASH_ALIAS_FILE" ];
      then
        # ALT: SIZE_NEW_ALIAS_FILE=$(ls -l "$LOCAL_DOWNLOAD_FILE" | awk '{print $5}' | xargs)
        SIZE_NEW_ALIAS_FILE=$(stat -c %s "$LOCAL_DOWNLOAD_FILE")
        # ALT: SIZE_OLD_ALIAS_FILE=$(ls -l "$BASH_ALIAS_FILE" | awk '{print $5}' | xargs)
        SIZE_OLD_ALIAS_FILE=$(stat -c %s "$BASH_ALIAS_FILE")
        if [ $SIZE_NEW_ALIAS_FILE -ne $SIZE_OLD_ALIAS_FILE ];
        then
          COPY_NEW_ALIAS_FILE=1
        fi
      else
        COPY_NEW_ALIAS_FILE=1
      fi
      if [ $COPY_NEW_ALIAS_FILE -eq 1 ];
      then
        ask_yes_or_no "$ACTION_MESSAGE"
        if [ $? -eq 1 ];
        then
          e_and_l -n " Richte Definitionen der ${light_yellow}Befehls-Aliase${colors_off} ein ... "
          # bash_aliases kopieren
          create_backup_file "$BASH_ALIAS_FILE"
          cp -f "$LOCAL_DOWNLOAD_FILE" "$BASH_ALIAS_FILE" &>/dev/null
          if [ $? -eq 0 ];
          then
            chmod a+r "$BASH_ALIAS_FILE" &>/dev/null
            # /etc/bash.bashrc erweitern
            if [ $(grep -i -c -E "\/etc\/bash_aliases" "$GLOBAL_BASHRC_FILE") -eq 0 ];
            then
              create_backup_file "$GLOBAL_BASHRC_FILE"
# --------------------------------
cat >> "$GLOBAL_BASHRC_FILE" <<EOF

# ------------------
# Alias Definitions
# ------------------
if [ -f /etc/bash_aliases ];
then
  . /etc/bash_aliases
fi
# ------------------
EOF
# --------------------------------
              if [ $? -eq 0 ];
              then
                # Aktuelle Aliase des Benutzers in ~/.bashrc deaktivieren
                create_backup_file "$USER_BASHRC_FILE"
                sed -i "s/# alias l/alias l/g" "$USER_BASHRC_FILE"
                sed -i "s/alias l/# alias l/g" "$USER_BASHRC_FILE"
                e_and_l "$OK_TAG"
                CHANGES_MADE=1
              else
                restore_backup_file "$GLOBAL_BASHRC_FILE"
                e_and_l "$ERROR_TAG $LINENO"
              fi
            else
              e_and_l "$OK_TAG"
              CHANGES_MADE=1
            fi
          else
            restore_backup_file "$BASH_ALIAS_FILE"
            e_and_l "$ERROR_TAG $LINENO"
          fi
        fi
      else
        e_and_l "$ACTION_MESSAGE  ... $NC_TAG"
      fi
    else
      e_and_l "$ACTION_MESSAGE  ... $ERROR_TAG beim Download"
      add_full_log
    fi
    remove_file "$LOCAL_DOWNLOAD_FILE"
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE " "nur für Bash")"
  fi

  # ===========================================================================
  # Tastatur-Belegung zurück auf Standard setzen (nur Raspbian)
  # ===========================================================================
  ACTION_MESSAGE=" Standard ${light_cyan}Tastaturbelegung${colors_off} wiederherstellen"
  if [ $RASPBIAN -ne 0 ];
  then
    USER_RC_CONFIG="$USER_CONFIG_DIR/openbox/lxde-pi-rc.xml"
    STANDARD_RC_CONFIG="/etc/xdg/openbox/lxde-pi-rc.xml"
    # Nur weitermachen, wenn eine geänderte Konfiguration exisitiert
    if [ -s "$USER_RC_CONFIG" ];
    then
      # Wenn darin kein Tastatur-Kürzel Ctrl-Alt-T eingerichtet ist,
      # dann Tastatur-Belegung wieder auf Standard zurücksetzen
      if [ $(grep -i -c -E "key\=\"C-A-T\"" "$USER_RC_CONFIG" 2>/dev/null) -eq 0 ];
      then
        if [ -s "$STANDARD_RC_CONFIG" ];
        then
          ask_yes_or_no "$ACTION_MESSAGE"
          if [ $? -eq 1 ];
          then
            e_and_l -n "${ACTION_MESSAGE//96m/93m} ... "
            create_backup_file "$USER_RC_CONFIG"
            cp -f "$STANDARD_RC_CONFIG" "$USER_RC_CONFIG" &>/dev/null
            if [ $? -eq 0 ];
            then
              e_and_l "$OK_TAG"
              CHANGES_MADE=1
            else
              restore_backup_file "$USER_RC_CONFIG"
              e_and_l "$ERROR_TAG $LINENO"
            fi
          fi
        else
          e_and_l "$ACTION_MESSAGE ... $ERROR_TAG $LINENO"
        fi
      else
        e_and_l "$ACTION_MESSAGE ... $NC_TAG"
      fi
    else
      e_and_l "$ACTION_MESSAGE ... $NC_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$PIOS_TXT")"
  fi

  # ===========================================================================
  # Hinweis auf Änderungen
  # ===========================================================================
  if [ $CHANGES_MADE -gt 0 ];
  then
    e_and_l "$HALF_LINE"
    e_and_l " $HINWEIS_TAG: Einzelne Änderungen werden ev. erst bei der nächsten Anmeldung aktiv"
  fi

  # ===========================================================================
  # Durchführung weiterer Festplatten-Optimierungen
  # ===========================================================================
  e_and_l "$FULL_LINE"
  e_and_l " ${bold_blue}Durchführung weiterer Festplatten-Optimierungen${colors_off}"
  e_and_l "$HALF_LINE"
  # ---------------------------
  # S.M.A.R.T Tools einrichten
  # ---------------------------
  if [ $(LANG=en dpkg-query -W -f='${Status}' smartmontools 2>/dev/null | grep -i -c -E "ok installed") -eq 0 ];
  then
    e_and_l -n " Installiere ${bold_yellow}smartmontools${colors_off}, bitte warten    "
    apt install smartmontools -y &>"$LOG_TEMP"
    if [ $? -eq 0 ];
    then
      e_and_l "... $OK_TAG"
      SMART_TOOLS_AVAILABLE=1
    else
      e_and_l "... $ERROR_TAG"
      SMART_TOOLS_AVAILABLE=0
    fi
    add_full_log
  else
    SMART_TOOLS_AVAILABLE=1
  fi
  # ----------------------------
  # Update der Geräte-Datenbank
  # ----------------------------
  if [ $SMART_TOOLS_AVAILABLE -eq 1 ];
  then
    e_and_l -n " Update der ${light_cyan}Geräte-Datenbank${colors_off}, bitte warten  ... "
    update-smart-drivedb &>"$LOG_TEMP"
    if [ $? -eq 0 ];
    then
      e_and_l "$OK_TAG"
    else
      e_and_l "${bold_red}$NA_TXT${colors_off}"
    fi
    add_full_log
  fi
  # -------------------------
  # Liste der Disks erzeugen
  # -------------------------
  THE_DISK_LIST="$DOWNLOAD_DIR/disk-list"
  remove_file "$THE_DISK_LIST"
  LANG=en lsblk -d -o name,rota,type 2>/dev/null | grep -i disk 1>"$THE_DISK_LIST" 2>/dev/null
  if [ -s "$THE_DISK_LIST" ];
  then
    # -------------------------------------------------------------------------
    # Für jede gefundene Disk die S.M.A.R.T-Einstellungen und den I/O-Scheduler
    # sowie für SSDs zusätzlich die Ausrichtung prüfen (SMART ggf. aktivieren)
    # -------------------------------------------------------------------------
    while read disk_data;
    do
      disk_name="$(echo ${disk_data} | awk '{print $1}' | xargs)"
      disk_rota=$(echo ${disk_data} | awk '{print $2}' | xargs)
      DEVICE_NAME="/dev/${disk_name}"
      DISK_MODEL=$(LANG=en smartctl -i -d sat ${DEVICE_NAME} 2>/dev/null | grep -i -E "device\s*model" | cut -d":" -f 2 | xargs)
      if [ "$DISK_MODEL" = "" ];
      then
        DISK_MODEL=$(LANG=en lsblk -S -o model ${DEVICE_NAME} 2>/dev/null | awk 'NR>1')
      fi
      if [ "$DISK_MODEL" = "" ];
      then
        DISK_MODEL=$(LANG=en parted ${DEVICE_NAME} print 2>/dev/null | grep -i -E "^model" | cut -d":" -f 2)
      fi
      DISK_MODEL=${DISK_MODEL:0:40}
      DISK_MODEL=$(echo ${DISK_MODEL//_/ } | xargs)
      DISK_SERIAL=$(LANG=en smartctl -i -d sat ${DEVICE_NAME} 2>/dev/null | grep -i -E "serial\s*number" | cut -d":" -f 2 | xargs)
      disk_name=$(echo ${disk_name:0:8} | xargs)
      e_and_l "$HALF_LINE"
      e_and_l -n " Prüfe ${bold_white}$disk_name${colors_off}"
      if [ "$DISK_MODEL" != "" ]; then e_and_l -n " ($DISK_MODEL)"; fi
      if [ "$DISK_SERIAL" != "" ]; then e_and_l -n " [SN $DISK_SERIAL]"; fi
      e_and_l ""
      # ----------
      # S.M.A.R.T
      # ----------
      e_and_l -n " - Einstellung der ${light_cyan}SMART-Überwachung${colors_off} ... Überwachung "
      if [ $(LANG=en smartctl -i -d sat ${DEVICE_NAME} 2>/dev/null | grep -i support | grep -i -c available) -gt 0 ];
      then
        # ---------------------
        # S.M.A.R.T aktivieren
        # ---------------------
        if [ $(LANG=en smartctl -i -d sat ${DEVICE_NAME} 2>/dev/null | grep -i support | grep -i -c enabled) -eq 0 ];
        then
          smartctl -s on ${DEVICE_NAME} &>"$LOG_TEMP"
          if [ $? -eq 0 ];
          then
            e_and_l "${bold_green}wurde aktiviert${colors_off}"
          else
            e_and_l "$ERROR_TAG"
            add_full_log
          fi
        else
          e_and_l "${bold_green}aktiv${colors_off}"
        fi
        # --------------------------
        # S.M.A.R.T Fehler auslesen
        # --------------------------
        e_and_l -n " - Status des ${light_cyan}SMART-Fehlerprotokolls${colors_off} ... Fehlerliste "
        ERROR_LIST=$(smartctl -d sat --quietmode=errorsonly --all ${DEVICE_NAME} 2>"$LOG_TEMP")
        if [ "$ERROR_LIST" = "" ];
        then
          e_and_l "${bold_green}leer${colors_off}"
        else
          e_and_l "${bold_yellow}enthält${colors_off} $ERROR_TAG"
          do_log "$ERROR_LIST"
          add_full_log
        fi
      else
        e_and_l "${bold_red}$NA_TXT${colors_off}"
      fi
      # --------------
      # I/O-Scheduler
      # --------------
      if [ -f "/sys/block/${disk_name}/queue/scheduler" ];
      then
        e_and_l -n " - Einstellung des ${light_cyan}I/O-Schedulers${colors_off}    ... "
        if [ $(cat /sys/block/${disk_name}/queue/scheduler | grep -i -E "mq-deadline" | grep -i -c -E "none") -gt 0 ];
        then
          e_and_l "QueueConfig $OK_TAG"
        else
          e_and_l "$ERROR_TAG"
        fi
      fi
      # ---------------------------------------
      # Partitionen
      # ---------------------------------------
      parted -s -m ${DEVICE_NAME} unit B print 2>/dev/null | awk 'NR>2' |
      while read partition;
      do
        PARTITION_NR=$(echo $partition | cut -d":" -f 1 | xargs)
        e_and_l -n " - Partition ${light_cyan}$PARTITION_NR${colors_off}: "
        PARTITION_TYPE=$(echo $partition | cut -d":" -f 5 | xargs)
        PARTITION_TYPE=${PARTITION_TYPE:0:6}
        if [ "$PARTITION_TYPE" = "" ];
        then
          PARTITION_TYPE=$(LANG=en parted ${DEVICE_NAME} print 2>/dev/null | grep -i -E "^\s*${PARTITION_NR}\s" | awk '{print $5}' | xargs)
          PARTITION_TYPE=${PARTITION_TYPE:0:8}
          if [ "$PARTITION_TYPE" = "" ] ||
             [ "$PARTITION_TYPE" = "primary" ];
          then
            PARTITION_TYPE="unknown"
          fi
        fi
        e_and_l -n "${light_blue}$PARTITION_TYPE${colors_off}"
        ((ANZ_SPACES=11-${#PARTITION_TYPE}))
        insert_spaces $ANZ_SPACES
        PARTITION_SIZE=$(echo $partition | cut -d":" -f 4 | xargs)
        PARTITION_SIZE=${PARTITION_SIZE//B/}
        PARTITION_SIZE=$(show_human_bytes ${PARTITION_SIZE})
        PARTITION_SIZE=${PARTITION_SIZE:0:10}
        e_and_l -n "${light_yellow}$PARTITION_SIZE${colors_off}"
        ((ANZ_SPACES=12-${#PARTITION_SIZE}))
        insert_spaces $ANZ_SPACES
        e_and_l -n "... Ausrichtung "
        # if [ $disk_rota -eq 0 ];
        # then
          if [ "$PARTITION_TYPE" != "unknown" ] &&
             [ "$PARTITION_TYPE" != "extended" ];
          then
            PARTITION_NAME="${DEVICE_NAME}${PARTITION_NR}"
            if [ ! -e "$PARTITION_NAME" ];
            then
              PARTITION_NAME="${DEVICE_NAME}p${PARTITION_NR}"
            fi
            if [ -e "$PARTITION_NAME" ];
            then
              PARTITION_ALIGNMENT=$(parted ${PARTITION_NAME} align-check opt 1 2>"$LOG_TEMP" | awk '{print $1}' | xargs)
              if [ "$PARTITION_ALIGNMENT" != "" ];
              then
                if [ $PARTITION_ALIGNMENT -eq 1 ];
                then
                  e_and_l "$OK_TAG"
                else
                  e_and_l "$ERROR_TAG"
                  add_full_log
                fi
              else
                e_and_l "${bold_yellow}$NA_TXT${colors_off}"
              fi
            else
              e_and_l "${bold_yellow}$NA_TXT${colors_off}"
            fi
          else
            e_and_l "${bold_yellow}$NA_TXT${colors_off}"
          fi
        # else
        #   e_and_l "nicht geprüft ${dark_grey}(keine SSD)${colors_off}"
        # fi
      done
    done < "$THE_DISK_LIST"
    # -------------------------------------------------------------------------
    # Weitere Aktionen nur wenn eine SSD vorhanden ist
    # -------------------------------------------------------------------------
    SSD_FOUND=0
    while read disk_data;
    do
      disk_rota=$(echo ${disk_data} | awk '{print $2}' | xargs)
      if [ $disk_rota -eq 0 ]; then SSD_FOUND=1; fi
    done < "$THE_DISK_LIST"
    if [ $SSD_FOUND -ne 0 ];
    then
      # -----------------------------------------------------------------------
      # Auf Raspberry können wir uns das sparen, weil der kein AHCI hat ...
      # -----------------------------------------------------------------------
      if [ $RASPBERRY -eq 0 ];
      then
        # ---------------------------------------------------------------------
        # AHCI-Modus prüfen
        # ---------------------------------------------------------------------
        e_and_l "$HALF_LINE"
        e_and_l -n " Prüfe die System-Parameter des ${light_cyan}AHCI-Modus${colors_off}  ... "
        if [ $(LANG=en dmesg | grep -i -E "scsi" | grep -i -c -E "ahci") -gt 0 ];
        then
          e_and_l "$OK_TAG"
          # -------------------------------------------------------------------
          # Trimming der SSDs
          # -------------------------------------------------------------------
          if [ ${OPTION_FLAG[notrim]} -eq 0 ];
          then
            e_and_l -n " Führe ${light_cyan}Trimming der SSD${colors_off} durch, bitte warten ... "
            fstrim --all &>"$LOG_TEMP"
            if [ $? -eq 0 ];
            then
              e_and_l "$OK_TAG"
            else
              e_and_l "$ERROR_TAG"
              add_full_log
            fi
          fi
        else
          e_and_l "$ERROR_TAG: AHCI scheint nicht aktiv"
        fi
      fi
    fi
    # -------------------------------------------------------------------------
  else
    e_and_l " $ERROR_TAG: Es wurden keine Festplatten/Laufwerke gefunden."
  fi
  remove_file "$THE_DISK_LIST"

  e_and_l "$FULL_LINE"

fi

###############################################################################
# Reparaturen und diverse Bereinigungen
###############################################################################
if [ ${OPTION_FLAG[listonly]} -eq 0 ] &&
   [ ${OPTION_FLAG[cleansys]} -eq 1 ];
then

  e_and_l " ${bold_blue}Durchführung von Reparaturen und Bereinigungen${colors_off}"

  # ===========================================================================
  # Überprüfung der Zugriffsrechte des Wurzelverzeichnis
  # ===========================================================================
  e_and_l "$HALF_LINE"
  e_and_l -n " Prüfe ${light_cyan}Zugriffsrechte des Wurzelverzeichnis${colors_off} ... "
  ATTRIBS_ROOT="$(ls -la / | grep -E "\s\.$" | awk '{print $1}' | sed 's/d//')"
  if [ $( echo "$ATTRIBS_ROOT" | grep -i -c -E "rwxr-xr-x") -eq 0 ];
  then
    e_and_l "$ERROR_TAG"
    e_and_l " Die Zugriffsrechte des Wurzelverzeichnis sind nicht optimal [${light_yellow}$ATTRIBS_ROOT${colors_off}]."
    ask_yes_or_no " Sollen die Rechte auf ${bold_yellow}rwxr-xr-x${colors_off} korrigiert werden "
    if [ $? -eq 1 ];
    then
      e_and_l -n " Korrigiere ${light_cyan}Rechte des Wurzelverzeichnis${colors_off}    ... "
      chmod 755 / &>"$LOG_TEMP"
      if [ $? -eq 0 ];
      then
        e_and_l "$OK_TAG"
      else
        e_and_l "$ERROR_TAG"
        add_full_log
      fi
    fi
  else
    e_and_l "$NC_TAG"
  fi

  # ===========================================================================
  # Überprüfung der Paketquellen-Konsistenz
  # ===========================================================================
  e_and_l "$HALF_LINE"
  e_and_l " ${bold_blue}Überprüfung der Paketquellen-Konsistenz${colors_off}"
  e_and_l "$HALF_LINE"

  # Datei mit Quell-Angaben des Systems (Ubuntu und Partner)
  SOURCES_LIST_FILE="/etc/apt/sources.list"
  # Verzeichnis mit Dateien, die weitere Quell-Angaben beinhalten
  SOURCES_LIST_DIR="/etc/apt/sources.list.d"
  # Temporäre Dateien zum Bearbeiten der Quell-Listen
  ALL_SOURCE_FILES="$DOWNLOAD_DIR/all_source_files.tmp" # Liste aller Dateien mit Quellen
  ALL_SOURCES_LIST="$DOWNLOAD_DIR/all_sources_list.tmp" # Liste aller Quell-Angaben
  # ---------------------------------------------------------------------------
  # Letzte internen Arbeitslisten löschen
  # ---------------------------------------------------------------------------
  remove_file "$ALL_SOURCE_FILES"
  remove_file "$ALL_SOURCES_LIST"

  # ---------------------------------------------------------------------------
  # Prüfung auf abgelaufene APT-Key-Signaturen (Authentifizierungs-Schlüssel)
  # ---------------------------------------------------------------------------
  ACTION_MESSAGE=" Prüfung auf ${light_cyan}abgelaufene APT-Key-Signaturen${colors_off} ... "
  apt-key list &>/dev/null
  if [ $? -eq 0 ];
  then
    e_and_l -n "$ACTION_MESSAGE"
    EXPIRED_APT_FILE="expired-apt-keys.txt"
    EXPIRED_APT_LIST="$DOWNLOAD_DIR/$EXPIRED_APT_FILE"
    LANG=en apt-key list 2>/dev/null | grep -A 2 -i -E "(expired|verfallen):" | awk 'NR>1' | \
    sed 's/^[[:space:]]*/ /g' | sed 's/[[:space:]]*uid.*\][[:space:]]*/ /gi' > "$EXPIRED_APT_LIST"
    if [ -s "$EXPIRED_APT_LIST" ];
    then
      e_and_l "$WARN_TAG"
      e_and_l " Folgende APT-Signaturen sind ${bold_red}abgelaufen${colors_off} und damit ungültig"
      e_and_l " (Liste wurde auch gespeichert in $EXPIRED_APT_FILE):"
      declare -A APT_EXP_KEY
      declare -A APT_EXP_DSC
      APT_KEY_IDX=1
      while read expired_key;
      do
        read key_description
        APT_EXP_KEY["$APT_KEY_IDX"]="$expired_key"
        APT_EXP_DSC["$APT_KEY_IDX"]="$key_description"
        ((APT_KEY_IDX+=1))
      done < "$EXPIRED_APT_LIST"
      knr=1
      while [ $knr -lt $APT_KEY_IDX ];
      do
        expired_key="${APT_EXP_KEY[$knr]}"
        key_description="${APT_EXP_DSC[$knr]}"
        e_and_l " - $key_description"
        e_and_l "   Schlüssel ${bold_white}$expired_key${colors_off}"
        RAW_APT_KEY="${expired_key// /}"
        ask_yes_or_no "   Soll der Schlüssel ${light_yellow}erneuert${colors_off} werden"
        KEY_RENEW=$?
        if [ $KEY_RENEW -eq 1 ];
        then
          e_and_l -n "   Versuche den alten Schlüssel zu erneuern ... "
          apt-key adv --recv-keys --keyserver keys.gnupg.net "$RAW_APT_KEY" &>"$LOG_TEMP"
          if [ $? -eq 0 ];
          then
            e_and_l "$OK_TAG"
          else
            apt-key adv --recv-keys --keyserver keyserver.ubuntu.com "$RAW_APT_KEY" &>"$LOG_TEMP"
            if [ $? -eq 0 ];
            then
              e_and_l "$OK_TAG"
            else
              e_and_l "$ERROR_TAG"
              KEY_RENEW=0
              add_full_log
            fi
          fi
          # Wenn ein neuer Schlüssel hinzugefügt wurde, dann den verfallenen automatisch löschen,
          # sonst, wenn der Schlüssel nicht erneuert werden kann, anbieten ihn selbst zu löschen
          if [ $KEY_RENEW -eq 1 ];
          then
            apt-key del "$RAW_APT_KEY" &>/dev/null
          fi
        fi
        if [ $KEY_RENEW -eq 0 ];
        then
          ask_yes_or_no "   Soll der Schlüssel ${light_yellow}gelöscht${colors_off} werden"
          if [ $? -eq 1 ];
          then
            e_and_l -n "   Versuche den alten Schlüssel zu löschen  ... "
            apt-key del "$RAW_APT_KEY" &>"$LOG_TEMP"
            if [ $? -eq 0 ];
            then
              e_and_l "$OK_TAG"
            else
              e_and_l "$ERROR_TAG"
              add_full_log
            fi
          fi
        fi
        ((knr+=1))
      done
    else
      remove_file "$EXPIRED_APT_LIST"
      e_and_l "$NF_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$NA_TXT")"
  fi

  # ---------------------------------------------------------------------------
  # Prüfung auf veraltete APT-Key-Eintragungen
  # ---------------------------------------------------------------------------
  ACTION_MESSAGE=" Prüfung auf ${light_cyan}veraltete APT-Key-Eintragungen${colors_off} ... "
  apt-key list &>/dev/null
  if [ $? -eq 0 ];
  then
    e_and_l -n "$ACTION_MESSAGE"
    OLD_APT_KEY_FILE="/etc/apt/trusted.gpg"
    NEW_APT_KEY_DIR="/etc/apt/trusted.gpg.d"
    if [ -s "$OLD_APT_KEY_FILE" ] &&
      [ -d "$NEW_APT_KEY_DIR" ];
    then
      create_backup_file "$OLD_APT_KEY_FILE"
      TMP_APT_KEY_FILE="old-apt-keys.txt"
      TMP_APT_KEY_LIST="$DOWNLOAD_DIR/$TMP_APT_KEY_FILE"
      LANG=en apt-key --keyring "$OLD_APT_KEY_FILE" list 2>/dev/null | grep -A 2 -i -E "^pub" | grep -v -i -E "^pub" | grep -v -i -E "^\s*-" | \
      sed 's/^[[:space:]]*/ /g' | sed 's/[[:space:]]*uid.*\][[:space:]]*/ /gi' > "$TMP_APT_KEY_LIST"
      if [ -s "$TMP_APT_KEY_LIST" ];
      then
        declare -A APT_TMP_KEY
        declare -A APT_TMP_DSC
        APT_KEY_IDX=1
        while read old_key;
        do
          THE_OLD_KEY=$(echo $old_key | sed 's/ //g')
          read THE_KEY_DESC
          THE_KEY_DESC="${THE_KEY_DESC%%\<*}"
          THE_KEY_DESC=$(echo "$THE_KEY_DESC" | xargs)
          if [ "$THE_OLD_KEY" != "" ] &&
             [ "$THE_KEY_DESC" != "" ];
          then
            APT_TMP_KEY["$APT_KEY_IDX"]="$THE_OLD_KEY"
            APT_TMP_DSC["$APT_KEY_IDX"]="$THE_KEY_DESC"
            ((APT_KEY_IDX+=1))
          fi
        done < "$TMP_APT_KEY_LIST"
        if [ $APT_KEY_IDX -gt 1 ];
        then
          e_and_l "$WARN_TAG"
          e_and_l " Es wurden veraltete Einträge gefunden. Es wird empfohlen, die folgenden"
          e_and_l " Einträge in ein neues Format umzuwandeln (bitte jeweils auswählen):"
          knr=1
          while [ $knr -lt $APT_KEY_IDX ];
          do
            THE_OLD_KEY="${APT_TMP_KEY[$knr]}"
            THE_KEY_DESC="${APT_TMP_DSC[$knr]}"
            echo -e "$HALF_MINUS_LINE"
            ask_yes_or_no " - $THE_KEY_DESC"
            if [ $? -eq 1 ];
            then
              NEW_APT_FILE_NAME=$(echo "$THE_KEY_DESC" | tr A-Z a-z | sed 's/(//g' | sed 's/)//g' | xargs | sed 's/ /-/g')
              if [ "$NEW_APT_FILE_NAME" != "" ]
              then
                NEW_APT_FILE_NAME+=".asc"
                if [ ! -s "$NEW_APT_KEY_DIR/$NEW_APT_FILE_NAME" ];
                then
                  e_and_l -n " Neuer Schlüssel: ${bold_white}$NEW_APT_FILE_NAME${colors_off} ... "
                  apt-key export "$THE_OLD_KEY" > "$NEW_APT_KEY_DIR/$NEW_APT_FILE_NAME" 2>"$LOG_TEMP"
                  if [ $? -eq 0 ];
                  then
                    e_and_l "$OK_TAG"
                    e_and_l -n " Lösche veralteten Schlüssel ... "
                    apt-key --keyring "$OLD_APT_KEY_FILE" del "$THE_OLD_KEY" &>"$LOG_TEMP"
                    if [ $? -eq 0 ];
                    then
                      e_and_l "$OK_TAG"
                    else
                      e_and_l "$ERROR_TAG"
                    fi
                  else
                    e_and_l "$ERROR_TAG"
                  fi
                else
                  e_and_l " $ERROR_TAG: Die neue Schlüssel-Datei $NEW_APT_KEY_DIR/$NEW_APT_FILE_NAME existiert schon."
                  ask_yes_or_no " Den veralteten Schlüssel löschen"
                  if [ $? -eq 1 ];
                  then
                    e_and_l -n " Lösche veralteten Schlüssel ... "
                    apt-key --keyring "$OLD_APT_KEY_FILE" del "$THE_OLD_KEY" &>"$LOG_TEMP"
                    if [ $? -eq 0 ];
                    then
                      e_and_l "$OK_TAG"
                    else
                      e_and_l "$ERROR_TAG"
                    fi
                  fi
                fi
              else
                e_and_l " $ERROR_TAG $LINENO"
              fi
            fi
            ((knr+=1))
          done
          add_full_log
        else
          remove_file "$TMP_APT_KEY_LIST"
          e_and_l "$NF_TAG"
        fi
      else
        remove_file "$TMP_APT_KEY_LIST"
        e_and_l "$NF_TAG"
      fi
    else
      e_and_l "$NF_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$NA_TXT")"
  fi

  # ---------------------------------------------------------------------------
  # Liste aller Dateien mit Quell-Angaben erstellen
  # ---------------------------------------------------------------------------
  if [ -s "$SOURCES_LIST_FILE" ];
  then
    echo "$SOURCES_LIST_FILE" > "$ALL_SOURCE_FILES"
  fi
  if [ -d "$SOURCES_LIST_DIR" ];
  then
    find "$SOURCES_LIST_DIR" -type f >> "$ALL_SOURCE_FILES" 2>/dev/null
  fi

  # ---------------------------------------------------------------------------
  # Liste aller Quell-Angaben aus den Quell-Dateien erstellen und diese dabei
  # um überflüssige Leerstellen bereinigen, damit auch redundante Einträge
  # sicher gefunden werden, die sich ev. nur durch Leerzeichen unterscheiden
  # ---------------------------------------------------------------------------
  if [ -s "$ALL_SOURCE_FILES" ];
  then
    while read file_path;
    do
      SRC_ENTRY=$(grep -v -E "^#" "$file_path" 2>/dev/null | \
      sed -E "/^[[:space:]]*$/d" | sed -E "s/[[:space:]]*[[:space:]]/ /g" | sed -E "s/\[[[:space:]]*arch.*\][[:space:]]//g")
      if [ "$SRC_ENTRY" != "" ];
      then
        echo "$SRC_ENTRY" >> "$ALL_SOURCES_LIST" 2>/dev/null
      fi
    done < "$ALL_SOURCE_FILES"
  fi

  # ---------------------------------------------------------------------------
  # Redundante Einträge aus der Gesamtliste (NICHT den Quelldateien) entfernen
  # Hinweis: NICHT sort -u verwenden, da "sort" die Reihenfolge der Zeilen
  # ändert und auch nicht "uniq", da dies nur direkte Nachbarn entfernt ;)
  # ---------------------------------------------------------------------------
  THE_TEMP_FILE="$DOWNLOAD_DIR/tmp_sources_list.tmp"
  if [ -s "$ALL_SOURCES_LIST" ];
  then
    awk '!seen[$0]++' "$ALL_SOURCES_LIST" > "$THE_TEMP_FILE" 2>/dev/null
    remove_file "$ALL_SOURCES_LIST"
    mv "$THE_TEMP_FILE" "$ALL_SOURCES_LIST" &>/dev/null
  fi

  # -------------------------------------------------------------------------
  # Verbliebene Quell-Angaben verarbeiten
  # -------------------------------------------------------------------------
  ACTION_MESSAGE=" Prüfung auf ${light_cyan}redundante Paket-Quell-Angaben${colors_off} ... "
  e_and_l "$HALF_LINE"
  if [ -s "$ALL_SOURCES_LIST" ];
  then
    SOURCES_URI_LIST="$DOWNLOAD_DIR/sources_uri_list.tmp"
    remove_file "$SOURCES_URI_LIST"
    # -------------------------------------------------------------------------
    # Äußere Schleife durch alle Quell-Angaben --------------------------------
    # -------------------------------------------------------------------------
    e_and_l -n "$ACTION_MESSAGE"
    REDUNDANT_FOUND=0
    while read source_entry;
    do
      source_entry=$(echo "$source_entry" | sed 's/\[\s*signed\-by\s*\=.*\]//gi')
      FIELD_CNT=$(echo "$source_entry" | awk '{print NF}')
      FIELD_TYP=$(echo "$source_entry" | awk '{print $1}')
      FIELD_URI=$(echo "$source_entry" | awk '{print $2}')
      FIELD_DIS=$(echo "$source_entry" | awk '{print $3}')
      echo "$FIELD_URI" | sed 's/\/$//g' >> "$SOURCES_URI_LIST" 2>/dev/null
      FIELD_OPT=""
      i=4
      while [ $i -le $FIELD_CNT ];
      do
        FIELD_OPT+="$(echo "$source_entry" | awk -v f=$i '{print $f}') "
        ((i+=1))
      done
      FIELD_OPT=$(echo $FIELD_OPT | xargs)
      REG_EXP="$FIELD_TYP\s*\s(\[arch=.*\]\s)*\s*$FIELD_URI\/*\s*\s$FIELD_DIS\s*\s${FIELD_OPT// /\\s\*\\s}"
      # -----------------------------------------------------------------------
      # Innere Schleife durch alle Dateien ------------------------------------
      # -----------------------------------------------------------------------
      # 1. Prüfen ob Redundanzen vorhanden sind
      # -----------------------------------------------------------------------
      ENTRIES_FOUND=0
      while read source_file;
      do
        # Sicherungsdateien überspringen, da diese von apt nicht geprüft werden
        FILE_EXTENSION=${source_file##*\.}
        if [ "$FILE_EXTENSION" != "dpkg-old" ] &&
           [ "$FILE_EXTENSION" != "save" ] &&
           [ "$FILE_EXTENSION" != "bak" ];
        then
          if [ $(cat "$source_file" 2>/dev/null | grep -i -c -E "$REG_EXP") -gt 0 ];
          then
            ((ENTRIES_FOUND+=1))
          fi
        fi
      done < "$ALL_SOURCE_FILES"
      # -----------------------------------------------------------------------
      # 2. Wenn Redundanzen gefunden wurden, dann betroffene Dateien anzeigen
      # -----------------------------------------------------------------------
      # LIST_FILE_FOUND=0 # Derzeit nicht verwendet
      if [ $ENTRIES_FOUND -gt 1 ];
      then
        if [ $REDUNDANT_FOUND -eq 0 ];
        then
          e_and_l "$WARN_TAG"
          e_and_l " Es wurden Redundanzen oder Unstimmigkeiten gefunden, die nicht eindeutig"
          e_and_l " automatisiert bereinigt werden können - daher ggf. bitte manuell ändern."
          REDUNDANT_FOUND=1
        fi
        # e_and_l ""
        e_and_l "${bold_white} - $source_entry${colors_off}"
        e_and_l -n "   Enthalten in Datei"
        if [ $ENTRIES_FOUND -gt 1 ]; then e_and_l -n "en"; fi
        e_and_l ":"
        while read source_file;
        do
          if [ $(cat "$source_file" 2>/dev/null | grep -i -c -E "$REG_EXP") -gt 0 ];
          then
            # e_and_l -n "   ${source_file/\/etc\/apt\/sources.list.d\//}" # Kurzform
            e_and_l -n "   $source_file" # Voller Pfad
            # -----------------------------------------------------
            # FILE_EXTENSION=${source_file##*\.}
            # if [ "$FILE_EXTENSION" = "dpkg-old" ] ||
            #    [ "$FILE_EXTENSION" = "save" ] ||
            #    [ "$FILE_EXTENSION" = "bak" ];
            # then
            #   e_and_l " ($OK_TAG)"
            # else
            #   if [ "$FILE_EXTENSION" != "list" ];
            #   then
            #     e_and_l " (${bold_yellow}ignoriert${colors_off})"
            #   else
            #     # Wenn der selbe Eintrag in mehreren .list-Dateien
            #     # auftaucht, dann diesen als Konflikt anzeigen ...
            #     if [ $ENTRIES_FOUND -ge 2 ] &&
            #        [ $LIST_FILE_FOUND -gt 0 ];
            #     then
            #       e_and_l " (${bold_red}Konflikt${colors_off})"
            #     else
            #       e_and_l " ($OK_TAG)"
            #     fi
            #     LIST_FILE_FOUND=1
            #   fi
            # fi
            # -----------------------------------------------------
            # Um Verwirrung zu vermeiden besser kein Hinweis hinter
            # jedem Dateinamen (siehe auskommentierte Zeilen zuvor)
            e_and_l ""
          fi
        done < "$ALL_SOURCE_FILES"
      fi
      # -----------------------------------------------------------------------
    done < "$ALL_SOURCES_LIST" # Ende äußere Schleife durch alle Quell-Angaben
    if [ $REDUNDANT_FOUND -eq 0 ];
    then
      e_and_l "$NF_TAG"
    fi

    # -------------------------------------------------------------------------
    # Prüfung der Erreichbarkeit der Server
    # -------------------------------------------------------------------------
    if [ -s "$SOURCES_URI_LIST" ];
    then
      ACTION_MESSAGE=" Prüfung der ${light_cyan}Erreichbarkeit der Paketserver${colors_off}"
      if [ ${OPTION_FLAG[nopkgsrv]} -eq 0 ];
      then
        # Doppelte URIs entfernen
        THE_TEMP_FILE="$DOWNLOAD_DIR/tmp_uri_list.tmp"
        awk '!seen[$0]++' "$SOURCES_URI_LIST" > "$THE_TEMP_FILE" 2>/dev/null
        remove_file "$SOURCES_URI_LIST"
        mv "$THE_TEMP_FILE" "$SOURCES_URI_LIST" &>/dev/null
        e_and_l "$HALF_LINE"
        e_and_l "$ACTION_MESSAGE:"
        # Nur zur Ermittlung des längsten Namens --------------------------------
        MAX_NAME_LENGTH=0
        while read src_uri;
        do
          DOMAIN_PART=$(echo "$src_uri" | awk -F/ '{print $3}' | xargs)
          SUBDOM_PART=$(echo "$src_uri" | sed -E "s/.*$DOMAIN_PART\///g")
          SUBDOM_PART=${SUBDOM_PART%%/*}
          DOM_PART_LENGTH=${#DOMAIN_PART}
          SUB_PART_LENGTH=${#SUBDOM_PART}
          ((FULL_NAME_LENGTH=DOM_PART_LENGTH+SUB_PART_LENGTH))
          if [ $FULL_NAME_LENGTH -gt $MAX_NAME_LENGTH ];
          then
            MAX_NAME_LENGTH=$FULL_NAME_LENGTH
          fi
        done < "$SOURCES_URI_LIST"
        ((MAX_NAME_LENGTH+=1))
        # -----------------------------------------------------------------------
        while read src_uri;
        do
          if [ "$src_uri" != "" ];
          then
            DOMAIN_PART=$(echo "$src_uri" | awk -F/ '{print $3}' | xargs)
            SUBDOM_PART=$(echo "$src_uri" | sed -E "s/.*$DOMAIN_PART\///g")
            SUBDOM_PART=${SUBDOM_PART%%/*}
            DOM_PART_LENGTH=${#DOMAIN_PART}
            SUB_PART_LENGTH=${#SUBDOM_PART}
            # e_and_l -n " - ${bold_white}$src_uri${colors_off}"
            e_and_l -n " - ${bold_white}$DOMAIN_PART${colors_off} ($SUBDOM_PART)"
            ((ANZ_SPACES=MAX_NAME_LENGTH-DOM_PART_LENGTH-SUB_PART_LENGTH))
            insert_spaces $ANZ_SPACES
            e_and_l -n " ... "
            TEST_FILE="$DOWNLOAD_DIR/download_test.tmp"
            remove_file "$TEST_FILE"
            TARGET_REACHED=0
            # Test 1 mit Download von vollem Pfad
            wget -nv -O "$TEST_FILE" "$src_uri/" &>/dev/null
            if [ -s "$TEST_FILE" ];
            then
              TARGET_REACHED=1
            else
              # Test 2 nur auf die Domain (falls wget abgewiesen wird)
              ping -c 1 "$DOMAIN_PART" &>/dev/null
              if [ $? -eq 0 ];
              then
                TARGET_REACHED=2
              fi
            fi
            if [ $TARGET_REACHED -gt 0 ];
            then
              e_and_l -n "$OK_TAG"
              if [ $TARGET_REACHED -eq 2 ];
              then
                e_and_l " ${dark_grey}(Domain)${colors_off}"
              else
                e_and_l ""
              fi
            else
              e_and_l "$ERROR_TAG"
              e_and_l "   Enthalten in Datei(en):"
              while read source_file;
              do
                if [ $(cat "$source_file" 2>/dev/null | grep -i -c -E "$src_uri") -gt 0 ];
                then
                  e_and_l "   $source_file"
                fi
              done < "$ALL_SOURCE_FILES"
            fi
            remove_file "$TEST_FILE"
          fi
        done < "$SOURCES_URI_LIST"
      else
        e_and_l "$(skip_text "$ACTION_MESSAGE" "nicht ausgewählt")"
      fi
    fi
  else # Keine Paketquellen gefunden
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$NA_TXT")"
  fi
  # ---------------------------------------------------------------------------
  # Temporäre Dateien löschen
  # ---------------------------------------------------------------------------
  remove_file "$THE_TEMP_FILE"
  remove_file "$ALL_SOURCES_LIST"
  remove_file "$ALL_SOURCE_FILES"
  remove_file "$SOURCES_URI_LIST"

  # ===========================================================================
  # Bereinigung des Systems
  # ===========================================================================
  e_and_l "$FULL_LINE"
  e_and_l " ${bold_blue}Bereinigung des Systems${colors_off}"
  e_and_l "$HALF_LINE"
  e_and_l " ${bold_blue}Kernel${colors_off}"
  e_and_l "$HALF_LINE"

  # ===========================================================================
  # Löschen nicht verwendeter Kernel-Versionen
  # ===========================================================================
  OLD_KERNEL_LIST="$DOWNLOAD_DIR/old_kernel_List.tmp"
  # Aktuelle Kernel-Version ermitteln
  CURR_KERNEL_VERSION="$(uname -r)"
  # Nicht verwendete Kernel-Versionen ermitteln
  echo $(dpkg -l linux-{image,headers}-"[0-9]*" 2>/dev/null | awk '/ii/{print $2}' | grep -ve "$(uname -r | sed -r 's/-[a-z]+//')") > "$OLD_KERNEL_LIST"
  declare -A REMOVE_KERNEL_TABLE
  REMOVE_KERNEL_IDX=0
  while read old_kernel;
  do
    if [ "$old_kernel" != "" ] &&
       [ "$old_kernel" != "$CURR_KERNEL_VERSION" ];
    then
       kernel_base_name="$(echo ${old_kernel} | sed 's/linux-image-//i' | sed 's/linux-headers-//i' | sed 's/-generic//i')"
       if [ $(grep -i -r -l -E "$kernel_base_name" /boot/efi 2>/dev/null | wc -l) -eq 0 ] &&
          [ $(grep -i -r -l -E "$kernel_base_name" /boot/grub 2>/dev/null | wc -l) -eq 0 ] &&
          [ $(ls -la /boot/initrd.img 2>/dev/null | grep -c -E "$kernel_base_name") -eq 0 ] &&
          [ $(ls -la /boot/vmlinuz 2>/dev/null | grep -c -E "$kernel_base_name") -eq 0 ];
      then
        REMOVE_KERNEL_TABLE[$REMOVE_KERNEL_IDX]="$old_kernel"
        ((REMOVE_KERNEL_IDX+=1))
      fi
    fi
  done < "$OLD_KERNEL_LIST"
  if [ -s "$OLD_KERNEL_LIST" ] &&
     [ $REMOVE_KERNEL_IDX -gt 0 ];
  then
    e_and_l " Es wurden ${bold_yellow}$REMOVE_KERNEL_IDX${colors_off} Einträge von nicht verwendeten ${light_cyan}Kernel-Versionen${colors_off} gefunden."
    e_and_l " Die aktuell verwendete Version ist: ${light_cyan}$(echo ${CURR_KERNEL_VERSION} | sed 's/-generic//i')${colors_off}."
    ask_yes_or_no " Nicht verwendete Versionen auswählbar löschen"
    if [ $? -eq 1 ];
    then
      kernel_changed=0
      for old_kernel in ${REMOVE_KERNEL_TABLE[@]}
      do
        kernel_show_name="$(echo ${old_kernel} | sed 's/-generic//i')"
        ask_yes_or_no " Version ${light_cyan}$kernel_show_name${colors_off} löschen"
        if [ $? -eq 1 ];
        then
          # Kernel selbst löschen
          e_and_l -n " Lösche ${bold_yellow}$kernel_show_name${colors_off} ... "
          apt-get purge -y "$old_kernel" &>"$LOG_TEMP"
          if [ $? -eq 0 ];
          then
            # Verbliebene Komponenten löschen, sofern diese nicht mehr gebraucht werden
            kernel_base_name="$(echo ${old_kernel} | sed 's/linux-image-//i' | sed 's/linux-headers-//i')"
            kernel_config_file="/boot/config-$kernel_base_name"
            if [ -f "$kernel_config_file" ];
            then
              # e_and_l " Removing $kernel_config_file"
              remove_file "$kernel_config_file"
            fi
            kernel_initrd_file="/boot/initrd.img-$kernel_base_name"
            if [ -f "$kernel_initrd_file" ];
            then
              # e_and_l " Removing $kernel_initrd_file"
              remove_file "$kernel_initrd_file"
            fi
            kernel_sysmap_file="/boot/System.map-$kernel_base_name"
            if [ -f "$kernel_sysmap_file" ];
            then
              # e_and_l " Removing $kernel_sysmap_file"
              remove_file "$kernel_sysmap_file"
            fi
            kernel_vmlinuz_file="/boot/vmlinuz-$kernel_base_name"
            if [ -f "$kernel_vmlinuz_file" ];
            then
              # e_and_l " Removing $kernel_vmlinuz_file"
              remove_file "$kernel_vmlinuz_file"
            fi
            e_and_l "$OK_TAG"
            ((kernel_changed+=1))
          else
            e_and_l "$ERROR_TAG"
            add_full_log
          fi
        fi
      done
      if [ $kernel_changed -gt 0 ];
      then
        e_and_l " Es wurden ${light_yellow}$kernel_changed${colors_off} Einträge gelöscht."
        ask_yes_or_no " Sollen Dateisystem und GRUB-Loader erneuert werden"
        if [ $? -eq 1 ];
        then
          e_and_l -n " Aktualisiere das ${light_yellow}Initial Ram FileSystem${colors_off}  ... "
          update-initramfs -u &>"$LOG_TEMP"
          if [ $? -eq 0 ];
          then
            e_and_l "$OK_TAG"
          else
            e_and_l "$ERROR_TAG"
          fi
          add_full_log
          e_and_l -n " Aktualisiere die Einträge im ${light_yellow}GRUB-Loader${colors_off} ... "
          update-grub &>"$LOG_TEMP"
          if [ $? -eq 0 ];
          then
            e_and_l "$OK_TAG"
          else
            e_and_l "$ERROR_TAG"
          fi
          add_full_log
        fi
      fi
      e_and_l "$HALF_LINE"
    fi
  else
    e_and_l " Löschen nicht verwendeter ${light_cyan}Kernel-Versionen${colors_off} ... $NF_TAG"
  fi
  remove_file "$OLD_KERNEL_LIST"

  # ===========================================================================
  # Erhöhung der initramfs-Kompressions-Rate
  # ===========================================================================
  ACTION_MESSAGE=" Erhöhung der ${light_cyan}initramfs-Kompressions-Rate${colors_off}  "
  IRFS_CONF_FILE="/etc/initramfs-tools/initramfs.conf"
  if [ -s "$IRFS_CONF_FILE" ];
  then
    if [ $(cat "$IRFS_CONF_FILE" | grep -i -c -E "^\s*COMPRESS\s*=") -ne 0 ];
    then
      IRFS_COMP=$(cat ${IRFS_CONF_FILE} | grep -i -E "^\s*COMPRESS\s*=" | sed -E "s/^\s*COMPRESS\s*=\s*//i")
      if [ "$IRFS_COMP" != "xz" ] &&
         [ "$IRFS_COMP" != "zstd" ];
      then
        e_and_l " Die aktuelle Kompressions-Methode des initramfs ist nur ${bold_white}$IRFS_COMP${colors_off}."
        ask_yes_or_no " Soll die ${light_cyan}Kompressions-Rate${colors_off} mit Methode ${bold_white}xz${colors_off} erhöht werden"
        if [ $? -eq 1 ];
        then
          e_and_l " $ACHTUNG_TAG: Dieser Vorgang verändert wichtige Boot-Dateien und sollte nur nach"
          e_and_l " einem vollständigen System-Backup durchgeführt werden! Soll jetzt wirklich die"
          e_and_l -n " Kompressions-Methode des initramfs geändert werden? [Bestätigung mit ${bold_yellow}ja${colors_off}]: "
          read -r CONFIRM_TEXT
          if [ "$CONFIRM_TEXT" == "ja" ] ||
             [ "$CONFIRM_TEXT" == "JA" ];
          then
            e_and_l " $USER_CHOICE_YES"
            create_backup_file "$IRFS_CONF_FILE"
            e_and_l -n "${ACTION_MESSAGE//96m/93m}"
            sed -i -E "s/^\s*COMPRESS\s*=\s*[0-9a-zA-Z]*\s*$/COMPRESS=xz/gi" "$IRFS_CONF_FILE"
            if [ $? -eq 0 ];
            then
              e_and_l " ... $OK_TAG"
              e_and_l " Erneuerung des ${light_yellow}initramfs${colors_off} ... bitte warten!"
              update-initramfs -u -k all
              if [ $? -eq 0 ];
              then
                CHANGES_MADE=1
              fi
            else
              e_and_l " ... $ERROR_TAG $LINENO"
            fi
          else
            e_and_l " $USER_CHOICE_NO"
          fi
        fi
      else # Schon optimiert
        e_and_l "$ACTION_MESSAGE ... $NC_TAG"
      fi
    else # Kein COMPRESS-Eintrag
      e_and_l "$(skip_text "$ACTION_MESSAGE" "$NA_TXT")"
    fi
  else # Keine initramfs.conf
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$NA_TXT")"
  fi

  e_and_l "$HALF_LINE"
  e_and_l " ${bold_blue}Veraltete und temporäre Daten${colors_off}"
  e_and_l "$HALF_LINE"

  # ===========================================================================
  # Löschen veralteter APT-Paket-Listen und APT-Cache-Dateien
  # ===========================================================================
  if lsof -v &>/dev/null;
  then
    ask_yes_or_no " Den ${light_cyan}APT-Zwischenspeicher${colors_off} und ${light_cyan}Paket-Listen${colors_off} bereinigen"
    if [ $? -eq 1 ];
    then
      # Nur weitermachen, wenn nicht gerade eine andere dpkg-Aktion läuft
      if [ $(lsof /var/lib/dpkg/lock 2>/dev/null | wc -l) -eq 0 ];
      then
        # Löschen der APT-Paket-Listen ----------------------------------------------
        if [ -d "/var/lib/apt/lists" ];
        then
          e_and_l -n " - Löschen der veralteten ${light_yellow}APT-Paket-Listen${colors_off}  ... "
          rm -f /var/lib/apt/lists/* &>"$LOG_TEMP"
          e_and_l "$OK_TAG"
          add_full_log
        fi
        # Löschen veralteter APT-Cache-Dateien --------------------------------------
        e_and_l -n " - Löschen der veralteten ${light_yellow}APT-Cache-Dateien${colors_off} ... "
        apt-get clean &>"$LOG_TEMP"
        if [ $? -eq 0 ];
        then
          apt-get autoclean &>>"$LOG_TEMP"
          if [ $? -eq 0 ];
          then
            e_and_l "$OK_TAG"
          else
            e_and_l "$ERROR_TAG $LINENO"
          fi
        else
          e_and_l "$ERROR_TAG $LINENO"
        fi
        add_full_log
        # Repository aktualisieren und Paketlisten neu erstellen --------------
        repo_update " - Erneuerung des ${light_yellow}Repository${colors_off}, bitte warten  ... "
      else
        e_and_l " $ERROR_TAG: APT ist gerade durch einen anderen Prozess geblockt (Update?), eine"
        e_and_l " Bereinigung daher derzeit ${bold_red}nicht${colors_off} möglich - bitte später nochmals versuchen."
      fi
    fi
  fi

  # ===========================================================================
  # Löschen veralteter Snap-Snapschüsse
  # ===========================================================================
  if [ $SNAP_INSTALLED -ne 0 ];
  then
    remove_file "$SNAPSHOT_SNAPS_LIST"
    LANG=en_US.UTF-8 snap saved | tail --lines=+2 | awk '{print $1, $2, "(A"$3")", "(V"$4")", "(R"$5")", "(S"$6")"}' >> "$SNAPSHOT_SNAPS_LIST"
    if [ -s "$SNAPSHOT_SNAPS_LIST" ];
    then
      remove_snapshots
    else
      e_and_l " Löschen der veralteten ${light_cyan}Snap-Snapschüsse${colors_off}    ... $NF_TAG"
      remove_file "$SNAPSHOT_SNAPS_LIST"
    fi
  fi

  # ===========================================================================
  # Löschen der veralteten System-Log-Dateien
  # ACHTUNG: Die Anzahl Tage werden weiter oben mit ANZ_LOG_DAYS festgelegt
  # ===========================================================================
  ACTION_MESSAGE=" Löschen der veralteten ${light_cyan}System-Log-Dateien${colors_off}  ... "
  VAR_LOG_DIR="/var/log"
  if [ -d "$VAR_LOG_DIR" ];
  then
    # Anzahl veralteter Dateien ermitteln
    OLD_LOGS_FILES=$(find "$VAR_LOG_DIR" -depth -type f -mtime +${ANZ_LOG_DAYS} 2>/dev/null | wc -l)
    EMPTY_LOG_DIRS=$(find "$VAR_LOG_DIR/journal" -depth -type d -empty 2>/dev/null | wc -l)
    if [ $OLD_LOGS_FILES -gt 0 ] ||
       [ $EMPTY_LOG_DIRS -gt 0 ];
    then
      # Belegten Speicherplatz der Dateien ermitteln
      # (nur wenn es auch Dateien gibt, da "du" sonst nicht das gewünschte Ergebnis liefert ;)
      if [ $OLD_LOGS_FILES -gt 0 ];
      then
        OLD_LOGS_BYTES=$(find "$VAR_LOG_DIR" -depth -type f -mtime +${ANZ_LOG_DAYS} 2>/dev/null | xargs du -b -c -s 2>/dev/null | tail -1 | awk '{print $1}')
      else
        OLD_LOGS_BYTES=0
      fi
      ((OLD_LOGS_FILES+=EMPTY_LOG_DIRS))
      QUESTION_TEXT=" Veraltete ${light_cyan}System-Logs${colors_off} löschen (${light_purple}$OLD_LOGS_FILES Dateien, "
      QUESTION_TEXT+=$(show_human_bytes "$OLD_LOGS_BYTES")
      QUESTION_TEXT+="${colors_off})"
      ask_yes_or_no "$QUESTION_TEXT"
      if [ $? -eq 1 ];
      then
        e_and_l -n " Löschen der veralteten ${light_yellow}System-Log-Dateien${colors_off}  ... "
        # Veraltete Dateien löschen
        find "$VAR_LOG_DIR" -depth -type f -mtime +${ANZ_LOG_DAYS} -delete &>"$LOG_TEMP"
        # Leere Ordner löschen (nur unter journal)
        if [ -d "$VAR_LOG_DIR/journal" ];
        then
          find "$VAR_LOG_DIR/journal" -depth -type d -empty -delete &>>"$LOG_TEMP"
        fi
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG"
        else
          e_and_l "$ERROR_TAG"
        fi
        add_full_log
      fi
    else
      e_and_l "$ACTION_MESSAGE$ND_TAG"
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE" "$NF_TXT")"
  fi

  # ===========================================================================
  # Löschen der gespeicherten Vorschaubilder (Thumbnail-Cache)
  # ===========================================================================
  ACTION_MESSAGE=" Löschen des gespeicherten ${light_cyan}Thumbnail-Cache${colors_off}  ... "
  THUMBS_DIR="$USER_HOME_DIR/.cache/thumbnails"
  if [ -d "$THUMBS_DIR" ];
  then
    THUMBS_TOTAL_BYTES=$(du -b -c -s ${THUMBS_DIR} 2>/dev/null | tail -1 | awk '{print $1}')
    THUMBS_TOTAL_FILES=$(find ${THUMBS_DIR} -type f 2>/dev/null | wc -l)
    if [ $THUMBS_TOTAL_FILES -gt 0 ];
    then
      QUESTION_TEXT=" ${light_cyan}Thumbnail-Cache${colors_off} löschen (${light_purple}$THUMBS_TOTAL_FILES Dateien, "
      QUESTION_TEXT+=$(show_human_bytes "$THUMBS_TOTAL_BYTES")
      QUESTION_TEXT+="${colors_off})"
      ask_yes_or_no "$QUESTION_TEXT"
      if [ $? -eq 1 ];
      then
        e_and_l -n " Löschen der gespeicherten ${light_yellow}Vorschau-Bilder${colors_off}  ... "
        rm -f -r ${THUMBS_DIR} &>"$LOG_TEMP"
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG"
        else
          e_and_l "$ERROR_TAG"
        fi
        add_full_log
      fi
    else
      e_and_l "$ACTION_MESSAGE$ND_TAG"
    fi
  else
    e_and_l "$ACTION_MESSAGE$ND_TAG"
  fi

  # ===========================================================================
  # Löschen der veralteten Datei-Nutzungsdaten
  # ===========================================================================
  ACTION_MESSAGE=" Löschen gespeicherter ${light_cyan}Datei-Nutzungsdaten${colors_off}  ... "
  # ACHTUNG: Alle Pfadangaben in SEARCH_FILE_LIST sind relativ zum $USER_HOME_DIR
  #          und dürfen KEINE Leerzeichen enthalten!
  SEARCH_FILE_LIST=('.recently-used'
                    '.local/share/recently-used.xbel*'
                    '.local/share/user-places.xbel*'
                    '.local/share/RecentDocuments/*'
                   )
  FILES_FOUND_TOTAL_BYTES=0
  FILES_FOUND_TOTAL_FILES=0
  for search_mask in ${SEARCH_FILE_LIST[@]};
  do
    SEARCH_FILE_MASK="$USER_HOME_DIR/$search_mask"
    FILES_FOUND_BYTES=$(du -b -c -s ${SEARCH_FILE_MASK} 2>/dev/null | tail -1 | awk '{print $1}')
    FILES_FOUND_FILES=$(find ${SEARCH_FILE_MASK} -type f 2>/dev/null | wc -l)
    ((FILES_FOUND_TOTAL_BYTES+=FILES_FOUND_BYTES))
    ((FILES_FOUND_TOTAL_FILES+=FILES_FOUND_FILES))
  done
  if [ $FILES_FOUND_TOTAL_FILES -gt 0 ];
  then
    QUESTION_TEXT=" ${light_cyan}Nutzungsdaten von Dateien${colors_off} löschen (${light_purple}$FILES_FOUND_TOTAL_FILES Dateien, "
    QUESTION_TEXT+=$(show_human_bytes "$FILES_FOUND_TOTAL_BYTES")
    QUESTION_TEXT+="${colors_off})"
    ask_yes_or_no "$QUESTION_TEXT"
    if [ $? -eq 1 ];
    then
      e_and_l -n " Löschen gespeicherter ${light_yellow}Datei-Nutzungsdaten${colors_off}  ... "
      for search_mask in ${SEARCH_FILE_LIST[@]};
      do
        # Zur Sicherheit nur löschen, wenn der Pfad nicht versehentlich leer
        # ist und dadurch der gesamte Home-Ordner gelöscht würde ... ;o)
        if [ "$search_mask" != "" ];
        then
          SEARCH_FILE_MASK="$USER_HOME_DIR/$search_mask"
          rm -f ${SEARCH_FILE_MASK} &>"$LOG_TEMP"
        fi
      done
      if [ $? -eq 0 ];
      then
        e_and_l "$OK_TAG"
      else
        e_and_l "$ERROR_TAG"
        add_full_log
      fi
    fi
  else
    e_and_l "$ACTION_MESSAGE$ND_TAG"
  fi

  # ===========================================================================
  # Alle eigenen Dateien auch zu eigen machen (all my files belong to me ;)
  # ===========================================================================
  ACTION_MESSAGE=" Besitz-Zuordnungen ${light_cyan}eigener Dateien${colors_off} prüfen"
  if [ "$USER_USERNAME" != "root" ] &&
     [ $USER_UID -ge 1000 ];
  then
    ask_yes_or_no "$ACTION_MESSAGE"
    if [ $? -eq 1 ];
    then
      e_and_l -n " Korrigiere ${light_yellow}Besitzzuordnung${colors_off} eigener Dateien ... "
      if [ $(find "$USER_HOME_DIR" ! -user "$USER_USERNAME" | wc -l) -gt 1 ];
      then
        chown -R "$USER_USERNAME:$USER_USERNAME" "$USER_HOME_DIR" &>"$LOG_TEMP"
        if [ $? -eq 0 ];
        then
          e_and_l "$OK_TAG"
        else
          e_and_l "$ERROR_TAG"
          add_full_log
        fi
      else
        e_and_l "$NC_TAG"
      fi
    fi
  else
    e_and_l "$(skip_text "$ACTION_MESSAGE " "$NR_TXT")"
  fi

  e_and_l "$FULL_LINE"
fi

###############################################################################
# Einrichtung persönlicher System-Einstellungen (Personalisierung)
###############################################################################
if [ ${OPTION_FLAG[listonly]} -eq 0 ];
   [ ${OPTION_FLAG[personal]} -eq 1 ];
then
  e_and_l " ${bold_blue}Einrichtung persönlicher System-Einstellungen${colors_off}"
  # ask_yes_or_no " Persönliche Einstellungen einrichten"
  # if [ $? -eq 1 ];
  # then
    # -----------------------------------------------------------------------
    # Eingabe der Zugangsdaten zur Verifizierung auf dem Server
    # -----------------------------------------------------------------------
    read -i "$USER_USERNAME" -p " Bitte Benutzernamen eingeben: " -r TMP_USER_NAME
    TMP_USER_NAME="${TMP_USER_NAME:-$USER_USERNAME}"
    TMP_USER_NAME=$(echo "$TMP_USER_NAME" | tr -d -c '[:alnum:]_' | tr '[:upper:]' '[:lower:]')
    e_and_l -n " ${colors_off}Bitte Passwort für ${bold_yellow}${TMP_USER_NAME}${colors_off} eingeben: "
    stty -echo &>/dev/null
    read -r -s USER_PASSWORD
    stty echo &>/dev/null
    DOWNLOAD_FILE_URL="$RESSOURCE_DOWNLOADER"
    THE_TEMP_FILE="$DOWNLOAD_DIR/individual"
    DECODED_PASS=$(echo -n ${USER_PASSWORD} | md5sum | awk '{print $1}')
    CHECK_PASS=$(wget -nv --post-data="&c=1&u=$TMP_USER_NAME&p=$DECODED_PASS" -O "$THE_TEMP_FILE" "$DOWNLOAD_FILE_URL" &>/dev/null && cat "$THE_TEMP_FILE" 2>/dev/null)
    if [ "$CHECK_PASS" = "SUCCESS" ];
    then
      # ---------------------------------------------------------------------
      # Liste der Einstellungen und Aktionen definieren
      # ---------------------------------------------------------------------
      declare -A USER_CONF_NAM # Angezeigte Bezeichnungen
      declare -A USER_CONF_SRC # Quelldateien (OHNE Pfad, der wird über RESSOURCE_DOWNLOADER festgelegt)
      declare -A USER_CONF_DST # Zieldateien (MIT Pfad)
      declare -A USER_CONF_COM # Befehl, der nach dem Download der jeweiligen Quelldatei durchgeführt wird
      declare -A USER_CONF_MAO # Wenn "true", dann wird diese Aktion nur auf MATE ausgeführt
      declare -A USER_CONF_MSG # Meldung, die nach der Aktion angezeigt wird
      # Interne Index-Liste der durchzuführenden Einstellungen (NICHT identisch mit Paketnamen!)
      # USER_CONF_LIST=('backpics' 'desktopu' 'firewall' 'matemenu' 'bookmark' 'mimeapps' 'doublcmd' 'kateconf' 'geanycfg' 'smplayer' 'redshift' 'teamview')
      USER_CONF_LIST=('backpics' 'firewall' 'matemenu' 'bookmark' 'mimeapps' 'doublcmd' 'kateconf' 'geanycfg' 'smplayer' 'redshift' 'teamview')
      # Download der Hintergrundbilder
      USER_CONF_NAM[backpics]="Download der [cs]Dual-Monitor-Hintergrundbilder[ce]"
      USER_CONF_SRC[backpics]=""
      USER_CONF_DST[backpics]=""
      USER_CONF_COM[backpics]="wget_dir \"https://migano.de/download/lissy/res/wallpapers/\" \"/usr/share/backgrounds/wallpapers\" && chmod 0644 /usr/share/backgrounds/wallpapers/* &>/dev/null"
      USER_CONF_MAO[backpics]=""
      USER_CONF_MSG[backpics]=""
      # Einstellungen des Desktops und diverser Tools (vollständiger dconf-Baum!)
      # USER_CONF_NAM[desktopu]="Konfiguration von [cs]Desktop & diversen Tools[ce]"
      # USER_CONF_SRC[desktopu]="$DCONF_BASE_NAME.conf"
      # USER_CONF_DST[desktopu]=""
      # USER_CONF_COM[desktopu]="sudo -u ${USER_USERNAME} DBUS_SESSION_BUS_ADDRESS=\"unix:path=/run/user/${USER_UID}/bus\" dconf load / < \"$DOWNLOAD_DIR/${USER_CONF_SRC[desktopu]}\" &>/dev/null"
      # USER_CONF_MAO[desktopu]="true"
      # USER_CONF_MSG[desktopu]=""
      # Firewall-Regeln
      USER_CONF_NAM[firewall]="Eintragen der eingehenden [cs]Firewall-Regeln[ce]"
      USER_CONF_SRC[firewall]="ufw-config"
      USER_CONF_DST[firewall]=""
      USER_CONF_COM[firewall]="chmod a+x $DOWNLOAD_DIR/${USER_CONF_SRC[firewall]} && $DOWNLOAD_DIR/${USER_CONF_SRC[firewall]} &>/dev/null"
      USER_CONF_MAO[firewall]=""
      USER_CONF_MSG[firewall]=""
      # Favoriten Advanced MATE Menü
      USER_CONF_NAM[matemenu]="Favoriten für das [cs]Advanced MATE Menü[ce] setzen"
      USER_CONF_SRC[matemenu]="applications.list"
      USER_CONF_DST[matemenu]="${USER_CONFIG_DIR}/mate-menu/applications.list"
      USER_CONF_COM[matemenu]="cp -f $DOWNLOAD_DIR/${USER_CONF_SRC[matemenu]} ${USER_CONF_DST[matemenu]} &>/dev/null"
      USER_CONF_MAO[matemenu]="true"
      USER_CONF_MSG[matemenu]=""
      # Dateimanager Lesezeichen
      USER_CONF_NAM[bookmark]="Einrichten der [cs]Lesezeichen für Dateimanager[ce]"
      USER_CONF_SRC[bookmark]="bookmarks"
      USER_CONF_DST[bookmark]="${USER_CONFIG_DIR}/gtk-3.0/bookmarks"
      USER_CONF_COM[bookmark]="cp -f $DOWNLOAD_DIR/${USER_CONF_SRC[bookmark]} ${USER_CONF_DST[bookmark]} &>/dev/null"
      USER_CONF_MAO[bookmark]=""
      USER_CONF_MSG[bookmark]=""
      # Bevorzugte Anwendungen
      USER_CONF_NAM[mimeapps]="Festlegung der [cs]bevorzugten Anwendungen[ce]"
      USER_CONF_SRC[mimeapps]="mimeapps.list"
      USER_CONF_DST[mimeapps]="${USER_CONFIG_DIR}/mimeapps.list"
      USER_CONF_COM[mimeapps]="cp -f $DOWNLOAD_DIR/${USER_CONF_SRC[mimeapps]} ${USER_CONF_DST[mimeapps]} &>/dev/null"
      USER_CONF_MAO[mimeapps]=""
      USER_CONF_MSG[mimeapps]=""
      # Double-Commander
      USER_CONF_NAM[doublcmd]="Konfiguration des Programms [cs]DoubleCommander[ce]"
      USER_CONF_SRC[doublcmd]="doublecmd.7z"
      USER_CONF_DST[doublcmd]="${USER_CONFIG_DIR}"
      USER_CONF_COM[doublcmd]="7z x \"$DOWNLOAD_DIR/${USER_CONF_SRC[doublcmd]}\" -o\"${USER_CONF_DST[doublcmd]}\" -y &>/dev/null && chown -R \"$USER_USERNAME\":\"$USER_USERNAME\" $USER_CONFIG_DIR/doublecmd &>/dev/null"
      USER_CONF_MAO[doublcmd]=""
      USER_CONF_MSG[doublcmd]=""
      # Kate
      THE_KATE_VERSION=$(get_pkg_apt_version "kate" 1)
      if [ "$THE_KATE_VERSION" = "" ];
      then
        THE_KATE_VERSION=$(get_pkg_snap_version "kate" 1)
      fi
      THE_KATE_VERSION=$(echo -n "${THE_KATE_VERSION:0:2}" | xargs)
      if [ "$THE_KATE_VERSION" = "" ]; then THE_KATE_VERSION=0; fi
      USER_CONF_NAM[kateconf]="Konfiguration des Programms [cs]Kate$THE_KATE_VERSION (Editor)[ce]"
      if [ $THE_KATE_VERSION -lt 20 ];
      then
        # Kate bis Version 19 (einschließlich)
        # Alle Konfigurations-Dateien zum Überschreiben
        USER_CONF_SRC[kateconf]="kate-settings.7z"
        USER_CONF_DST[kateconf]="${USER_CONFIG_DIR}"
        USER_CONF_COM[kateconf]="7z x \"$DOWNLOAD_DIR/${USER_CONF_SRC[kateconf]}\" -o\"${USER_CONF_DST[kateconf]}\" -y &>/dev/null && chown \"$USER_USERNAME\":\"$USER_USERNAME\" $USER_CONFIG_DIR/kate* &>/dev/null"
        USER_CONF_MAO[kateconf]=""
        USER_CONF_MSG[kateconf]=""
      else
        # Kate ab Version 20 (Nur Farb-Codes zum manuellen Import)
        USER_CONF_SRC[kateconf]="kate_colors.theme"
        USER_CONF_DST[kateconf]=""
        USER_CONF_COM[kateconf]="mv -f \"${DOWNLOAD_DIR}/${USER_CONF_SRC[kateconf]}\" \"${DOWNLOAD_DIR}/kate_color_set.theme\" &>/dev/null"
        USER_CONF_MAO[kateconf]=""
        USER_CONF_MSG[kateconf]="Bitte die Datei ${light_yellow}kate_color_set.theme${colors_off} noch manuell importieren."
      fi
      # Geany
      USER_CONF_NAM[geanycfg]="Konfiguration des Programms [cs]Geany (Editor)[ce]"
      USER_CONF_SRC[geanycfg]="geany.7z"
      USER_CONF_DST[geanycfg]="${USER_CONFIG_DIR}"
      USER_CONF_COM[geanycfg]="7z x \"$DOWNLOAD_DIR/${USER_CONF_SRC[geanycfg]}\" -o\"${USER_CONF_DST[geanycfg]}\" -y &>/dev/null && chown -R \"$USER_USERNAME\":\"$USER_USERNAME\" $USER_CONFIG_DIR/geany &>/dev/null"
      USER_CONF_MAO[geanycfg]=""
      USER_CONF_MSG[geanycfg]=""
      # SMPlayer
      USER_CONF_NAM[smplayer]="Konfiguration des Programms [cs]SMPlayer[ce]"
      USER_CONF_SRC[smplayer]="smplayer.ini"
      USER_CONF_DST[smplayer]="${USER_CONFIG_DIR}/smplayer/smplayer.ini"
      USER_CONF_COM[smplayer]="cp -f $DOWNLOAD_DIR/${USER_CONF_SRC[smplayer]} ${USER_CONF_DST[smplayer]} &>/dev/null"
      USER_CONF_MAO[smplayer]=""
      USER_CONF_MSG[smplayer]=""
      # Redshift
      USER_CONF_NAM[redshift]="Konfiguration der [cs]Farbtemperaturanpassung[ce]"
      USER_CONF_SRC[redshift]="redshift.conf"
      USER_CONF_DST[redshift]="${USER_CONFIG_DIR}/redshift.conf"
      USER_CONF_COM[redshift]="cp -f $DOWNLOAD_DIR/${USER_CONF_SRC[redshift]} ${USER_CONF_DST[redshift]} &>/dev/null"
      USER_CONF_MAO[redshift]=""
      USER_CONF_MSG[redshift]=""
      # Teamviewer-Hintergrunddienst deaktivieren
      USER_CONF_NAM[teamview]="Deaktivierung [cs]Teamviewer[ce] Hintergrunddienst"
      USER_CONF_SRC[teamview]=""
      USER_CONF_DST[teamview]=""
      USER_CONF_COM[teamview]="teamviewer daemon disable &>/dev/null"
      USER_CONF_MAO[teamview]=""
      USER_CONF_MSG[teamview]=""
      # ---------------------------------------------------------------------
      # Einstellungen durchführen
      # (Datei downloaden und zugehörigen Befehl ausführen)
      # ---------------------------------------------------------------------
      e_and_l "$OK_TAG"
      e_and_l "$HALF_LINE"
      for conf_name in ${USER_CONF_LIST[@]};
      do
        IDX_NAME="$conf_name"
        SHOW_NAME=${USER_CONF_NAM[$IDX_NAME]}
        SHOW_NAME=${SHOW_NAME//\[cs\]/${light_cyan}}
        SHOW_NAME=${SHOW_NAME//\[ce\]/${colors_off}}
        ANZ_SPACES=62
        if [ ${OPTION_FLAG[nocolor]} -eq 1 ]; then ((ANZ_SPACES-=17)); fi
        ((ANZ_SPACES-=${#SHOW_NAME}))
        ACTION_MESSAGE=" $SHOW_NAME"
        i=1; while [ $i -lt $ANZ_SPACES ]; do ACTION_MESSAGE+=" "; ((i+=1)); done
        ACTION_MESSAGE+="... "
        if [ "$DESKTOP_ENVIRONMENT" = "MATE" ] ||
           [ "${USER_CONF_MAO[$IDX_NAME]}" != "true" ];
        then
          ask_yes_or_no " $SHOW_NAME"
          DO_THE_CONFIG=$?
          if [ $DO_THE_CONFIG -eq 1 ];
          then
            e_and_l -n "${ACTION_MESSAGE//96m/93m}"
            # --------------------------------------------------------------
            # Bei dconf-Änderung ("desktopu") zusätzliches Backup erstellen
            # --------------------------------------------------------------
            # if [ "$IDX_NAME" = "desktopu" ];
            # then
            #   sudo -u ${USER_USERNAME} DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/${USER_UID}/bus" dconf dump / 1>${DCONF_USER_BACKUP} 2>/dev/null
            #   chown "$USER_USERNAME:$USER_USERNAME" "${DCONF_USER_BACKUP}" &>/dev/null
            #   chmod 0664 "${DCONF_USER_BACKUP}" &>/dev/null
            # fi
            # ----------------------------------------------------------
            # Wenn keine Datei im Spiel ist, nur Kommando ausführen ...
            # ----------------------------------------------------------
            if [ "${USER_CONF_SRC[$IDX_NAME]}" = "" ] &&
               [ "${USER_CONF_DST[$IDX_NAME]}" = "" ];
            then
              { eval "${USER_CONF_COM[$IDX_NAME]}" 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
              if [ $(cat "$LAST_EXIT_CODE") -eq 0 ];
              then
                e_and_l "$OK_TAG"
              else
                e_and_l "$ERROR_TAG $LINENO"
                add_full_log
              fi
            else # ... sonst Datei downloaden ...
              DOWNLOAD_FILE_NAME=${USER_CONF_SRC[$IDX_NAME]}
              DOWNLOAD_FILE_URL="$RESSOURCE_DOWNLOADER/cfg/$DOWNLOAD_FILE_NAME"
              LOCAL_DOWNLOAD_FILE="$DOWNLOAD_DIR/$DOWNLOAD_FILE_NAME"
              wget -nv --post-data="&u=$USER_USERNAME&p=$DECODED_PASS" -O "$LOCAL_DOWNLOAD_FILE" "$DOWNLOAD_FILE_URL" &>"$LOG_TEMP"
              if [ $? -eq 0 ] &&
                 [ -s "$LOCAL_DOWNLOAD_FILE" ] &&
                 [ $(grep -i -c -E "Error\s*404" "$LOCAL_DOWNLOAD_FILE") -eq 0 ];
              then
                chown "$USER_USERNAME:$USER_USERNAME" "$LOCAL_DOWNLOAD_FILE" &>/dev/null
                PERSONAL_ACTION_RESULT=0
                # ... wenn nach dem Download etwas getan werden soll,
                # dann die entsprechenden Aktionen durchführen
                if [ "${USER_CONF_COM[$IDX_NAME]}" != "" ];
                then
                  DO_SOME_ACTION=1
                  # Wenn eine Datei kopiert werden soll ...
                  if [ $(echo "${USER_CONF_COM[$IDX_NAME]}" | grep -i -c -E "cp -f ") -gt 0 ];
                  then
                    # Ziel-Ordner anlegen, falls noch nicht vorhanden
                    # (sicherheitshalber nur innerhalb des eigenen Benutzerordners)
                    THE_DST_DIR="${USER_CONF_DST[$IDX_NAME]%/*}"
                    if [ $(echo -n "${USER_CONF_DST[$IDX_NAME]}" | grep -i -c -E "${USER_HOME_DIR}" 2>/dev/null) -gt 0 ] &&
                       [ ! -d "$THE_DST_DIR" ];
                    then
                      mkdir -p "$THE_DST_DIR" &>/dev/null
                      chown -R "$USER_USERNAME:$USER_USERNAME" "$THE_DST_DIR" &>/dev/null
                    fi
                    # Nichts machen wenn Zieldatei und Quelldatei identisch sind ;)
                    if
                      [ -f "$LOCAL_DOWNLOAD_FILE" ] &&
                      [ -f "${USER_CONF_DST[$IDX_NAME]}" ];
                    then
                      diff "$LOCAL_DOWNLOAD_FILE" "${USER_CONF_DST[$IDX_NAME]}" &>/dev/null
                      DO_SOME_ACTION=$?
                    fi
                  fi
                  # Wenn die vorherige Prüfung ergeben hat, dass etwas zu tun ist,
                  # dann entsprechende Aktion durchführen ...
                  if [ $DO_SOME_ACTION -ne 0 ];
                  then
                    if [ -s "${USER_CONF_DST[$IDX_NAME]}" ] &&
                       [ ! -d "${USER_CONF_DST[$IDX_NAME]}" ];
                    then
                      create_backup_file "${USER_CONF_DST[$IDX_NAME]}"
                    fi
                    { eval "${USER_CONF_COM[$IDX_NAME]}" 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$LOG_TEMP"
                    if [ $(cat "$LAST_EXIT_CODE") -eq 0 ];
                    then
                      e_and_l "$OK_TAG"
                      if [ $(echo -n "${USER_CONF_DST[$IDX_NAME]}" | grep -i -c -E "${USER_HOME_DIR}" 2>/dev/null) -gt 0 ] &&
                         [ -f "${USER_CONF_DST[$IDX_NAME]}" ];
                      then
                        chown "$USER_USERNAME:$USER_USERNAME" "${USER_CONF_DST[$IDX_NAME]}" &>/dev/null
                        chmod 0664 "${USER_CONF_DST[$IDX_NAME]}" &>/dev/null
                      fi
                    else
                      e_and_l "$ERROR_TAG $LINENO"
                      PERSONAL_ACTION_RESULT=1
                      add_full_log
                    fi
                  else
                    # e_and_l "$NC_TAG"
                    # Um keine Verwirrung zu stiften, immer einfach nur OK anzeigen,
                    # selbst wenn es keine Änderung der Konfiguration gegeben hat ;)
                    e_and_l "$OK_TAG"
                  fi
                else
                  e_and_l "$OK_TAG"
                fi
                # Optionale Meldung anzeigen ...
                if [ $PERSONAL_ACTION_RESULT -eq 0 ] &&
                   [ "${USER_CONF_MSG[$IDX_NAME]}" != "" ];
                then
                  e_and_l " $HINWEIS_TAG: ${USER_CONF_MSG[$IDX_NAME]}"
                fi
              else
                # e_and_l "${bold_red}Daten nicht von diesem System${colors_off}"
                e_and_l "$ERROR_TAG"
                add_full_log
              fi
            fi
            remove_file "$LAST_EXIT_CODE"
            remove_file "$LOCAL_DOWNLOAD_FILE"
          fi
        else
          e_and_l -n "$ACTION_MESSAGE${light_yellow}wird übersprungen${colors_off}"
        fi
      done
    else
      e_and_l "${bold_red}Ungültige Zugangsdaten${colors_off}"
    fi
    remove_file "$THE_TEMP_FILE"
  # fi
  e_and_l "$FULL_LINE"
fi

###############################################################################
# Desktop- und Anwendungs-Einstellungen speichern oder wiederherstellen
###############################################################################
if [ ${OPTION_FLAG[listonly]} -eq 0 ];
then
  if [ ${OPTION_FLAG[dload]} -eq 1 ] ||
     [ ${OPTION_FLAG[dsave]} -eq 1 ];
  then
    if [ ${OPTION_FLAG[dload]} -eq 1 ] &&
       [ ${OPTION_FLAG[dsave]} -eq 1 ];
    then
      e_and_l " ${bold_blue}Desktop- und Anwendungs-Einstellungen${colors_off}"
      e_and_l " $ERROR_TAG: Die Aktionen ${bold_white}dload${colors_off} und ${bold_white}dsave${colors_off} können nicht zusammen ausgeführt werden!"
    else
      # -----------------------------------------------------------------------
      # Speichern
      # -----------------------------------------------------------------------
      if [ ${OPTION_FLAG[dsave]} -eq 1 ];
      then
        e_and_l " ${bold_blue}Desktop- und Anwendungs-Einstellungen speichern${colors_off}"
        DO_SAVE_FILE=1
        if [ -s "$DCONF_USER_FILE" ];
        then
          FILE_DATE=$(date -r ${DCONF_USER_FILE} "+%d.%m.%Y %H:%M:%S")
          e_and_l " Es ist schon eine Sicherungsdatei vom ${bold_cyan}$FILE_DATE${colors_off} vorhanden!"
          ask_yes_or_no " Bestehende Sicherungsdatei überschreiben"
          DO_SAVE_FILE=$?
        fi
        if [ $DO_SAVE_FILE -eq 1 ];
        then
          create_backup_file "$DCONF_USER_FILE"
          e_and_l -n " Erstelle Sicherungsdatei ${bold_yellow}${DCONF_USER_FILE##*/}${colors_off} ... "
          sudo -u ${USER_USERNAME} DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/${USER_UID}/bus" dconf dump / 1>${DCONF_USER_FILE} 2>/dev/null
          if [ $? -eq 0 ];
          then
            chown "$USER_USERNAME:$USER_USERNAME" "${DCONF_USER_FILE}" &>/dev/null
            chmod 0664 "${DCONF_USER_FILE}" &>/dev/null
            e_and_l "$OK_TAG"
          else
            e_and_l "$ERROR_TAG"
          fi
        fi
      fi
      # -----------------------------------------------------------------------
      # Laden
      # -----------------------------------------------------------------------
      if [ ${OPTION_FLAG[dload]} -eq 1 ];
      then
        e_and_l " ${bold_blue}Desktop- und Anwendungs-Einstellungen wiederherstellen${colors_off}"
        if [ -s "$DCONF_USER_FILE" ];
        then
          FILE_DATE=$(date -r ${DCONF_USER_FILE} "+%d.%m.%Y %H:%M:%S")
          e_and_l " Die Sicherungsdatei hat das Datum ${bold_cyan}$FILE_DATE${colors_off}. Alle aktuellen"
          ask_yes_or_no " Einstellungen auf diesen Stand zurücksetzen" "$DCONF_USER_FILE"
          if [ $? -eq 1 ];
          then
            e_and_l -n " Sichere aktuelle Einstellungen in ${bold_yellow}${DCONF_USER_BACKUP##*/}${colors_off} ... "
            sudo -u ${USER_USERNAME} DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/${USER_UID}/bus" dconf dump / 1>${DCONF_USER_BACKUP} 2>/dev/null
            if [ $? -eq 0 ];
            then
              chown "$USER_USERNAME:$USER_USERNAME" "${DCONF_USER_BACKUP}" &>/dev/null
              chmod 0664 "${DCONF_USER_BACKUP}" &>/dev/null
              e_and_l "$OK_TAG"
              e_and_l -n " Stelle Einstellungen aus der Sicherungsdatei wieder her ... "
              sudo -u ${USER_USERNAME} DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/${USER_UID}/bus" dconf load / < ${DCONF_USER_FILE} &>/dev/null
              if [ $? -eq 0 ];
              then
                e_and_l "$OK_TAG"
              else
                e_and_l "$ERROR_TAG"
              fi
            else
              e_and_l "$ERROR_TAG"
            fi
          fi
        else
          e_and_l " $ERROR_TAG: Keine Sicherungsdaten gefunden!"
        fi
      fi
    fi
    e_and_l "$FULL_LINE"
  fi
fi

###############################################################################
# Entfernen eines Programmpakets mit zugehörigen Daten
###############################################################################
if [ ${OPTION_FLAG[remove]} -eq 1 ] &&
   [ "$REMOVE_PKG_NAME" != "" ];
then
  # ---------------------------------------------------------------------------
  # Option zur Entfernung ermitteln
  # ---------------------------------------------------------------------------
  declare -A REMOVE_TEXT
  REMOVE_TEXT[0]="Abbrechen, Programmpaket nicht entfernen"
  REMOVE_TEXT[1]="Programm entfernen und Konfiguration behalten"
  REMOVE_TEXT[2]="Programm und dessen Konfiguration entfernen"
  REMOVE_TEXT[3]="Programm und alle zugehörigen Daten enfernen"
  REMOVE_ACTION=-1
  e_and_l " ${bold_blue}Entfernen eines Programmpakets mit zugehörigen Daten${colors_off}"
  e_and_l "$HALF_LINE"
  get_install_status "$REMOVE_PKG_NAME"
  INST_STATUS=$?
  if [ $INST_STATUS -ne 0 ];
  then
    # -------------------------------------------------------------------------
    # Prüfen ob mehrere Versionen installiert sind und Auswahl dazu anzeigen
    # -------------------------------------------------------------------------
    INST_MODE_LIST="0"
    if [ $(LANG=en dpkg-query -W -f='${Status}' "$REMOVE_PKG_NAME" 2>/dev/null | grep -i -c -E "ok installed") -ne 0 ];
    then
      INST_MODE_LIST+=",1"
    fi
    if [ $SNAP_INSTALLED -ne 0 ];
    then
      if [ $(LANG=en snap info "$REMOVE_PKG_NAME" 2>/dev/null | grep -i -c -E "installed\:") -ne 0 ];
      then
        INST_MODE_LIST+=",2"
      fi
    fi
    OPT_PKG_INST_NAME="${DEB_PKG_NAME[$REMOVE_PKG_NAME]}"
    if [ "$OPT_PKG_INST_NAME" = "" ];
    then
      OPT_PKG_INST_NAME="${WEB_PKG_NAME[$REMOVE_PKG_NAME]}"
      if [ "$OPT_PKG_INST_NAME" = "" ];
      then
        OPT_PKG_INST_NAME="$REMOVE_PKG_NAME"
      fi
    fi
    if [ -d "/opt/$OPT_PKG_INST_NAME" ];
    then
      INST_MODE_LIST+=",3"
    fi
    WEB_PKG_INST_NAME="${WEB_PKG_NAME[$REMOVE_PKG_NAME]}"
    if [ "$WEB_PKG_INST_NAME" = "" ];
    then
      WEB_PKG_INST_NAME="$REMOVE_PKG_NAME"
    fi
    if [ -d "$WEB_PKG_DIR/$WEB_PKG_INST_NAME" ];
    then
      INST_MODE_LIST+=",4"
    fi
    if [ ${#INST_MODE_LIST} -gt 3 ]; # "0,n" z.B. "0,2,4"
    then
      e_and_l " Das Programm ${bold_yellow}$REMOVE_PKG_NAME${colors_off} ist mehrfach installiert:"
      if [ $(echo "$INST_MODE_LIST" | grep -c -E ",1") -ne 0 ];
      then
        TMP_PKG_VERSION=$(get_pkg_apt_version "$REMOVE_PKG_NAME" 0)
        e_and_l -n " [${bold_white}1${colors_off}] "
        if [ "$TMP_PKG_VERSION" != "" ]; then e_and_l -n "Version $TMP_PKG_VERSION "; fi
        e_and_l "als Paket aus dem Standard-Repository"
      fi
      if [ $(echo "$INST_MODE_LIST" | grep -c -E ",2") -ne 0 ];
      then
        TMP_PKG_VERSION=$(get_pkg_snap_version "$REMOVE_PKG_NAME" 0)
        e_and_l -n " [${bold_white}2${colors_off}] "
        if [ "$TMP_PKG_VERSION" != "" ]; then e_and_l -n "Version $TMP_PKG_VERSION "; fi
        e_and_l "als Snap-Paket"
      fi
      if [ $(echo "$INST_MODE_LIST" | grep -c -E ",3") -ne 0 ];
      then
        TMP_PKG_VERSION=$(get_pkg_deb_version "$REMOVE_PKG_NAME")
        e_and_l -n " [${bold_white}3${colors_off}] "
        if [ "$TMP_PKG_VERSION" != "" ]; then e_and_l -n "Version $TMP_PKG_VERSION "; fi
        e_and_l "in /opt/$OPT_PKG_INST_NAME"
      fi
      if [ $(echo "$INST_MODE_LIST" | grep -c -E ",4") -ne 0 ];
      then
        TMP_PKG_VERSION=$(get_pkg_web_version "$REMOVE_PKG_NAME")
        e_and_l -n " [${bold_white}4${colors_off}] "
        if [ "$TMP_PKG_VERSION" != "" ]; then e_and_l -n "Version $TMP_PKG_VERSION "; fi
        e_and_l "in $WEB_PKG_DIR/$WEB_PKG_INST_NAME"
      fi
      e_and_l -n " Bitte auswählen, welche Version entfernt werden soll: "
      INST_STATUS=0
      while [ $INST_STATUS -eq 0 ];
      do
        read -N 1 -r -s INST_STATUS
        INST_STATUS=$(echo $INST_STATUS | sed 's/[^0-9]*//g')
        if [ "$INST_STATUS" = "" ] ||
           [ $(echo "$INST_MODE_LIST" | grep -c -E "$INST_STATUS") -eq 0 ];
        then
          INST_STATUS=0
        fi
      done
      e_and_l "$INST_STATUS"
    fi
    # -------------------------------------------------------------------------
    case $INST_STATUS in
      1) TMP_PKG_TYPE="STD"  ;;
      2) TMP_PKG_TYPE="SNAP" ;;
      3) TMP_PKG_TYPE="DEB"  ;;
      4) TMP_PKG_TYPE="WEB"  ;;
    esac
    echo -e ""
    e_and_l " Optionen zur Entfernung von ${bold_yellow}$REMOVE_PKG_NAME${colors_off} (${bold_purple}$TMP_PKG_TYPE${colors_off}):"
    i=0
    while [ $i -lt 4 ];
    do
      e_and_l " [${bold_white}$i${colors_off}] ${REMOVE_TEXT[$i]}"
      ((i+=1))
    done
    while [ $REMOVE_ACTION -lt 0 ];
    do
      e_and_l -n " Bitte eine Option auswählen: "
      while [ $REMOVE_ACTION -lt 0 ] ||
            [ $REMOVE_ACTION -gt 3 ];
      do
        read -N 1 -r -s REMOVE_ACTION
        REMOVE_ACTION=$(echo $REMOVE_ACTION | sed 's/[^0-9]*//g')
        if [ "$REMOVE_ACTION" = "" ]; then REMOVE_ACTION=-1; fi
      done
      if [ $REMOVE_ACTION -eq 0 ];
      then
        e_and_l "Abbruch"
      else
        e_and_l "$REMOVE_ACTION"
        ask_yes_or_no " Wirklich ${REMOVE_TEXT[$REMOVE_ACTION]}"
        if [ $? -eq 0 ];
        then
          REMOVE_ACTION=-1
        fi
      fi
    done
  else
    e_and_l " Das Programmpaket ${bold_yellow}$REMOVE_PKG_NAME${colors_off} scheint nicht installiert zu sein."
    ask_yes_or_no " Sollen hinterbliebene Daten gesucht werden"
    if [ $? -eq 1 ];
    then
      REMOVE_ACTION=3
    fi
  fi
  echo -e ""
  # ---------------------------------------------------------------------------
  # Entfernung je nach Installationsart durchführen
  # ---------------------------------------------------------------------------
  if [ $REMOVE_ACTION -gt 0 ];
  then
    # Nicht installiertes Paket, "nur" hinterbliebene Daten löschen
    if [ $INST_STATUS -eq 0 ];
    then
      e_and_l " ${light_blue}Schritt 1/3:${colors_off} Löschen verbliebener Paketrückstände"
      echo -e " Starte Suche, bitte warten ... $FERTIG_TAG"
      TMP_PURGE_OUT="$DOWNLOAD_DIR/purge_output.tmp"
      if [ $(apt list "$REMOVE_PKG_NAME" -a 2>/dev/null | grep -c -i -E "$REMOVE_PKG_NAME") -gt 0 ];
      then
        { apt purge "$REMOVE_PKG_NAME" -y 2>&1; echo -e -n "$?" > "$LAST_EXIT_CODE"; } | tee "$TMP_PURGE_OUT"
        # REMOVE_RESULT=$(cat "$LAST_EXIT_CODE")
      fi
      if [ ! -s "$TMP_PURGE_OUT" ];
      then
        e_and_l " Es sind keine Paketrückstände mehr vorhanden ... $OK_TAG"
      fi
      remove_file "$TMP_PURGE_OUT"
      remove_file "$LAST_EXIT_CODE"
      remove_snapshots "$REMOVE_PKG_NAME"
      remove_ico "$REMOVE_PKG_NAME"
      remove_cfg "$REMOVE_PKG_NAME" 1
      remove_dat "$REMOVE_PKG_NAME"
    fi
    # Standard-Paketverwaltung (apt) und Snaps
    if [ $INST_STATUS -eq 1 ] ||
       [ $INST_STATUS -eq 2 ];
    then
      e_and_l -n " ${light_blue}Schritt 1/$REMOVE_ACTION:${colors_off}"
      REMOVE_RESULT=-1
      if [ $REMOVE_ACTION -eq 1 ];
      then
        remove_pkg "$REMOVE_PKG_NAME" 0 # remove
      else
        remove_pkg "$REMOVE_PKG_NAME" 1 # purge
      fi
      # Bei Snap auch noch die Snapschüsse löschen
      if [ $INST_STATUS -eq 2 ];
      then
        remove_snapshots "$REMOVE_PKG_NAME"
      fi
      if [ $REMOVE_RESULT -eq 0 ];
      then
        # Starter nur für einfache Standard-Pakete entfernen, da
        # dummes Snap eigene Starter unterschiedlich speichert ...
        if [ $INST_STATUS -eq 1 ];
        then
          remove_ico "$REMOVE_PKG_NAME"
        fi
        if [ $REMOVE_ACTION -gt 1 ];
        then
          remove_cfg "$REMOVE_PKG_NAME" 0
        fi
        if [ $REMOVE_ACTION -gt 2 ];
        then
          remove_dat "$REMOVE_PKG_NAME"
        fi
      fi
    fi
    # Ordner mit ausführbaren Dateien
    if [ $INST_STATUS -eq 3 ] ||
       [ $INST_STATUS -eq 4 ];
    then
      e_and_l " ${light_blue}Schritt 1/$REMOVE_ACTION:${colors_off} Löschen von ${bold_yellow}$REMOVE_PKG_NAME${colors_off} ..."
      THE_PKG_INST_DIR=""
      if [ $INST_STATUS -eq 3 ] &&
         [ "$OPT_PKG_INST_NAME" != "" ];
      then
        THE_PKG_INST_DIR="/opt/$OPT_PKG_INST_NAME"
      fi
      if [ $INST_STATUS -eq 4 ] &&
         [ "$WEB_PKG_INST_NAME" != "" ];
      then
        THE_PKG_INST_DIR="$WEB_PKG_DIR/$WEB_PKG_INST_NAME"
      fi
      if [ "$THE_PKG_INST_DIR" != "" ] &&
         [ -d "$THE_PKG_INST_DIR" ];
      then
        # Wenn es ein Skript oder Programm zur De-Installation gibt,
        # dann Hinweis darauf anzeigen und weiter nichts machen ...
        REMOVE_SCRIPT_FOUND=""
        REMOVE_SCRIPT_LIST="uninstall uninstall.sh deinstall deinstall.sh remove remove.sh"
        for rm_script in ${REMOVE_SCRIPT_LIST[@]};
        do
          if [ -s "$THE_PKG_INST_DIR/${rm_script}" ];
          then
            REMOVE_SCRIPT_FOUND="$THE_PKG_INST_DIR/$rm_script"
            break
          fi
        done
        if [ "$REMOVE_SCRIPT_FOUND" != "" ];
        then
          e_and_l " $ACHTUNG_TAG: Das Programm verfügt über ein eigenes De-Installations-Skript."
          e_and_l " Zu finden unter: ${light_yellow}$REMOVE_SCRIPT_FOUND${colors_off}"
          e_and_l " Bitte dieses zuerst manuell ausführen und danach nochmals versuchen."
        else # ... sonst Verzeichnis löschen
          rm -d -f -r "$THE_PKG_INST_DIR"
          if [ $? -eq 0 ];
          then
            e_and_l " Das Programm wurde aus ${light_yellow}$THE_PKG_INST_DIR${colors_off} entfernt ... $OK_TAG"
            remove_ico "$REMOVE_PKG_NAME"
            if [ $REMOVE_ACTION -gt 1 ];
            then
              remove_cfg "$REMOVE_PKG_NAME" 0
            fi
            if [ $REMOVE_ACTION -gt 2 ];
            then
              remove_dat "$REMOVE_PKG_NAME"
            fi
          else
            e_and_l " $ERROR_TAG: Das Programm konnte ${bold_red}nicht${colors_off} entfernt werden!"
          fi
        fi
      fi
    fi
    echo -e ""
  fi
  # ---------------------------------------------------------------------------
  e_and_l "$FULL_LINE"
fi

###############################################################################
# Aufräumen und Hinweise am Ende anzeigen
###############################################################################
clean_on_exit
e_and_l " ${bold_blue}Hinweise${colors_off}"
e_and_l "$HALF_LINE"
if [ -s "$USER_SCRIPT_CONFIG" ] ||
   [ -s "$USER_PAKET_LIST" ];
then
  e_and_l " Ordner mit gespeicherten Einstellungen: ${light_yellow}$SCRIPT_CONFIG_DIR${colors_off}"
fi
if [ ${OPTION_FLAG[listonly]} -eq 0 ];
then
  if [ $TOTAL_PACKS -gt 0 ];
  then
    if [ -d "$WEB_PKG_DIR" ] &&
       [ $(ls -1 "$WEB_PKG_DIR" | wc -w) -gt 0 ];
    then
      e_and_l " Ordner mit externen Programmen (WEB): ${light_yellow}$WEB_PKG_DIR${colors_off}"
    fi
  fi
  if [ -d "$DOWNLOAD_DIR" ] &&
     [ $(ls -1 "$DOWNLOAD_DIR" | wc -w) -gt 0 ];
  then
    e_and_l " Ordner mit gespeicherten Dateien: ${light_yellow}$DOWNLOAD_DIR${colors_off}"
  fi
  if [ -s "$DCONF_USER_BACKUP" ];
  then
    e_and_l "$FULL_LINE"
    e_and_l " $ACHTUNG_TAG: Es liegt ein Konfigurations-Backup für ${light_cyan}Desktop & diverse Tools${colors_off} vor."
    e_and_l " Zurücksetzen der Einstellungen auf diese Konfiguration (ohne sudo):"
    e_and_l " ${light_purple}dconf load / < ${DCONF_USER_BACKUP}${colors_off}"
  fi
else
  e_and_l " Wenn die Option ${bold_white}listonly${colors_off} zur Auflistung der Paketnamen angegeben ist, werden"
  e_and_l " alle anderen angegebenen Optionen außer der Kategorieauswahl ignoriert."
fi
e_and_l "$FULL_LINE"
if [ $NO_MENU -eq 0 ];
then
  echo -e " Aufruf per Kommandozeile:"
  echo -e " ${light_yellow}$SCRIPT_NAME $COMMAND_LINE_STRING nomenu${colors_off}"
  echo -e "$FULL_LINE"
fi
e_and_l " ${bold_green}Alles erledigt${colors_off}. Auf Wiedersehen ..."
e_and_l "$FULL_LINE"

###############################################################################
# Ende
###############################################################################
